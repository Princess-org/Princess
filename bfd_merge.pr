import bfd
import map
import vector

const file_a = "A.o"
const file_b = "B.o"
const file_r = "AB2.o"

type Section = struct {
    offsets: &Map(&Section, size_t)
    section: *s_bfd_section
    name: &string
    size: size_t // Size of the entire section
    data: *
    relocations: Relocations
}

type Relocations = struct {
    count: size_t
    reloc: **s_reloc_cache_entry
    // TODO It would take less memory to have some sort of range based data structure
    // Because all we do here is add the same object to it in a loop
    origin: &Vector(&Object)
}

export def hash(sec: &Section) -> uint64 {
    return sec !*uint64 !uint64
}

type Object = struct {
    bfd: *s_bfd
    sections: &SMap(&Section)
    symtab: **s_bfd_symbol
    symbols: &Vector(&Symbol)
    sym_size: size_t
}

def find_symbol(o: &Object, name: Str) -> &Symbol {
    for var sym in o.symbols {
        if sym.name == name { return sym }
    }
    return null
}

def find_symbol(o: &Object, origin: &Object, section: &Section, reloc: *s_reloc_cache_entry) -> &Symbol {
    let addr = reloc.address !int64
    for var sym in o.symbols {
        let loc = sym.location !int64
        if sym.origin == origin and sym.section == section {
            if addr >= loc and addr < loc + sym.size {
                return sym
            }
        }
    }
    return null
}

def delete_symbol(o: &Object, name: Str) {
    for var i in 0..o.symbols.length {
        let sym = o.symbols[i]
        if sym.name == name {
            o.symbols.remove(i)
            return
        }
    }
}

def open_object_read(file: Str) -> &Object {
    let abfd = bfd_openr(file.to_array().value, null)
    bfd_check_format(abfd, e_bfd_format::bfd_object)
    return { abfd, sections = map::make(type &Section), symbols = vector::make(type &Symbol) } !&Object
}

def open_object_write(file: Str) -> &Object {
    let abfd = bfd_openw(file.to_array().value, null)
    bfd_set_format(abfd, e_bfd_format::bfd_object)
    return { abfd, sections = map::make(type &Section), symbols = vector::make(type &Symbol) } !&Object
}

def copy_arch_mach(to: &Object, frm: &Object) {
    to.bfd.xvec._bfd_set_arch_mach(to.bfd, bfd_get_arch(frm.bfd), bfd_get_mach(frm.bfd))
}

def delete(obj: &Object) {
    bfd_close(obj.bfd)
    free(obj.symtab)
    for var name in @obj.sections.keys() {
        let section = obj.sections[name]
        free(section.data)
        free(section.relocations.reloc)
    }
}

type Symbol = struct {
    origin: &Object
    name: Str
    symbol: *s_bfd_symbol
    section: &Section
    size: size_t
    offset: int64 // Offset based on deleted sections
    location: size_t // Original location based on the offset within a file
}

def bfd_asymbol_value(sy: *s_bfd_symbol) -> size_t {
    return sy.section.vma + sy.value
}

def initialize_section(res: &Object, name: Str) {
    let sec = bfd_get_section_by_name(res.bfd, name.to_array().value)
    if not sec { return }
    res.sections[name] = { section = sec, name = name.to_array(), offsets = map::make(type &Section, size_t), size = sec.size} !&Section
}

def load_section_data(obj: &Object, name: Str) {
    if not obj.sections.contains(name) { return }
    let section = obj.sections[name]
    var data = allocate(section.section.size)
    bfd_get_section_contents(obj.bfd, section.section, data, 0, section.section.size)
    section.data = data
}

def merge_section(res: &Object, obj_a: &Object, name: Str) {
    if not obj_a.sections.contains(name) { return }
    let a_sec = obj_a.sections[name]

    if res.sections.contains(name) {
        return
    }

    let section_name = name.to_array()
    let new_sec = bfd_make_section(res.bfd, section_name.value)
    bfd_set_section_flags(new_sec, a_sec.section.flags)
    bfd_set_section_size(new_sec, a_sec.section.size)
    new_sec.alignment_power = a_sec.section.alignment_power

    let section = { section = new_sec, name = section_name, offsets = map::make(type &Section, size_t), size = 0 } !&Section
    section.relocations.origin = vector::make(type &Object)
    res.sections[name] = section
}

def merge_section_data(res: &Object, obj_a: &Object, name: Str) {
    if not obj_a.sections.contains(name) { return }

    merge_section(res, obj_a, name)

    let a_sec = obj_a.sections[name]
    let new_sec = res.sections[name]

    let sz = a_sec.section.size
    
    var offset: size_t = new_sec.size
    var data = reallocate(new_sec.data !*char, offset + sz)

    // Initialize relocations
    let rel_sz = bfd_get_reloc_upper_bound(obj_a.bfd, a_sec.section)
    if rel_sz > 0 {
        let relent = allocate(rel_sz) !**s_reloc_cache_entry
        let count = bfd_canonicalize_reloc(obj_a.bfd, a_sec.section, relent, obj_a.symtab)

        if count > 0 {
            let new_sz = (count + new_sec.relocations.count) * size_of *s_reloc_cache_entry
            let out = reallocate(new_sec.relocations.reloc, new_sz)
            memcopy(relent, out ++ new_sec.relocations.count, count * size_of *s_reloc_cache_entry)

            new_sec.relocations.reloc = out
            new_sec.relocations.count += count

            for var i in 0..count {
                let rel = relent[i]
                let sym_name = make_string((@rel.sym_ptr_ptr).name)
                let sym = find_symbol(obj_a, sym_name)
                rel.address += offset
            }
              
            for var i in 0..count {
                new_sec.relocations.origin.push(obj_a)
            }
        }

        free(relent)
    }

    memcopy(a_sec.data, data ++ offset, a_sec.section.size)
    new_sec.offsets[a_sec] = offset

    new_sec.data = data
    new_sec.size += sz

    bfd_set_section_size(new_sec.section, new_sec.size)
}

def write_section_data(res: &Object, name: Str) {
    if not res.sections.contains(name) { return }
    let sec = res.sections[name]
    bfd_set_section_contents(res.bfd, sec.section, sec.data, 0, sec.size)

    // Write relocations
    let count = sec.relocations.count
    let relent = sec.relocations.reloc
    if count > 0 {
        for var i in 0..count {
            let rel = relent[i]
            let sym_name = make_string((@rel.sym_ptr_ptr).name)
            let sym = find_symbol(res, sec.relocations.origin[i], sec, rel)
            rel.sym_ptr_ptr = *find_symbol(res, sym_name).symbol

            if sym {
                rel.address += sym.offset
            }
        }
        res.bfd.xvec._bfd_set_reloc(res.bfd, sec.section, relent, count !uint)
    }
}

def load_symbols(res: &Object) {
    let a_sz = res.bfd.xvec._bfd_get_symtab_upper_bound(res.bfd)
    let syms = allocate(a_sz) !**s_bfd_symbol
    let cnta = res.bfd.xvec._bfd_canonicalize_symtab(res.bfd, syms)
    
    res.symtab = syms

    // TODO This relies on symbols being ordered
    var i = 0
    while i < cnta {
        var sym = syms[i]
        let sec_name = make_string(sym.section.name)
        let sym_name = make_string(sym.name)

        var section: &Section
        if not is_abs_section(sym.section) and res.sections.contains(sec_name) {
            section = res.sections[sec_name]
        }

        var offset: size_t = bfd_asymbol_value(sym) 
        var size: size_t = 0

        if section and sec_name != sym_name {
            if i + 1 < cnta {
                let next_sym = syms[i + 1]
                if make_string(next_sym.section.name) != sec_name {
                    size = section.size - offset
                } else {
                    size = bfd_asymbol_value(next_sym) - offset
                }
            } else {
                size = section.size - offset
            }
        }
        
        let out_sym = { res, sym_name, sym, section, size } !&Symbol
        res.symbols.push(out_sym)
        res.sym_size += 1
        i += 1
    }
}

// returns the difference in size when a symbol is deleted
def remove_symbol(res: &Object, name: Str) -> int {
    if find_symbol(res, name) == null { return 0 }
    let sym = find_symbol(res, name)
    let sec = sym.section

    delete_symbol(res, name)
    
    var size_diff = 0
    if sec { 
        // Purge the symbol from the section
        let data = allocate(sec.size - sym.size)
        memcopy(sec.data, data, sym.symbol.value)
        memcopy(sec.data ++ sym.symbol.value ++ sym.size, data ++ sym.symbol.value, sec.size - sym.symbol.value - sym.size)
        free(sec.data)
        sec.data = data

        // Actually shrink the section
        sec.size -= sym.size
        size_diff -= sym.size
    }

    var i = 0
    while i < res.sym_size {
        if make_string(res.symtab[i].name) == name {
            break
        }
        i += 1
    }

    let symtab = allocate(size_of **s_bfd_symbol * (res.sym_size - 1)) !**s_bfd_symbol
    memcopy(res.symtab, symtab, i * size_of **s_bfd_symbol)
    if res.sym_size - i > 0 {
        memcopy(res.symtab ++ i ++ 1, symtab ++ i, (res.sym_size - i - 1) * size_of **s_bfd_symbol) 
    }

    free(res.symtab)

    res.symtab = symtab
    res.sym_size -= 1

    if sec {
        for var sym2 in res.symbols {
            // Offset symbols
            if sym.section and sym2.symbol.value > sym.symbol.value and sym.section == sym2.section {
                sym2.symbol.value -= sym.size
                sym2.offset -= sym.size
            }
        }
    }

    return size_diff
}

// TODO There are in fact ways to do this without a string compare but it doesn't seem to work
def #inline is_und_section(section: *s_bfd_section) -> bool {
    return cstd::strcmp(section.name, "*UND*".value) == 0
}

def #inline is_abs_section(section: *s_bfd_section) -> bool {
    return cstd::strcmp(section.name, "*ABS*".value) == 0
}

type DuplicateEntry = struct {
    symbol: &Symbol
    from_section: &Section
}

def copy_symbols(to: &Object, frm: &Object) {
    to.symtab = reallocate(to.symtab, size_of *s_bfd_symbol * (frm.sym_size + to.sym_size)) !**s_bfd_symbol

    let duplicates = map::make(DuplicateEntry)
    
    var i = to.sym_size
    for var sym in frm.symbols {
        let name = sym.name
        let new_sym = to.bfd.xvec._bfd_make_empty_symbol(to.bfd)
        let section = frm.sections[sym.section.name] if sym.section else null
        let to_section = to.sections[sym.section.name] if sym.section else null

        var offset: int64 = 0
        if to_section and to_section.offsets.contains(section) {
            offset = to_section.offsets[section]
        }

        new_sym.name = sym.symbol.name
        if to_section {
            new_sym.section = to_section.section
        } else {
            new_sym.section = sym.symbol.section
        }
        new_sym.flags = sym.symbol.flags
        new_sym.value = sym.symbol.value + offset

        to.symtab[i] = new_sym
        let symbol = { frm, name, new_sym, to_section, sym.size, offset, sym.symbol.value } !&Symbol

        if not is_und_section(sym.symbol.section) {
            if find_symbol(to, name) != null {
                if name.starts_with(".") { continue }
                
                duplicates[name] = { symbol, section } !DuplicateEntry
                new_sym.value = sym.symbol.value
            } else {
                to.symbols.push(symbol)
                to.sym_size += 1
                i += 1
            }
        }
    }

    var size_diff = 0
    for var name in @duplicates.keys() {
        size_diff += remove_symbol(to, name)
    }

    to.symtab = reallocate(to.symtab, size_of *s_bfd_symbol * (frm.sym_size + duplicates.size)) !**s_bfd_symbol

    for var name in @duplicates.keys() {
        let entry = duplicates[name]
        let sym = entry.symbol
        
        if entry.symbol.section {
            sym.symbol.value += entry.symbol.section.offsets[entry.from_section]
        }

        sym.symbol.value = sym.symbol.value !int + size_diff
        sym.offset += size_diff

        to.symbols.push(sym)
        to.symtab[to.sym_size] = sym.symbol
        to.sym_size += 1
    }
}

def write_symbols(res: &Object) {
    bfd_set_symtab(res.bfd, res.symtab, res.sym_size !uint)
}

def main {
    let obj_a = open_object_read(file_a)
    let obj_b = open_object_read(file_b)
    let new_obj = open_object_write(file_r)
    new_obj.copy_arch_mach(obj_a)

    obj_a.initialize_section(".text")
    obj_a.initialize_section(".data")
    obj_a.initialize_section(".llvm_addrsig")

    obj_b.initialize_section(".text")
    obj_b.initialize_section(".data")
    obj_b.initialize_section(".llvm_addrsig")
    
    // Debug Symbols
    obj_a.initialize_section(".debug_abbrev")
    obj_a.initialize_section(".debug_info")
    obj_a.initialize_section(".debug_ranges")
    obj_a.initialize_section(".debug_str")
    obj_a.initialize_section(".debug_line")
    obj_a.initialize_section(".debug_pubnames")
    obj_a.initialize_section(".debug_pubtypes")

    obj_b.initialize_section(".debug_abbrev")
    obj_b.initialize_section(".debug_info")
    obj_b.initialize_section(".debug_ranges")
    obj_b.initialize_section(".debug_str")
    obj_b.initialize_section(".debug_line")
    obj_b.initialize_section(".debug_pubnames")
    obj_b.initialize_section(".debug_pubtypes")

    obj_a.load_symbols()
    obj_b.load_symbols()

    obj_a.load_section_data(".text")
    obj_a.load_section_data(".data")
    obj_a.load_section_data(".debug_abbrev")
    obj_a.load_section_data(".debug_info")
    obj_a.load_section_data(".debug_ranges")
    obj_a.load_section_data(".debug_str")
    obj_a.load_section_data(".debug_line")
    obj_a.load_section_data(".debug_pubnames")
    obj_a.load_section_data(".debug_pubtypes")
    obj_a.load_section_data(".llvm_addrsig")

    obj_b.load_section_data(".text")
    obj_b.load_section_data(".data")
    obj_b.load_section_data(".debug_abbrev")
    obj_b.load_section_data(".debug_info")
    obj_b.load_section_data(".debug_ranges")
    obj_b.load_section_data(".debug_str")
    obj_b.load_section_data(".debug_line")
    obj_b.load_section_data(".debug_pubnames")
    obj_b.load_section_data(".debug_pubtypes")
    obj_b.load_section_data(".llvm_addrsig")

    new_obj.merge_section_data(obj_a, ".text")
    new_obj.merge_section_data(obj_a, ".data")
    new_obj.merge_section_data(obj_a, ".debug_abbrev")
    new_obj.merge_section_data(obj_a, ".debug_info")
    new_obj.merge_section_data(obj_a, ".debug_ranges")
    new_obj.merge_section_data(obj_a, ".debug_str")
    new_obj.merge_section_data(obj_a, ".debug_line")
    new_obj.merge_section_data(obj_a, ".debug_pubnames")
    new_obj.merge_section_data(obj_a, ".debug_pubtypes")
    new_obj.merge_section_data(obj_a, ".llvm_addrsig")

    new_obj.merge_section_data(obj_b, ".text")
    new_obj.merge_section_data(obj_b, ".data")
    new_obj.merge_section_data(obj_b, ".debug_abbrev")
    new_obj.merge_section_data(obj_b, ".debug_info")
    new_obj.merge_section_data(obj_b, ".debug_ranges")
    new_obj.merge_section_data(obj_b, ".debug_str")
    new_obj.merge_section_data(obj_b, ".debug_line")
    new_obj.merge_section_data(obj_b, ".debug_pubnames")
    new_obj.merge_section_data(obj_b, ".debug_pubtypes")
    new_obj.merge_section_data(obj_b, ".llvm_addrsig")

    new_obj.copy_symbols(obj_a)
    new_obj.copy_symbols(obj_b)

    new_obj.write_symbols()

    new_obj.write_section_data(".text")
    new_obj.write_section_data(".data")
    new_obj.write_section_data(".debug_abbrev")
    new_obj.write_section_data(".debug_info")
    new_obj.write_section_data(".debug_ranges")
    new_obj.write_section_data(".debug_str")
    new_obj.write_section_data(".debug_line")
    new_obj.write_section_data(".debug_pubnames")
    new_obj.write_section_data(".llvm_addrsig")

    delete(new_obj)
    delete(obj_a)
    delete(obj_b)
}

main
