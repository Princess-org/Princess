import bfd
import libdwarf
import map
import vector
import linux

const file_a = "A.o"
const file_b = "B.o"
const file_r = "AB2.o"

const DW_AT_low_pc: ushort = 0x11
const DW_AT_high_pc: ushort = 0x12

const DW_DLA_STRING = 0x01
const DW_DLA_DIE = 0x08
const DW_DLA_LIST = 0x0f
const DW_DLA_ATTR = 0x0a

const DW_DLV_NO_ENTRY = -1

const DW_TAG_compile_unit = 0x11

type Section = struct {
    offsets: &Map(&Section, size_t)
    section: *s_bfd_section
    name: &string
    size: size_t // Size of the entire section
    data: *
    relocations: Relocations
}

type DebugSection = struct {
    section: *s_bfd_section
    name: Str
    index: int
    size: size_t
    data: *
}

type Relocations = struct {
    count: size_t
    reloc: **s_reloc_cache_entry
    // TODO It would take less memory to have some sort of range based data structure
    // Because all we do here is add the same object to it in a loop
    origin: &Vector(&Object)
}

export def hash(sec: &Section) -> uint64 {
    return sec !*uint64 !uint64
}

type Object = struct {
    bfd: *s_bfd
    sections: &SMap(&Section)
    symtab: **s_bfd_symbol
    symbols: &Vector(&Symbol)
    sym_size: size_t

    // DWARF
    dbg: *s_Dwarf_Debug_s
    pdbg: *s_Dwarf_P_Debug_s

    section_index: int
    debug_sections: &Vector(&DebugSection)
}

def find_symbol(o: &Object, name: Str) -> &Symbol {
    for var sym in o.symbols {
        if sym.name == name { return sym }
    }
    return null
}

def find_symbol(o: &Object, origin: &Object, section: &Section, reloc: *s_reloc_cache_entry) -> &Symbol {
    let addr = reloc.address !int64
    for var sym in o.symbols {
        let loc = sym.location !int64
        if sym.origin == origin and sym.section == section {
            if addr >= loc and addr < loc + sym.size {
                return sym
            }
        }
    }
    return null
}

def delete_symbol(o: &Object, name: Str) {
    for var i in 0..o.symbols.length {
        let sym = o.symbols[i]
        if sym.name == name {
            o.symbols.remove(i)
            return
        }
    }
}

def open_object_read(file: Str) -> &Object {
    let path = file.to_array()
    let abfd = bfd_openr(path.value, null)
    bfd_check_format(abfd, e_bfd_format::bfd_object)

    let obj = { abfd, sections = map::make(type &Section), symbols = vector::make(type &Symbol) } !&Object

    var error: *s_Dwarf_Error_s
    if dwarf_init_path(path.value, null, 0, 0, 0, null, null, *obj.dbg, null, 0, null, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    return obj
}

def bfd_write_callback(
    name: *char, size: int, tpe: uint64, 
    flags: uint64, link: uint64, info: uint64, 
    sect_name_index: *uint64, user_data: *, errorcode: *int) -> int {

    let obj = user_data !*Object
    
    if tpe != 9 { // 9 is for the rel section but don't ask me why
        
        let section = bfd_make_section(obj.bfd, name)

        obj.debug_sections.push({
            section = section,
            name = make_string(name),
            index = obj.section_index
        } !&DebugSection)
    }
    
    obj.section_index += 1
    return obj.section_index - 1
}

def open_object_write(file: Str) -> &Object {
    let path = file.to_array()
    let abfd = bfd_openw(path.value, null)
    bfd_set_format(abfd, e_bfd_format::bfd_object)

    let obj = { abfd, sections = map::make(type &Section), symbols = vector::make(type &Symbol), debug_sections = vector::make(type &DebugSection) } !&Object
    
    var error: *s_Dwarf_Error_s
    if dwarf_producer_init(
        DW_DLC_WRITE | /*symbolic relocations*/ 0x04000000 | /*little endian*/ 0x00100000 | /* 32 bit pointers */ 0x20000000,
        *bfd_write_callback, null, null, obj !*, "x86_64".value, "V4".value, null, *obj.pdbg, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    return obj
}

def copy_arch_mach(to: &Object, frm: &Object) {
    to.bfd.xvec._bfd_set_arch_mach(to.bfd, bfd_get_arch(frm.bfd), bfd_get_mach(frm.bfd))
}

def delete(obj: &Object) {
    bfd_close(obj.bfd)

    if obj.dbg {
        var error: *s_Dwarf_Error_s
        if dwarf_finish(obj.dbg, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }
    }

    free(obj.symtab)
    for var name in @obj.sections.keys() {
        let section = obj.sections[name]
        free(section.data)
        free(section.relocations.reloc)
    }
}

def write_debug_info(res: &Object) {
    // Test debug info
    var die: *s_Dwarf_P_Die_s
    var error: *s_Dwarf_Error_s

    if dwarf_new_die_a(res.pdbg, DW_TAG_compile_unit, null, null, null, null, *die, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    var producer: *s_Dwarf_P_Attribute_s
    if dwarf_add_AT_producer_a(die, "Princess!".value, *producer, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }
    var name: *s_Dwarf_P_Attribute_s
    if dwarf_add_AT_name_a(die, "test.c".value, *name, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }
    var low_pc: *s_Dwarf_P_Attribute_s
    if dwarf_add_AT_targ_address_c(res.pdbg, die, DW_AT_low_pc, 0, 0, *low_pc, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }
    var high_pc: *s_Dwarf_P_Attribute_s
    if dwarf_add_AT_targ_address_c(res.pdbg, die, DW_AT_high_pc, 0x6A, 0, *high_pc, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    if dwarf_add_die_to_debug_a(res.pdbg, die, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    var nbufs: int64
    if dwarf_transform_to_disk_form_a(res.pdbg, *nbufs, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    for var i in 0..nbufs {
        let section = res.debug_sections[i]
        var section_index: int64

        var error: *s_Dwarf_Error_s
        if dwarf_get_section_bytes_a(res.pdbg, i, *section_index, *section.size, *section.data, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }

        bfd_set_section_size(section.section, section.size)
        bfd_set_section_flags(section.section, section.section.flags | 0x8 /*SEC_READONLY*/ | 0x100 /*SEC_CONTENTS*/ )
    }

    var nrelocs: uint64
    var drd_version: int
    if dwarf_get_relocation_info_count(res.pdbg, *nrelocs, *drd_version, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    for var i in 0..nrelocs {
        var elf_section_index: int64
        var elf_section_index_link: int64
        var relocation_buffer_count: uint64
        var reld: *s_Dwarf_Relocation_Data_s

        if dwarf_get_relocation_info(res.pdbg,
            *elf_section_index,
            *elf_section_index_link,
            *relocation_buffer_count,
            *reld, *error) == DW_DLV_ERROR {

            dwarf_error(error)
        }

        var relocations = allocate(relocation_buffer_count * size_of *s_reloc_cache_entry) !**s_reloc_cache_entry

        for var j in 0..relocation_buffer_count {
            let relent = zero_allocate(s_reloc_cache_entry)
            
            relent.sym_ptr_ptr = *res.symbols[reld.drd_symbol_index].symbol
            relent.addend = 0
            relent.address = reld.drd_offset
            relent.howto = bfd_reloc_type_lookup(res.bfd, e_bfd_reloc_code_real::BFD_RELOC_32 if reld.drd_length == 4 else e_bfd_reloc_code_real::BFD_RELOC_64)
            relocations[j] = relent
        }
        
        let section = res.debug_sections[elf_section_index_link].section
        bfd_set_section_flags(section, section.flags | 0x4 /* SEC_RELOC `*/)
        res.bfd.xvec._bfd_set_reloc(res.bfd, section, relocations, relocation_buffer_count !uint)
    }

    for var i in 0..nbufs {
        let section = res.debug_sections[i]

        print("Writing section ", section.name, " with size ", section.size, "\n")
        bfd_set_section_contents(res.bfd, section.section, section.data, 0, section.size)
    }

    if dwarf_producer_finish_a(res.pdbg, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }
    print("Finished writing!\n")
}

type Symbol = struct {
    origin: &Object
    name: Str
    symbol: *s_bfd_symbol
    section: &Section
    size: size_t
    offset: int64 // Offset based on deleted sections
    location: size_t // Original location based on the offset within a file
}

def bfd_asymbol_value(sy: *s_bfd_symbol) -> size_t {
    return sy.section.vma + sy.value
}

def initialize_section(res: &Object, name: Str) {
    let sec = bfd_get_section_by_name(res.bfd, name.to_array().value)
    if not sec { return }
    res.sections[name] = { section = sec, name = name.to_array(), offsets = map::make(type &Section, size_t), size = sec.size} !&Section
}

def load_section_data(obj: &Object, name: Str) {
    if not obj.sections.contains(name) { return }
    let section = obj.sections[name]
    var data = allocate(section.section.size)
    bfd_get_section_contents(obj.bfd, section.section, data, 0, section.section.size)
    section.data = data
}

def merge_section(res: &Object, obj_a: &Object, name: Str) {
    if not obj_a.sections.contains(name) { return }
    let a_sec = obj_a.sections[name]

    if res.sections.contains(name) {
        return
    }

    let section_name = name.to_array()
    let new_sec = bfd_make_section(res.bfd, section_name.value)
    bfd_set_section_flags(new_sec, a_sec.section.flags)
    bfd_set_section_size(new_sec, a_sec.section.size)
    new_sec.alignment_power = a_sec.section.alignment_power

    let section = { section = new_sec, name = section_name, offsets = map::make(type &Section, size_t), size = 0 } !&Section
    section.relocations.origin = vector::make(type &Object)
    res.sections[name] = section
}

def merge_section_data(res: &Object, obj_a: &Object, name: Str) {
    if not obj_a.sections.contains(name) { return }

    merge_section(res, obj_a, name)

    let a_sec = obj_a.sections[name]
    let new_sec = res.sections[name]

    let sz = a_sec.section.size
    
    var offset: size_t = new_sec.size
    var data = reallocate(new_sec.data !*char, offset + sz)

    // Initialize relocations
    let rel_sz = bfd_get_reloc_upper_bound(obj_a.bfd, a_sec.section)
    if rel_sz > 0 {
        let relent = allocate(rel_sz) !**s_reloc_cache_entry
        let count = bfd_canonicalize_reloc(obj_a.bfd, a_sec.section, relent, obj_a.symtab)

        if count > 0 {
            let new_sz = (count + new_sec.relocations.count) * size_of *s_reloc_cache_entry
            let out = reallocate(new_sec.relocations.reloc, new_sz)
            memcopy(relent, out ++ new_sec.relocations.count, count * size_of *s_reloc_cache_entry)

            new_sec.relocations.reloc = out
            new_sec.relocations.count += count

            for var i in 0..count {
                let rel = relent[i]
                let sym_name = make_string((@rel.sym_ptr_ptr).name)
                let sym = find_symbol(obj_a, sym_name)
                rel.address += offset
            }
              
            for var i in 0..count {
                new_sec.relocations.origin.push(obj_a)
            }
        }

        free(relent)
    }

    memcopy(a_sec.data, data ++ offset, a_sec.section.size)
    new_sec.offsets[a_sec] = offset

    new_sec.data = data
    new_sec.size += sz

    bfd_set_section_size(new_sec.section, new_sec.size)
}

def write_section_data(res: &Object, name: Str) {
    if not res.sections.contains(name) { return }
    let sec = res.sections[name]
    bfd_set_section_contents(res.bfd, sec.section, sec.data, 0, sec.size)

    // Write relocations
    let count = sec.relocations.count
    let relent = sec.relocations.reloc
    if count > 0 {
        for var i in 0..count {
            let rel = relent[i]
            let sym_name = make_string((@rel.sym_ptr_ptr).name)
            let sym = find_symbol(res, sec.relocations.origin[i], sec, rel)
            rel.sym_ptr_ptr = *find_symbol(res, sym_name).symbol

            if sym {
                rel.address += sym.offset
            }
        }
        res.bfd.xvec._bfd_set_reloc(res.bfd, sec.section, relent, count !uint)
    }
}

def load_symbols(res: &Object) {
    let a_sz = res.bfd.xvec._bfd_get_symtab_upper_bound(res.bfd)
    let syms = allocate(a_sz) !**s_bfd_symbol
    let cnta = res.bfd.xvec._bfd_canonicalize_symtab(res.bfd, syms)
    
    res.symtab = syms

    // TODO This relies on symbols being ordered
    var i = 0
    while i < cnta {
        var sym = syms[i]
        let sec_name = make_string(sym.section.name)
        let sym_name = make_string(sym.name)

        var section: &Section
        if not is_abs_section(sym.section) and res.sections.contains(sec_name) {
            section = res.sections[sec_name]
        }

        var offset: size_t = bfd_asymbol_value(sym) 
        var size: size_t = 0

        if section and sec_name != sym_name {
            if i + 1 < cnta {
                let next_sym = syms[i + 1]
                if make_string(next_sym.section.name) != sec_name {
                    size = section.size - offset
                } else {
                    size = bfd_asymbol_value(next_sym) - offset
                }
            } else {
                size = section.size - offset
            }
        }
        
        let out_sym = { res, sym_name, sym, section, size } !&Symbol
        res.symbols.push(out_sym)
        res.sym_size += 1
        i += 1
    }
}

// returns the difference in size when a symbol is deleted
def remove_symbol(res: &Object, name: Str) -> int {
    if find_symbol(res, name) == null { return 0 }
    let sym = find_symbol(res, name)
    let sec = sym.section

    delete_symbol(res, name)
    
    var size_diff = 0
    if sec { 
        // Purge the symbol from the section
        let data = allocate(sec.size - sym.size)
        memcopy(sec.data, data, sym.symbol.value)
        memcopy(sec.data ++ sym.symbol.value ++ sym.size, data ++ sym.symbol.value, sec.size - sym.symbol.value - sym.size)
        free(sec.data)
        sec.data = data

        // Actually shrink the section
        sec.size -= sym.size
        size_diff -= sym.size
    }

    var i = 0
    while i < res.sym_size {
        if make_string(res.symtab[i].name) == name {
            break
        }
        i += 1
    }

    let symtab = allocate(size_of **s_bfd_symbol * (res.sym_size - 1)) !**s_bfd_symbol
    memcopy(res.symtab, symtab, i * size_of **s_bfd_symbol)
    if res.sym_size - i > 0 {
        memcopy(res.symtab ++ i ++ 1, symtab ++ i, (res.sym_size - i - 1) * size_of **s_bfd_symbol) 
    }

    free(res.symtab)

    res.symtab = symtab
    res.sym_size -= 1

    if sec {
        for var sym2 in res.symbols {
            // Offset symbols
            if sym.section and sym2.symbol.value > sym.symbol.value and sym.section == sym2.section {
                sym2.symbol.value -= sym.size
                sym2.offset -= sym.size
            }
        }
    }

    return size_diff
}

// TODO There are in fact ways to do this without a string compare but it doesn't seem to work
def #inline is_und_section(section: *s_bfd_section) -> bool {
    return cstd::strcmp(section.name, "*UND*".value) == 0
}

def #inline is_abs_section(section: *s_bfd_section) -> bool {
    return cstd::strcmp(section.name, "*ABS*".value) == 0
}

type DuplicateEntry = struct {
    symbol: &Symbol
    from_section: &Section
}

def copy_symbols(to: &Object, frm: &Object) {
    to.symtab = reallocate(to.symtab, size_of *s_bfd_symbol * (frm.sym_size + to.sym_size)) !**s_bfd_symbol

    let duplicates = map::make(DuplicateEntry)
    
    var i = to.sym_size
    for var sym in frm.symbols {
        let name = sym.name
        let new_sym = to.bfd.xvec._bfd_make_empty_symbol(to.bfd)
        let section = frm.sections[sym.section.name] if sym.section else null
        let to_section = to.sections[sym.section.name] if sym.section else null

        var offset: int64 = 0
        if to_section and to_section.offsets.contains(section) {
            offset = to_section.offsets[section]
        }

        new_sym.name = sym.symbol.name
        if to_section {
            new_sym.section = to_section.section
        } else {
            new_sym.section = sym.symbol.section
        }
        new_sym.flags = sym.symbol.flags
        new_sym.value = sym.symbol.value + offset

        to.symtab[i] = new_sym
        let symbol = { frm, name, new_sym, to_section, sym.size, offset, sym.symbol.value } !&Symbol

        if not is_und_section(sym.symbol.section) {
            if find_symbol(to, name) != null {
                if name.starts_with(".") { continue }
                
                duplicates[name] = { symbol, section } !DuplicateEntry
                new_sym.value = sym.symbol.value
            } else {
                to.symbols.push(symbol)
                to.sym_size += 1
                i += 1
            }
        }
    }

    var size_diff = 0
    for var name in @duplicates.keys() {
        size_diff += remove_symbol(to, name)
    }

    to.symtab = reallocate(to.symtab, size_of *s_bfd_symbol * (to.sym_size + duplicates.size)) !**s_bfd_symbol

    for var name in @duplicates.keys() {
        let entry = duplicates[name]
        let sym = entry.symbol
        
        if entry.symbol.section {
            sym.symbol.value += entry.symbol.section.offsets[entry.from_section]
        }

        sym.symbol.value = sym.symbol.value !int + size_diff
        sym.offset += size_diff

        to.symbols.push(sym)
        to.symtab[to.sym_size] = sym.symbol
        to.sym_size += 1
    }

    // DWARF
    read_dwarf_symbols(frm)
}

def dwarf_die_handler(dbg: *s_Dwarf_Debug_s, die: *s_Dwarf_Die_s) {
    
    var error: *s_Dwarf_Error_s
    var atlist: **s_Dwarf_Attribute_s
    var atcount: int64
    var res: int

    res = dwarf_attrlist(die, *atlist, *atcount, *error)
    if res != DW_DLV_OK {
        dwarf_error(error)
    }

    for var i in 0..atcount {
        var attrnum: ushort
        var attrname: *char 

        res = dwarf_whatattr(atlist[i], *attrnum, *error)
        if res != DW_DLV_OK {
            dwarf_error(error)
        }
        dwarf_get_AT_name(attrnum, *attrname)

        var value: *char
        dwarf_die_text(die, attrnum, *value, *error)
        if res != DW_DLV_OK {
            dwarf_error(error)
        }

        dwarf_dealloc(dbg, atlist[i], DW_DLA_ATTR)
    }

    dwarf_dealloc(dbg, atlist, DW_DLA_LIST)
}

def dwarf_error(err: *s_Dwarf_Error_s) {
    error(dwarf_errmsg(err), "\n")
    abort()
}

def read_dwarf_die(dbg: *s_Dwarf_Debug_s, in_die: *s_Dwarf_Die_s, is_info: int, in_level: int) {

    var error: *s_Dwarf_Error_s
    var res = DW_DLV_OK
    var cur_die = in_die
    var child: *s_Dwarf_Die_s

    dwarf_die_handler(dbg, in_die)

    loop {
        var sib_die: *s_Dwarf_Die_s
        res = dwarf_child(cur_die, *child, *error)
        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_OK {
            read_dwarf_die(dbg, child, is_info, in_level + 1)
            dwarf_dealloc(dbg, child, DW_DLA_DIE)
            child = null
        }
        res = dwarf_siblingof_b(dbg, cur_die, is_info, *sib_die, *error)
        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_NO_ENTRY { break }

        if cur_die != in_die {
            dwarf_dealloc(dbg, cur_die, DW_DLA_DIE)
            cur_die = null
        }
        cur_die = sib_die
        dwarf_die_handler(dbg, sib_die)
    }
}

def read_dwarf_symbols(o: &Object) {

    var error: *s_Dwarf_Error_s

    var abbrev_offset: uint64
    var address_size: ushort
    var version_stamp: ushort
    var offset_size: ushort
    var extension_size: ushort
    var signature: s_Dwarf_Sig8_s
    var typeoffset: uint64
    var next_cu_hader: uint64
    var header_cu_type: ushort

    var is_info: int = 1
    var res = 0

    loop {
        var no_die: *s_Dwarf_Die_s
        var cu_die: *s_Dwarf_Die_s
        var cu_header_length: uint64

        res = dwarf_next_cu_header_d(o.dbg, is_info, *cu_header_length,
            *version_stamp, *abbrev_offset,
            *address_size, *offset_size,
            *extension_size, *signature,
            *typeoffset, *next_cu_hader,
            *header_cu_type, *error)
        
        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_NO_ENTRY {
            if is_info { 
                is_info = 0
                continue
            }
            else { return }
        }
        res = dwarf_siblingof_b(o.dbg, no_die, is_info, *cu_die, *error)

        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_NO_ENTRY { dwarf_error(error) }
        read_dwarf_die(o.dbg, cu_die, is_info, 0)
    }
}

def write_symbols(res: &Object) {
    bfd_set_symtab(res.bfd, res.symtab, res.sym_size !uint)
}

def main {
    let obj_a = open_object_read(file_a)
    let obj_b = open_object_read(file_b)
    let new_obj = open_object_write(file_r)
    new_obj.copy_arch_mach(obj_a)

    obj_a.initialize_section(".text")
    obj_a.initialize_section(".data")
    obj_a.initialize_section(".llvm_addrsig")

    obj_b.initialize_section(".text")
    obj_b.initialize_section(".data")
    obj_b.initialize_section(".llvm_addrsig")

    obj_a.load_symbols()
    obj_b.load_symbols()

    obj_a.load_section_data(".text")
    obj_a.load_section_data(".data")
    obj_a.load_section_data(".llvm_addrsig")

    obj_b.load_section_data(".text")
    obj_b.load_section_data(".data")
    obj_b.load_section_data(".llvm_addrsig")

    new_obj.merge_section_data(obj_a, ".text")
    new_obj.merge_section_data(obj_a, ".data")
    new_obj.merge_section_data(obj_a, ".llvm_addrsig")

    new_obj.merge_section_data(obj_b, ".text")
    new_obj.merge_section_data(obj_b, ".data")
    new_obj.merge_section_data(obj_b, ".llvm_addrsig")

    new_obj.copy_symbols(obj_a)
    new_obj.copy_symbols(obj_b)

    new_obj.write_symbols()
    new_obj.write_debug_info()

    new_obj.write_section_data(".text")
    new_obj.write_section_data(".data")
    new_obj.write_section_data(".llvm_addrsig")

    delete(new_obj)
    delete(obj_a)
    delete(obj_b)
}

main
