import parser
import vector
import set
import map
import scope
import util
import debug
import toolchain
import builtins
import typechecking
import consteval
import errors
import eval
import md5
import optional
import arena
import constants

export type Label = struct {
    name: Str
}

export type DebugValueKind = enum {
    NULL; BOOL; INT; STRING; METADATA; CONST; DIEXP
}

export type DebugValue = struct {
    kind: DebugValueKind
    name: Str
    s: Str
    i: int64
}

export type DebugParam = struct {
    name: Str
    value: DebugValue
}

export type ValueKind = enum {
    NULL; ZEROINITIALIZER; UNDEF; LOCAL; GLOBAL
    BOOL; INT; FLOAT; STRING; POINTER
    ARRAY; STRUCT; UNION; TYPE; ADDRESS
    METADATA; DEBUG_INFO; FUNCTION
}

export type Value = struct {
    kind: ValueKind
    metadata: bool
    distinct: bool
    name: Str
    i: int64
    f: double
    s: &[char]
    // This is the value of a type
    value_tpe: &typechecking::Type
    // Used for both struct and array
    values: &[Value]
    // This is used for DEBUG_INFO
    debug_values: &[DebugParam]
    // Address of a value
    addr: &Value
    tpe: &typechecking::Type
    function: *eval::FunctionPtr
}

export def copy(value: Value) -> Value {
    let ret = value
    if value.kind == ValueKind::ARRAY or value.kind == ValueKind::STRUCT {
        let values = allocate_ref(Value, value.values.size)
        for var i in 0..value.values.size {
            values(i) = copy(value.values(i))
        }
        ret.values = values
    }
    return ret
}

export let NO_VALUE = [ kind = ValueKind::NULL, tpe = null ] !Value

export type InsnKind = enum {
    ADD; SUB; MUL; SREM; UREM; SDIV; UDIV
    FADD; FSUB; FMUL; FREM; FDIV; ASHR; LSHR
    SHL; AND; OR; XOR; FCMP; ICMP; FNEG
    RET; LOAD; STORE; ALLOCA
    INSERTVALUE; EXTRACTVALUE; GETELEMENTPTR
    TRUNC; ZEXT; SEXT; FPTRUNC; FPEXT
    FPTOUI; FPTOSI; UITOFP; SITOFP
    PTRTOINT; INTTOPTR; BITCAST; SWITCH
    CALL; BR_UNC; BR; UNREACHABLE
}

export type CompareFloat = enum {
    ueq; ugt; uge; ult; ule; une
}

export type CompareInt = enum {
    eq; ne; ugt; uge; ult; ule;
    sgt; sge; slt; sle
}

export type InsnFcmp = struct {
    op: CompareFloat
    ret: Value
    left: Value
    right: Value
}

export type InsnIcmp = struct {
    op: CompareInt
    ret: Value
    left: Value
    right: Value
}

export def icmp(state: &State, op: CompareInt, left: Value, right: Value, loc: &Value = null) -> Value {
    let ret = make_local_value(builtins::bool_, null, state)
    let icmp = make_insn_dbg(InsnKind::ICMP, loc)
    icmp.value.icmp = [
        op = op,
        ret = ret,
        left = left,
        right = right
    ] !InsnIcmp
    push_insn(icmp, state)
    
    return ret
}

export type SwitchValue = struct {
    value: Value
    label_: Label
}

export type InsnSwitch = struct {
    value: Value
    otherwise: Label
    switch_values: &Vector(SwitchValue)
}

export type InsnFneg = struct {
    ret: Value
    value: Value
}

export type InsnInsertValue = struct {
    ret: Value
    value: Value
    element: Value
    index: &[int]
}

export def insert_value(state: &State, ret: &typechecking::Type, value: Value, element: Value, index: &[int], loc: &Value = null) -> Value {
    let iv_ret = make_local_value(ret, null, state)
    let iv = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    iv.value.insert_value = [
        ret = iv_ret,
        value = value,
        element = element,
        index = index
    ] !InsnInsertValue
    push_insn(iv, state)
    
    return iv_ret
}

export type InsnGetElementPtr = struct {
    ret: Value
    // Here the type isn't the same as ret
    tpe: &typechecking::Type
    value: Value
    index: &[Value]
}

export def gep(state: &State, ret: &typechecking::Type, tpe: &typechecking::Type, value: Value, index: &[Value], loc: &Value = null) -> Value {
    let gep_ret = make_local_value(ret, null, state)
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep.value.gep = [
        ret = gep_ret,
        tpe = tpe,
        value = value,
        index = index
    ] !InsnGetElementPtr
    push_insn(gep, state)

    return gep_ret
}

export type InsnConvert = struct {
    ret: Value
    value: Value
}

export def bitcast(state: &State, ret: &typechecking::Type, value: Value, loc: &Value = null) -> Value {
    let bitcast_ret = make_local_value(ret, null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = [
        ret = bitcast_ret,
        value = value
    ] !InsnConvert
    push_insn(bitcast, state)

    return bitcast_ret
}

export def ptr_to_int(state: &State, value: Value, loc: &Value = null) -> Value {
    let ret = make_local_value(builtins::int64_, null, state)
    let ptrtoint = make_insn_dbg(InsnKind::PTRTOINT, loc)
    ptrtoint.value.convert = [
        ret = ret,
        value = value
    ] !InsnConvert
    push_insn(ptrtoint, state)

    return ret
}

export type InsnExtractValue = struct {
    ret: Value
    value: Value
    index: &[int]
}

export def extract_value(state: &State, ret: &typechecking::Type, value: Value, index: &[int], loc: &Value = null) -> Value {
    let ev_ret = make_local_value(ret, null, state)
    let ev = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    ev.value.extract_value = [
        ret = ev_ret,
        value = value,
        index = index
    ] !InsnExtractValue
    push_insn(ev, state)

    return ev_ret
}

export type InsnStore = struct {
    value: Value
    loc: Value
}

export def store(state: &State, vloc: Value, value: Value, loc: &Value = null) {
    let store = make_insn_dbg(InsnKind::STORE, loc)
    store.value.store = [
        loc = vloc,
        value = value
    ] !InsnStore
    push_insn(store, state)
}

export type InsnLoad = struct {
    value: Value
    loc: Value
}

export def load(state: &State, tpe: &typechecking::Type, locv: Value, loc: &Value = null) -> Value {
    let load_ret = make_local_value(tpe, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    load.value.load = [
        loc = locv,
        value = load_ret
    ] !InsnLoad
    push_insn(load, state)

    return load_ret
}

export def ret(state: &State, value: Value, loc: &Value = null) {
    let ret = make_insn_dbg(InsnKind::RET, loc)
    ret.value.ret.value = value
    push_insn(ret, state)
}

export type InsnReturn = struct {
    value: Value
}

export type InsnArithmetic = struct {
    ret: Value
    left: Value
    right: Value
}

def arithmetic(state: &State, kind: InsnKind, ret: &typechecking::Type, left: Value, right: Value, loc: &Value) -> Value {
    let retv = make_local_value(ret, null, state)
    let arith = make_insn_dbg(kind, loc)
    arith.value.arith = [
        ret = retv,
        left = left,
        right = right
    ] !InsnArithmetic
    push_insn(arith, state)
    
    return retv
}

export def sub(state: &State, ret: &typechecking::Type, left: Value, right: Value, loc: &Value = null) -> Value {
    return arithmetic(state, InsnKind::SUB, ret, left, right, loc)
}

export def add(state: &State, ret: &typechecking::Type, left: Value, right: Value, loc: &Value = null) -> Value {
    return arithmetic(state, InsnKind::ADD, ret, left, right, loc)
}

export def mul(state: &State, ret: &typechecking::Type, left: Value, right: Value, loc: &Value = null) -> Value {
    return arithmetic(state, InsnKind::MUL, ret, left, right, loc)
}

export type InsnAlloca = struct {
    ret: Value
}

export def alloca(state: &State, tpe: &typechecking::Type, loc: &Value = null, no_yield_capture: bool = false) -> Value {
    let alloca_ret = make_named_local(tpe, null, state)
    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
    alloca.value.alloca = [
        ret = alloca_ret
    ] !InsnAlloca
    push_alloca(alloca, state, no_yield_capture)
    alloca_ret.tpe = typechecking::pointer(tpe)
    return alloca_ret
}

export type InsnCall = struct {
    name: Value
    ret: Value
    args: &[Value]
    proto: &[typechecking::NamedParameter]
}

export def call(state: &State, name: Str, tpe: &typechecking::Type, args: &[Value], loc: &Value = null) -> Value {
    let name_v = [ kind = ValueKind::GLOBAL, name = name ] !Value
    return call(state, name_v, tpe, args, parser::InlineSpecifier::NONE, null, loc)
}

export def call(state: &State, name_v: Value, tpe: &typechecking::Type, args: &[Value], inline: parser::InlineSpecifier, proto: &[typechecking::NamedParameter] = null, loc: &Value = null) -> Value {
    var node: &Node
    var func: &Function
    var do_inline = inline == parser::InlineSpecifier::INLINE
    if name_v.kind == ValueKind::GLOBAL {
        let name = name_v.name
        func = state.module.result.functions.get_or_default(name, null)
        if func {
            // TODO Getting the Node like this seems like a terrible idea, maybe give Function a Node instead
            let value = scope::find(scope::make_ident(name, func.module))
            if value {
                node = value.node
            }
            if node {
                do_inline = do_inline or node.value.def_.inline
            }
        }
    }
    if do_inline and inline != parser::InlineSpecifier::NO_INLINE and node and func {
        return inline_call(node, func, tpe, args, state)
    } else {
        let ret = make_local_value(tpe, null, state) if tpe else NO_VALUE
        let call = make_insn_dbg(InsnKind::CALL, loc)
        call.value.call = [
            name = name_v,
            ret = ret,
            args = args,
            proto = proto
        ] !InsnCall
        push_insn(call, state)
        return ret
    }
}

export type InsnBrUnc = struct {
    label_: Label
}

export type InsnBr = struct {
    cond: Value
    if_true: Label
    if_false: Label
}

export type InsnValue = struct #union {
    arith: InsnArithmetic
    ret: InsnReturn
    store: InsnStore
    load: InsnLoad
    alloca: InsnAlloca
    call: InsnCall
    br_unc: InsnBrUnc
    br: InsnBr
    insert_value: InsnInsertValue
    extract_value: InsnExtractValue
    gep: InsnGetElementPtr
    convert: InsnConvert
    icmp: InsnIcmp
    fcmp: InsnFcmp
    fneg: InsnFneg
    switch_: InsnSwitch
}

export type Insn = struct {
    kind: InsnKind
    value: InsnValue
    debug: &Value
}

export def destruct(insn: *Insn) {
    switch insn.kind {
        case InsnKind::ADD..=InsnKind::XOR
            __destruct__(*insn.value.arith)
        case InsnKind::FCMP
            __destruct__(*insn.value.fcmp)
        case InsnKind::ICMP
            __destruct__(*insn.value.icmp)
        case InsnKind::FNEG
            __destruct__(*insn.value.fneg)
        case InsnKind::RET
            __destruct__(*insn.value.ret)
        case InsnKind::LOAD
            __destruct__(*insn.value.load)
        case InsnKind::STORE
            __destruct__(*insn.value.store)
        case InsnKind::ALLOCA
            __destruct__(*insn.value.alloca)
        case InsnKind::INSERTVALUE
            __destruct__(*insn.value.insert_value)
        case InsnKind::EXTRACTVALUE
            __destruct__(*insn.value.extract_value)
        case InsnKind::GETELEMENTPTR
            __destruct__(*insn.value.gep)
        case InsnKind::TRUNC..=InsnKind::BITCAST
            __destruct__(*insn.value.convert)
        case InsnKind::SWITCH
            __destruct__(*insn.value.switch_)
        case InsnKind::CALL
            __destruct__(*insn.value.call)
        case InsnKind::BR_UNC
            __destruct__(*insn.value.br_unc)
        case InsnKind::BR
            __destruct__(*insn.value.br)
        case InsnKind::UNREACHABLE
        case
            error(insn.kind, "\n")
            assert
    }
}

// Block for CFG
export type Block = struct {
    label_: Str
    counter: int
    // Vector of Insn
    insn: &Vector(&Insn)
    next: &Block
}

type Snapshot = &Vector(&SMap(int))

def take_snapshot(function: &Function) {

    let compiled = map::make(int) 
    let current = function.current_snapshot
    for var scpe in current {
        compiled.put_all(scpe)
    }

    function.snapshots.push(compiled)
}

export type Function = struct {
    is_global: bool
    module: weak_ref(toolchain::Module)
    imported: bool
    dllimport: bool
    dllexport: bool
    test: bool
    polymorph: bool

    // True if we have C style varargs
    varargs: bool
    name: Str
    unmangled: Str
    tpe: &typechecking::Type
    // Vector of typechecking::NamedParameter
    args: &Vector(typechecking::NamedParameter)
    ret: &typechecking::Type
    multiple_returns: bool
    forward_declare: bool
    // First node
    block: &Block
    debug: &Value
    allocas: &Vector(&Insn)

    // Map of typechecking::Type
    locals: &SMap(&typechecking::Type)
    has_defer: bool
    defers: &typechecking::Type
    // Vector of Function
    defer_functions: &Vector(&Function)
    env: &typechecking::Type
    // These 
    used_type_meta: &Set(&typechecking::Type)
    
    // This is a map of local variables that are defined at that point
    function_locals: &SSet

    // Generators
    context: &typechecking::Type
    optional: &typechecking::Type
    all_locals: &SMap(&typechecking::Type)
    // This is the current scope that needs to be freed by the jump index
    current_snapshot: Snapshot
    snapshots: &Vector(&SMap(int))

    has_yield: bool
    yield_index: int
    yield_switch: &Insn
    value: &scope::Value
    generator_ctor: &parser::Node // Needs a strong reference if generated

    // Closures
    is_closure: bool
    state: &typechecking::Type
    scope: weak_ref(scope::Scope)
    inner_scope: weak_ref(scope::Scope)
    captures: &Vector(weak_ref(scope::Value))

    is_compiled: bool
    is_typechecked: bool
}

def add_local(state: &State, function: &Function, value: &scope::Value, tpe: &typechecking::Type) {
    if function.locals {
        function.locals(value.assembly_name(state)) = tpe
    }
}

// TODO Maybe move this into module
export type Result = struct {
    // Map of Function
    functions: &SMap(&Function)
    // Map of typechecking::Type
    structures: &SMap(&typechecking::Type)
    // Map of Global
    globals: &SMap(&Global)
    // Map of Value
    metadata: &SMap(&Value)

    finalizer: &typechecking::Type
}

export type Global = struct {
    dllimport: bool 
    dllexport: bool
    external: bool
    private: bool
    name: Str
    tpe: &typechecking::Type
    value: &Value
    line: int
    debug: &Value
    identifier: &parser::Node   // TODO Use this in other places
    is_var_decl: bool // This is true to differentiate between actual defined globals and generated ones
}

type LoopState = struct {
    break_insn: &Insn
    continue_insn: &Insn
    scope: &scope::Scope
}

export type State = struct {
    module: weak_ref(toolchain::Module)
    global_counter: int
    meta_counter: int
    local_counter: int
    function_stack: &Vector(&Function)
    current_block: &Block
    // Vector of LoopState 
    loops: &Vector(LoopState)
    // Map of Value
    ditypes: &Map(&typechecking::Type, &Value)
    difile: &Value
    diunit: &Value
    // Vector of Value
    discope: &Vector(&Value)
    // Used by eval
    globals: &SMap(*)
    mem: &arena::Arena
    scope: weak_ref(scope::Scope)
    // Destructor function
    finalizer: &Function
    consteval: bool
    current_variable: &scope::Value
    // This is set by the language server to not store instructions
    no_instructions: bool
    // Set in consteval::compiler_state
    file_name_value: Value
    // inline_offset gets incremented when a new function gets inlined
    inline_offset: size_t
    // prefix gets added in front of every variable
    prefix: Str
    return_address: Value // This is used as the return address in inline functions
    return_br: &Insn // This is used to jump back to the end of the function
    inline_start_block: &Block // This represents the first block of the current function
}

export def destruct(state: *State) {
    state.mem.free()
}

def current_value(state: &State) -> &scope::Value {
    if state.current_variable {
        return state.current_variable
    }
    
    let len = vector::length(state.function_stack)
    for var i in 0..len {
        let j = state.function_stack.length - i - 1
        let fun = state.function_stack(j)
        if fun.is_global and j + 1 < len { 
            return state.function_stack(j + 1).value
        }
    }
    return null
}

export def current_function(state: &State) -> &Function {
    if state.function_stack.length > 0 {
        return state.function_stack.peek()
    }
    return null
}

def is_inline(state: &State) -> bool {
    return state.inline_offset > 0
}

def add_type_meta(tpe: &typechecking::Type, state: &State) {
    if not tpe { return }
    if tpe.kind == typechecking::TypeKind::NULL { return }
    var cf = current_function(state)

    let len = vector::length(state.function_stack)
    for var i in 0..len {
        let j = state.function_stack.length - i - 1
        let fun = state.function_stack(j)
        if fun.is_global {
            cf = fun
            break
        }
    }

    if cf and cf.used_type_meta {
        cf.used_type_meta.add(tpe)
    }
}

export def make_block -> &Block {
    return [
        label_ = "start",
    	insn = vector::make(type &Insn)
    ] !&Block
}

export def make_insn_dbg(kind: InsnKind, debug: &Value) -> &Insn {
    let insn = [] !&Insn
    insn.kind = kind
    if toolchain::debug_sym {
        insn.debug = debug
    } else {
        insn.debug = null
    }
    return insn
}

export def make_insn(kind: InsnKind) -> &Insn {
    return make_insn_dbg(kind, null)
}

def get_break_insn(state: &State) -> &Insn {
    if vector::length(state.loops) > 0 {
        return state.loops.peek().break_insn
    }
    return null
}

def get_continue_insn(state: &State) -> &Insn {
    if vector::length(state.loops) > 0 {
        return state.loops.peek().continue_insn
    }
    return null
}

def get_loop_state(state: &State) -> Optional(LoopState) {
    if vector::length(state.loops) > 0 {
        return optional::some(state.loops.peek())
    }
    return optional::none(LoopState)
}

def push_loop_state(state: &State, scpe: &scope::Scope) {
    let break_insn = make_insn(InsnKind::BR_UNC)
    let continue_insn = make_insn(InsnKind::BR_UNC)

    let loops = [
        break_insn = break_insn,
        continue_insn = continue_insn,
        scope = scpe
    ] !LoopState
    
    state.loops.push(loops)
}

def pop_loop_state(state: &State) {
    vector::pop((@state).loops)
}

def make_meta(state: &State) -> &Value {
    let s = to_string(state.meta_counter)
    state.meta_counter += 1
    let value = [
        kind = ValueKind::METADATA,
        name = s
    ] !&Value
    return value
}

def push_meta(meta: &Value, state: &State) -> &Value {
    let val = make_meta(state)
    state.module.result.metadata((@val).name) = meta
    return val
}

def meta_to_debug_value(meta: &Value) -> DebugValue {
    if not meta { return [] !DebugValue }
    
    assert meta.kind == ValueKind::METADATA
    return [
        kind = DebugValueKind::METADATA,
        name = (@meta).name
    ] !DebugValue
}

export def make_location(node: &parser::Node, state: &State) -> &Value {
    let discope = vector::peek(state.discope) if state.discope.length > 0 else null !&Value

    if not toolchain::debug_sym { return null }
    let debug_values = allocate_ref(DebugParam, 3)
    debug_values(0) = [
        name = "line", value = [ kind = DebugValueKind::INT, i = node.loc.line + 1 ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "column", value = [ kind = DebugValueKind::INT, i = node.loc.column + 1 ] !DebugValue
    ] !DebugParam
    debug_values(2) = [
        name = "scope", value = meta_to_debug_value(discope)
    ] !DebugParam
    
    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DILocation",
        debug_values = debug_values
    ] !&Value
    return push_meta(di, state)
}

export def make_label(state: &State) -> Label {
    let s = to_string(state.current_block.counter)
    state.current_block.counter += 1
    return [ name = s ] !Label
}

export def push_label(label_: Label, state: &State) {
    // TODO Might want to use the actual label here
    let block = [
        label_ = label_.name,
        insn = vector::make(type &Insn),
        counter = state.current_block.counter
    ] !&Block
    
    state.current_block.next = block
    state.current_block = block
}

export def push_insn(insn: &Insn, state: &State) {
    if state.no_instructions { return }
    let insns = state.current_block.insn
    insns.push(insn)
}

def push_local_var(name: Str, tpe: &typechecking::Type, function: &Function) {
    if function.has_yield {
        let index = function.all_locals.size !int + 1
        function.all_locals(name) = tpe
        function.current_snapshot.peek()(name) = index
    }
}

// TODO We must use make_insn directly because the values go into the alloca vector
// There might be a better way of handling this
def push_alloca(insn: &Insn, state: &State, no_yield_capture: bool = false) {
    if state.no_instructions { return }

    assert insn.kind == InsnKind::ALLOCA

    let current_function = state.current_function
    let allocas = current_function.allocas

    if current_function.has_yield and not no_yield_capture {
        let ret = insn.value.alloca.ret
        let index = current_function.all_locals.size !int + 1
        push_local_var(ret.name, ret.tpe, current_function)

        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = [
            ret = ret,
            tpe = current_function.context,
            value = [ kind = ValueKind::LOCAL, tpe = pointer(current_function.context), name = "__context"] !Value,
            index = [make_int_value(0), make_int_value(index)]
        ] !InsnGetElementPtr
        allocas.push(gep)
    } else {
        allocas.push(insn)
    }
}

def push_declare_arg(node: &parser::Node, val: Value, name: Str, arg: int, state: &State) {
    if not toolchain::debug_sym { return }
    var line = node.loc.line
    let discope = vector::peek(state.discope) if state.discope.length > 0 else null !&Value

    var debug_values: &[DebugParam]
    if arg >= 0 {
        debug_values = allocate_ref(DebugParam, 6)
    } else {
        debug_values = allocate_ref(DebugParam, 5)
    }

    debug_values(0) = [
        name = "name", value = [ kind = DebugValueKind::STRING, s = name ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "scope", value = meta_to_debug_value(discope)
    ] !DebugParam
    debug_values(2) = [
        name = "file", value = meta_to_debug_value((@state).difile)
    ] !DebugParam
    debug_values(3) = [
        name = "line", value = [ kind = DebugValueKind::INT, i = line + 1 ] !DebugValue
    ] !DebugParam
    debug_values(4) = [
        name = "type", value = meta_to_debug_value(di_type((@val.tpe).tpe, state))
    ] !DebugParam
    if arg >= 0 {
        debug_values(5) = [
            name = "arg", value = [ kind = DebugValueKind::INT, i = arg ] !DebugValue
        ] !DebugParam
    }

    let value = [
        kind = ValueKind::DEBUG_INFO,
        name = "DILocalVariable",
        debug_values = debug_values
    ] !&Value

    // These all need metadata set to true
    let args = allocate_ref(Value, 3)
    args(0) = val
    args(0).metadata = true
    args(1) = @push_meta(value, state)
    args(1).metadata = true
    args(2) = [
        metadata = true,
        kind = ValueKind::DEBUG_INFO,
        name = "DIExpression",
        debug_values = [] ![DebugParam]
    ] !Value

    let call = make_insn_dbg(InsnKind::CALL, make_location(node, state))
    (@call).value.call = [
        name = [ kind = ValueKind::GLOBAL, name = "llvm.dbg.declare" ] !Value,
        ret = NO_VALUE,
        args = args
    ] !InsnCall
    push_insn(call, state)
}

def push_declare(node: &parser::Node, val: Value, name: Str, state: &State) {
    push_declare_arg(node, val, name, -1, state)
}

export def make_int_value(v: int) -> Value {
    let value = [
        kind = ValueKind::INT,
        i = v,
        tpe = builtins::int_
    ] !Value
    return value
}

export def make_address_value(tpe: &typechecking::Type, addr: &Value, state: &State) -> Value {
    return [
        kind = ValueKind::ADDRESS,
        tpe = tpe,
        addr = addr
    ] !Value
}

export def make_local_value(tpe: &typechecking::Type, addr: &Value, state: &State) -> Value {
    let s = to_string(state.current_block.counter)
    state.current_block.counter += 1
    return [
        kind = ValueKind::LOCAL,
        name = s,
        tpe = tpe,
        addr = addr
    ] !Value
}

export def make_named_local(tpe: &typechecking::Type, addr: &Value, state: &State) -> Value {
    let name = "__tmp." + state.local_counter
    state.local_counter += 1

    return [
        kind = ValueKind::LOCAL,
        name = name,
        tpe = tpe,
        addr = addr
    ] !Value
}

export def make_global_name(name: Str, state: &State) -> Str {
    let ret = state.module.module + "::" + name + '.' + state.global_counter
    state.global_counter += 1
    return ret
}

export def make_global_value(tpe: &typechecking::Type, name: Str, value: &Value, state: &State, private: bool = true) -> Value {
    name = make_global_name(name, state)

    let global = [
        private = private,
        name = name,
        tpe = tpe,
        value = value,
        line = -1
    ] !&Global
    state.module.result.globals(global.name) = global
    if not private {
        state.module.imported.add(global.name)
    }

    return [
        kind = ValueKind::GLOBAL,
        name = name,
        tpe = typechecking::pointer(tpe),
        addr = null
    ] !Value
}

export def load_value(value: Value, loc: &Value, state: &State) -> Value {
    if value.addr {
        let ret = make_local_value(value.tpe, value.addr, state)
        let load = make_insn_dbg(InsnKind::LOAD, loc)
        (@load).value.load = [
            value = ret,
            loc = @value.addr
        ] !InsnLoad
        push_insn(load, state)
        // TODO Temporary hack for builtin functions
        ret.value_tpe = value.value_tpe
        return ret
    } else {
        return value
    }
}

export def charp_str(value: Value, state: &State) -> Value {
    let local = make_local_value(typechecking::pointer(builtins::char_), null, state)

    let index = allocate_ref(int, 1)
    index(0) = 1

    let extract = make_insn(InsnKind::EXTRACTVALUE)
    (@extract).value.extract_value = [
        ret = local,
        value = value,
        index = index
    ] !InsnExtractValue

    push_insn(extract, state)

    return local
}

export def charp_static(global: &Value, state: &State) -> Value {
    let local = make_local_value(typechecking::pointer(builtins::char_), global, state)

    let index = allocate_ref(Value, 2)
    index(0) = make_int_value(0)
    index(1) = make_int_value(0)

    let gep = make_insn(InsnKind::GETELEMENTPTR)
    (@gep).value.gep = [
        ret = local,
        tpe = global.tpe.tpe,
        value = @global,
        index = index
    ] !InsnGetElementPtr

    push_insn(gep, state)

    return local
}

export def create_global_string(str: Str, state: &State) -> Value {
    let tpe = typechecking::make_type_raw(typechecking::TypeKind::STATIC_ARRAY)
    tpe._tpe = builtins::char_
    tpe.length = str.length() + 1
    tpe.size = tpe.length * (size_of char)
    tpe.align = align_of char

    let value = [
        kind = ValueKind::STRING,
        s = str.to_array(),
        tpe = tpe
    ] !&Value

    return make_global_value(tpe, "str", value, state)
}

export def charp(str: Str, state: &State) -> Value {
    return charp_static(create_global_string(str, state), state)
}

def push_scope(node: &parser::Node, state: &State) {
    if state.current_function.has_yield {
        state.current_function.current_snapshot.push(map::make(int))
    }

    if not toolchain::debug_sym { return }
    let discope = vector::peek(state.discope) if state.discope.length > 0 else null !&Value

    let debug_values = allocate_ref(DebugParam, 4)
    debug_values(0) = [
        name = "scope", value = meta_to_debug_value(discope)
    ] !DebugParam
    debug_values(1) = [
        name = "file", value = meta_to_debug_value((@state).difile)
    ] !DebugParam
    debug_values(2) = [
        name = "line", value = [ kind = DebugValueKind::INT, i = node.loc.line + 1] !DebugValue
    ] !DebugParam
    debug_values(3) = [
        name = "column", value = [ kind = DebugValueKind::INT, i = node.loc.column + 1] !DebugValue
    ] !DebugParam

    let dilexical = [
        kind = ValueKind::DEBUG_INFO,
        name = "DILexicalBlock",
        distinct = true,
        debug_values = debug_values
    ] !&Value

    vector::push((@state).discope, push_meta(dilexical, state))
}

def pop_scope(state: &State) {
    if toolchain::debug_sym {
        vector::pop((@state).discope)
    }

    if state.current_function.has_yield {
        if state.current_function.current_snapshot.length == 1 {
            abort()
        }
        state.current_function.current_snapshot.pop()
    }
}

// TODO We might want to cache this somewhere
def make_return_type(tpe: &typechecking::Type) -> &typechecking::Type {
    let length = vector::length(tpe.return_t)
    let fields = allocate_ref(typechecking::StructMember, length)

    for var i in 0..length {
        let t = tpe.return_t(i)
        // TODO Add an underscore in front for the debugger
        let name = to_string(i)

        fields(i) = [ line = tpe.line, name = name, tpe = t ] !typechecking::StructMember
    }

    return typechecking::make_struct_type(fields)
}

def import_structure(tpe: &typechecking::Type, module: &toolchain::Module) {
    if not tpe { return }
    if not module.result.structures.contains(tpe.type_name) or tpe.kind == typechecking::TypeKind::STUB {
        module.result.structures(tpe.type_name) = tpe
        if tpe.fields {
            for var i in 0..tpe.fields.size {
                let field = tpe.fields(i)
                typechecking::lookup_struct_member(field)
                import_structures(field.tpe, module)
            }
        }
    }
}

export def import_structures(tpe: &typechecking::Type, module: &toolchain::Module) {
    if not tpe { return }
    if tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.weak
    }
    switch tpe.kind !int {
        case typechecking::TypeKind::STRUCT..=typechecking::TypeKind::UNION
            import_structure(tpe, module)
        case typechecking::TypeKind::ARRAY, 
            typechecking::TypeKind::STATIC_ARRAY, 
            typechecking::TypeKind::POINTER, 
            typechecking::TypeKind::REFERENCE,
            typechecking::TypeKind::WEAK_REF
            import_structures(tpe.tpe, module)
        case typechecking::TypeKind::FUNCTION, typechecking::TypeKind::CLOSURE
            for var i in 0..vector::length(tpe.parameter_t) {
                let param = tpe.parameter_t(i)
                import_structures(param.tpe, module)
            }
            for var i in 0..vector::length(tpe.return_t) {
                let t = tpe.return_t(i)
                import_structures(t, module)
            }
        case typechecking::TypeKind::STUB
            if not map::contains(module.result.structures, tpe.type_name) {
                module.result.structures(tpe.type_name) = tpe
            }
    }
}

def import_cstd_function(name: Str, state: &State) {
    let cstd_module = toolchain::find_module("cstd")
    var func = scope::get(cstd_module.scope, parser::make_identifier(name))
    if not func { return }
    predeclare_function(func.tpe, state.module)
    if consteval::is_static {
        consteval::compile_function(func, state.scope)
    }
    state.module.imported.add(name)
}

export def walk_and_load_expression(node: &parser::Node, state: &State) -> Value {
    let expr = walk_expression(node, state)
    return load_value(expr, make_location(node, state), state)
}

def walk_Null(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    let value = [
        kind = ValueKind::NULL,
        tpe = tpe
    ] !Value
    return value
}

def walk_Boolean(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    let value = [
        kind = ValueKind::BOOL,
        i = node.value.i,
        tpe = tpe
    ] !Value
    return value
}

def walk_Integer(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    let value = [
        kind = ValueKind::INT,
        i = node.value.i,
        tpe = tpe
    ] !Value
    return value
}

def walk_Float(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    let value = [
        kind = ValueKind::FLOAT,
        f = node.value.f,
        tpe = tpe
    ] !Value
    return value
}

def walk_Char(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    let value = [
        kind = ValueKind::INT,
        i = node.value.i,
        tpe = tpe
    ] !Value
    return value    
}

def walk_String(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let tpe = node.tpe
    if not tpe { return NO_VALUE }

    let strtpe = typechecking::make_type_raw(typechecking::TypeKind::STATIC_ARRAY)
    (@strtpe)._tpe = builtins::char_
    (@strtpe).length = node.value.str.length() + 1
    (@strtpe).size = (@strtpe).length * (size_of char)
    (@strtpe).align = align_of char
    
    let str_value = [
        kind = ValueKind::STRING,
        s = node.value.str.to_array(),
        tpe = tpe
    ] !&Value

    let global = make_global_value(strtpe, "str", str_value, state)

    let alloca_ret = state.alloca(tpe, loc)
    
    let index = allocate_ref(Value, 2)
    index(0) = make_int_value(0)
    index(0).tpe = builtins::size_t_
    index(1) = make_int_value(0)
    index(1).tpe = builtins::size_t_

    let gep_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    (@gep).value.gep = [
        ret = gep_ret,
        tpe = strtpe,
        value = global,
        index = index
    ] !InsnGetElementPtr
    push_insn(gep, state)
    
    let ret = make_local_value(tpe, alloca_ret, state)

    let values = allocate_ref(Value, 2)
    values(0) = [
        kind = ValueKind::INT,
        tpe = builtins::size_t_,
        i = node.value.str.length() + 1
    ] !Value
    values(1) = [
        kind = ValueKind::UNDEF,
        tpe = typechecking::pointer(tpe.tpe)
    ] !Value

    let value = [
        kind = ValueKind::STRUCT,
        values = values,
        tpe = tpe
    ] !Value

    let index2 = allocate_ref(int, 1)
    index2(0) = 1
    let insert = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    (@insert).value.insert_value = [
        ret = ret,
        value = value,
        element = gep_ret, 
        index = index2
    ] !InsnInsertValue
    push_insn(insert, state)

    let store = make_insn_dbg(InsnKind::STORE, loc)
    store.value.store = [
        value = ret,
        loc = alloca_ret
    ] !InsnStore
    push_insn(store, state)

    return ret
}

def resolve_types(cache: &Vector(TypeEntry)) {
    let state = toolchain::types_state
    // We need an independent block that we can run for constant evaluation
    let old_block = toolchain::types_state.current_block
    let new_block = make_block()
    new_block.counter = old_block.counter
    state.current_block = new_block

    while cache.length > 0 {
        let first = cache(0)
        cache.remove(0)
        first.value.value = do_create_type(first.tpe, first.value, first.module, cache)
        first.value.phase = scope::Phase::COMPILED
    }
        
    old_block.counter = new_block.counter
    for var i in 0..vector::length(new_block.insn) {
        old_block.insn.push(new_block.insn(i))
    }

    if state.consteval {
        let old_cstate_block = consteval::compiler_state.current_block

        let function = [
            name = "__main__",
            unmangled = "__main__",
            forward_declare = true,
            allocas = vector::make(type &Insn),
            block = new_block,
            function_locals = set::make()
        ] !&Function

        consteval::compiler_state.function_stack.push(function)
        consteval::compiler_state.current_block = new_block
        
        // Copy constants into the right module
        // TODO This always copies the whole thing
        let keys = map::keys(toolchain::types.result.globals)
        for var i in 0..keys.size {
            let key = keys(i)
            let global = toolchain::types.result.globals(key)
            consteval::const_module.result.globals(key) = global
        }

        let old_module = consteval::compiler_state.module
        consteval::compiler_state.module = consteval::const_module 
        eval::eval(consteval::compiler_state)
        consteval::compiler_state.module = old_module
        consteval::compiler_state.current_block = old_cstate_block
        consteval::compiler_state.function_stack.pop()
    }

    state.current_block = old_block
}

export def create_type(tpe: &typechecking::Type, module: &toolchain::Module) -> &Value {
    let cache = vector::make(TypeEntry) // TODO Should probably use a linked list here
    let ret = create_type(tpe, module, cache)
    resolve_types(cache)
    return ret
}

// TODO This name is stupid
def do_create_type(tpe: &typechecking::Type, module: &toolchain::Module) -> Value {
    let value = create_type(tpe, module)
    if value { return @value }
    return [ kind = ValueKind::NULL, tpe = typechecking::pointer(builtins::Type_) ] !Value
}

// Variants are a type followed by a union
def convert_value_to_variant(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    let ptr_variant = state.alloca(tpe, loc, no_yield_capture = true)
    state.store(ptr_variant, [ kind = ValueKind::ZEROINITIALIZER, tpe = tpe ] !Value, loc)

    let union_tpe = pointer([kind = typechecking::TypeKind::WORD, size = tpe.tpe.align ] !&typechecking::Type)
    var tptr = state.gep(pointer(pointer(builtins::Type_)), tpe, ptr_variant, [make_int_value(0), make_int_value(0)], loc)
    var vptr = state.gep(union_tpe, tpe, ptr_variant, [make_int_value(0), make_int_value(1), make_int_value(0)], loc)
    vptr = state.bitcast(pointer(value.tpe), vptr, loc)

    state.store(vptr, value, loc)
    let ctpe = do_create_type(value.tpe, state.module)
    state.store(tptr, ctpe, loc)

    return state.load(tpe, ptr_variant, loc)
}

def convert_variant_to_variant(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if value.addr { // Make it work with values that don't have an address
        value = @value.addr
    } else {
        var tmp = state.alloca(value.tpe, loc, no_yield_capture = true)
        state.store(value, tmp, loc)
        value = tmp
    }
    
    let ptr_variant = state.alloca(tpe, loc, no_yield_capture = true)
    
    var ptpein = state.gep(pointer(pointer(builtins::Type_)), value.tpe.tpe, value, [make_int_value(0), make_int_value(0)], loc)
    var ptpeout = state.gep(pointer(pointer(builtins::Type_)), tpe, ptr_variant, [make_int_value(0), make_int_value(0)], loc)
    var vin = state.gep(pointer(value.tpe.tpe.tpe), value.tpe.tpe, value, [make_int_value(0), make_int_value(1)], loc)
    var vout = state.gep(pointer(tpe.tpe), tpe, ptr_variant, [make_int_value(0), make_int_value(1)], loc)

    let vptr = state.bitcast(pointer(tpe.tpe), vin, loc)
    let v = state.load(tpe.tpe, vptr, loc)
    state.store(vout, v, loc)

    let ptpe = state.load(pointer(builtins::Type_), ptpein, loc)
    state.store(ptpeout, ptpe)
    return state.load(tpe, ptr_variant, loc)
}

def convert_variant_to_value(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if value.addr { // Make it work with values that don't have an address
        value = @value.addr
    } else {
        var tmp = state.alloca(value.tpe, loc, no_yield_capture = true)
        state.store(value, tmp, loc)
        value = tmp
    }

    let union_tpe = pointer([ kind = typechecking::TypeKind::WORD, size = value.tpe.tpe.tpe.align ] !&typechecking::Type)
    var vptr = state.gep(union_tpe, value.tpe.tpe, value, [make_int_value(0), make_int_value(1), make_int_value(0)], loc)
    vptr = state.bitcast(pointer(tpe), vptr, loc)
    return state.load(tpe, vptr, loc)
}

def convert_ref_to_ref(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if is_interface(tpe.tpe) and is_interface(value.tpe.tpe) {
        // Interface is already i8 so we don't need to convert anything
        return value
    }
    
    if not value.tpe {
        return NO_VALUE
    }
    if tpe.tpe {
        typechecking::create_type_entry(tpe)
    }

    add_type_meta(tpe, state)

    let index1 = allocate_ref(int, 1)
    index1(0) = 0
    
    let extract1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let extract1 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract1.value.extract_value = [
        ret = extract1_ret,
        value = value,
        index = index1
    ] !InsnExtractValue
    push_insn(extract1, state)

    let index2 = allocate_ref(int, 1)
    index2(0) = 1
    
    let extract2_ret = make_local_value(typechecking::pointer(value.tpe.tpe), null, state)
    let extract2 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract2.value.extract_value = [
        ret = extract2_ret,
        value = value,
        index = index2
    ] !InsnExtractValue
    push_insn(extract2, state)

    let index3 = allocate_ref(int, 1)
    index3(0) = 2
    
    let extract3_ret = make_local_value(typechecking::pointer(builtins::Type_), null, state)
    let extract3 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract3.value.extract_value = [
        ret = extract3_ret,
        value = value,
        index = index3
    ] !InsnExtractValue
    push_insn(extract3, state) 

    let bitcast_ret = make_local_value(typechecking::pointer(tpe.tpe if tpe.tpe else builtins::int8_), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = [
        ret = bitcast_ret,
        value = extract2_ret
    ] !InsnConvert
    push_insn(bitcast, state)

    var start = [ kind = ValueKind::UNDEF, tpe = tpe ] !Value

    let insert1_ret = make_local_value(tpe, null, state)
    let insert1 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert1.value.insert_value = [
        ret = insert1_ret,
        value = start,
        element = extract1_ret,
        index = index1
    ] !InsnInsertValue
    push_insn(insert1, state)

    let insert2_ret = make_local_value(tpe, null, state)
    let insert2 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert2.value.insert_value = [
        ret = insert2_ret,
        value = insert1_ret,
        element = bitcast_ret,
        index = index2
    ] !InsnInsertValue
    push_insn(insert2, state)

    let insert3_ret = make_local_value(tpe, null, state)
    let insert3 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert3.value.insert_value = [
        ret = insert3_ret,
        value = insert2_ret,
        element = extract3_ret,
        index = index3
    ] !InsnInsertValue
    push_insn(insert3, state)

    return insert3_ret
}

def convert_ref_to_ptr(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    let index = allocate_ref(int, 1)
    index(0) = 1
    let extract_ret = make_local_value(typechecking::pointer(value.tpe.tpe), null, state)
    let extract = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract.value.extract_value = [
        ret = extract_ret,
        value = value,
        index = index
    ] !InsnExtractValue
    push_insn(extract, state)

    let bitcast_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = [
        ret = bitcast_ret,
        value = extract_ret
    ] !InsnConvert
    push_insn(bitcast, state)

    return bitcast_ret
}

def convert_value_to_ref(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if tpe.tpe and value.tpe.kind != tpe.tpe.kind {
        value = convert_to(loc, value, tpe.tpe, state)
    }

    import_cstd_function("malloc", state)
    add_type_meta(tpe, state)

    var is_null = false
    if value.tpe.kind == typechecking::TypeKind::NULL { 
        value.tpe = tpe.tpe 
        is_null = true
    }

    // Create type entry
    typechecking::create_type_entry(reference(value.tpe))

    var refcount = [ kind = ValueKind::NULL, tpe = pointer(builtins::int64_) ] !Value

    if not is_null {
        let args1 = allocate_ref(Value, 1)
        args1(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = builtins::int64_.size ] !Value
        let call1_ret = make_local_value(typechecking::pointer(builtins::int8_), null, state)
        let call1 = make_insn_dbg(InsnKind::CALL, loc)
        call1.value.call = [
            name = [ kind = ValueKind::GLOBAL, name = "malloc" ] !Value,
            ret = call1_ret,
            args = args1
        ] !InsnCall
        push_insn(call1, state)

        refcount = make_local_value(typechecking::pointer(builtins::int64_), null, state)
        let bitcast1 = make_insn_dbg(InsnKind::BITCAST, loc)
        bitcast1.value.convert = [
            ret = refcount,
            value = call1_ret
        ] !InsnConvert
        push_insn(bitcast1, state)

        let store1 = make_insn_dbg(InsnKind::STORE, loc)
        store1.value.store = [
            loc = refcount,
            value = [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value
        ] !InsnStore
        push_insn(store1, state)
    }

    let start = [ kind = ValueKind::UNDEF, tpe = tpe ] !Value

    let index1 = allocate_ref(int, 1)
    index1(0) = 0
    let ret_insert1 = make_local_value(tpe, null, state)
    let insert1 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert1.value.insert_value = [
        ret = ret_insert1,
        value = start,
        element = refcount,
        index = index1
    ] !InsnInsertValue
    push_insn(insert1, state)

    var heapval: Value
    if not is_null {
        let args2 = allocate_ref(Value, 1)
        args2(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = value.tpe.size ] !Value
        let call2_ret = make_local_value(typechecking::pointer(builtins::int8_), null, state)
        let call2 = make_insn_dbg(InsnKind::CALL, loc)
        call2.value.call = [
            name = [ kind = ValueKind::GLOBAL, name = "malloc" ] !Value,
            ret = call2_ret,
            args = args2
        ] !InsnCall
        push_insn(call2, state)
        
        heapval = make_local_value(typechecking::pointer(value.tpe), null, state)
        let bitcast2 = make_insn_dbg(InsnKind::BITCAST, loc)
        bitcast2.value.convert = [
            ret = heapval,
            value = call2_ret
        ] !InsnConvert
        push_insn(bitcast2, state)
        
        if has_copy_constructor(value.tpe) {
            let ret = state.alloca(value.tpe, loc, no_yield_capture = true)
            insert_copy_constructor(ret, value, loc, state)
            value = state.load(value.tpe, ret, loc)
        } else if is_array(value.tpe) {
            import_cstd_function("memcpy", state)

            var size = NO_VALUE
            var data = NO_VALUE
            var new_ptr = NO_VALUE
            if value.tpe.kind == typechecking::TypeKind::ARRAY {
                // We need to copy the array
                size = state.extract_value(builtins::int64_, value, [0], loc)
                let size_in_bytes = state.mul(builtins::int64_, size, [ kind = ValueKind::INT, tpe = builtins::int64_, i = value.tpe.tpe.size ] !Value, loc)
                data = state.extract_value(pointer(value.tpe.tpe), value, [1], loc)
                let ptr_i8 = state.bitcast(pointer(builtins::int8_), data, loc)
                let new_ptr_i8 = state.call("malloc", pointer(builtins::int8_), [size_in_bytes], loc)
                state.call("memcpy", pointer(builtins::int8_), [new_ptr_i8, ptr_i8, size_in_bytes], loc)
                new_ptr = state.bitcast(pointer(value.tpe.tpe), new_ptr_i8, loc)
                value = [ kind = ValueKind::UNDEF, tpe = value.tpe ] !Value
                value = state.insert_value(value.tpe, value, size, [0], loc)
                value = state.insert_value(value.tpe, value, new_ptr, [1], loc)
            } else {
                data = @value.addr
                size = [ kind = ValueKind::INT, tpe = builtins::int64_, i = value.tpe.length ] !Value
                let size_in_bytes = [ kind = ValueKind::INT, tpe = builtins::int64_, i = value.tpe.size ] !Value
                let ptr_i8 = state.bitcast(pointer(builtins::int8_), @value.addr, loc)
                state.call("memcpy", pointer(builtins::int8_), [call2_ret, ptr_i8, size_in_bytes], loc)
                new_ptr = state.bitcast(pointer(value.tpe), call2_ret, loc)
                value = state.load(value.tpe, new_ptr, loc)
            }

            if is_ref(value.tpe.tpe) or has_copy_constructor(value.tpe.tpe) {
                // TODO The looping bit should be extracted into its own function, let's see what we can do once we have closures
                let counter_ptr = state.alloca(builtins::size_t_)
                state.store(counter_ptr, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 0 ] !Value)
                
                let br_to_start = make_insn_dbg(InsnKind::BR_UNC, loc)
                push_insn(br_to_start, state)

                let loop_start = make_label(state)
                push_label(loop_start, state)
                br_to_start.value.br_unc.label_ = loop_start
                
                let counter_value = state.load(builtins::size_t_, counter_ptr)
                let cond = state.icmp(CompareInt::eq, counter_value, size)
                let br = make_insn_dbg(InsnKind::BR, loc)
                br.value.br = [ cond = cond ] !InsnBr
                push_insn(br, state)

                let loop_inner = make_label(state)
                push_label(loop_inner, state)
                br.value.br.if_false = loop_inner

                let ptpe = pointer(value.tpe.tpe)
                var array_val = NO_VALUE
                if value.tpe.kind == typechecking::TypeKind::ARRAY {
                    array_val = state.gep(ptpe, value.tpe.tpe, data, [counter_value], loc)
                } else {
                    array_val = state.gep(ptpe, value.tpe, data, [make_int_value(0), counter_value], loc)
                }

                if is_ref(value.tpe.tpe) {
                    increase_ref_count(array_val, loc, state)
                } else if has_copy_constructor(value.tpe.tpe) {
                    let val = state.load(value.tpe.tpe, array_val, loc)
                    let addr = state.gep(ptpe, value.tpe.tpe, new_ptr, [counter_value], loc)
                    insert_copy_constructor(addr, val, loc, state)
                }

                let counter_inc = state.add(builtins::size_t_, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value, loc)
                state.store(counter_ptr, counter_inc)

                push_insn(br_to_start, state)

                let loop_end = make_label(state)
                push_label(loop_end, state)
                br.value.br.if_true = loop_end
            }
        }

        let store2 = make_insn_dbg(InsnKind::STORE, loc)
        store2.value.store = [
            loc = heapval,
            value = value
        ] !InsnStore
        push_insn(store2, state)

        if not typechecking::equals(tpe.tpe, value.tpe) {
            let bitcast2_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
            let bitcast2 = make_insn_dbg(InsnKind::BITCAST, loc)
            bitcast2.value.convert = [
                ret = bitcast2_ret,
                value = heapval
            ] !InsnConvert
            push_insn(bitcast2, state)
            heapval = bitcast2_ret
        }
    } else {
        heapval = [ kind = ValueKind::NULL, tpe = typechecking::pointer(value.tpe) ] !Value
    }
    
    let index2 = allocate_ref(int, 1)
    index2(0) = 1
    let ret_insert2 = make_local_value(tpe, null, state)
    let insert2 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert2.value.insert_value = [
        ret = ret_insert2,
        value = ret_insert1,
        element = heapval,
        index = index2
    ] !InsnInsertValue
    push_insn(insert2, state)

    let svalue = do_create_type(typechecking::reference(value.tpe), state.module)

    let index3 = allocate_ref(int, 1)
    index3(0) = 2
    let ret_insert3 = make_local_value(tpe, null, state)
    let insert3 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
    insert3.value.insert_value = [
        ret = ret_insert3,
        value = ret_insert2,
        element = svalue,
        index = index3
    ] !InsnInsertValue
    push_insn(insert3, state)

    /*if not is_null and not is_captured {
        // Destroy the value
        let ptr = state.alloca(tpe, loc)
        state.store(ptr, ret_insert3)
        insert_destructor(ptr, loc, state)
    }*/

    if builtins::builtins.fields.contains("DEBUG_REF_CYCLES") and not consteval::is_static {
        var line = -1
        if loc {
            let di = state.module.result.metadata(loc.name)
            line = di.debug_values(0).value.i !int
        }
        let linev = make_int_value(line) 
        let filev = charp_static(state.file_name_value, state)
        let fun = toolchain::find_module("std").scope.get(parser::make_identifier("add_root")).tpe
        predeclare_function(fun, state.module)
        state.module.imported.add(fun.type_name)
        import_structure(builtins::Ref_, state.module)
        state.call(fun.type_name, null, [convert_ref_to_ref(builtins::Ref_, ret_insert3, loc, state), filev, linev], loc)
    }

    return ret_insert3
}

// This function needs to be called with an address value
def convert_array_to_array(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if (@value.tpe).kind == typechecking::TypeKind::STATIC_ARRAY and
        (@value.tpe).length == 0 {

        let values = allocate_ref(Value, 2)
        values(0) = [
            kind = ValueKind::INT,
            tpe = builtins::size_t_,
            i = (@value.tpe).length
        ] !Value
        values(1) = [
            kind = ValueKind::NULL,
            tpe = typechecking::pointer(tpe.tpe)
        ] !Value
        return [
            kind = ValueKind::STRUCT,
            values = values,
            tpe = tpe
        ] !Value
    } else if (@value.tpe).kind == typechecking::TypeKind::STATIC_ARRAY and 
        (not tpe.tpe or typechecking::equals(tpe.tpe, (@value.tpe).tpe)) {

        var local = make_local_value(typechecking::pointer((@value.tpe).tpe), null, state)

        let index = allocate_ref(Value, 2)
        index(0) = make_int_value(0)
        index(0).tpe = builtins::size_t_
        index(1) = make_int_value(0)
        index(1).tpe = builtins::size_t_

        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = [
            ret = local,
            tpe = value.tpe,
            value = @value.addr,
            index = index
        ] !InsnGetElementPtr

        push_insn(gep, state)

        if not tpe.tpe {
            let local1 = local
            local = make_local_value(typechecking::pointer(null), null, state)
            let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
            (@bitcast).value.convert = [
                ret = local,
                value = local1
            ] !InsnConvert

            push_insn(bitcast, state)
        }

        let ret = make_local_value(tpe, null, state)

        let values = allocate_ref(Value, 2)
        values(0) = [
            kind = ValueKind::INT,
            tpe = builtins::size_t_,
            i = (@value.tpe).length
        ] !Value
        values(1) = [
            kind = ValueKind::UNDEF,
            tpe = typechecking::pointer(tpe.tpe)
        ] !Value

        let value = [
            kind = ValueKind::STRUCT,
            values = values,
            tpe = tpe
        ] !Value

        let index2 = allocate_ref(int, 1)
        index2(0) = 1
        let insert = make_insn_dbg(InsnKind::INSERTVALUE, loc)
        (@insert).value.insert_value = [
            ret = ret,
            value = value,
            element = local, 
            index = index2
        ] !InsnInsertValue

        push_insn(insert, state)

        return ret
    } else if not tpe.tpe and (@value.tpe).kind == typechecking::TypeKind::ARRAY {
        value = load_value(value, loc, state)
        let index1 = allocate_ref(int, 1)
        index1(0) = 0

        let size = make_local_value(builtins::size_t_, null, state)
        let extract1 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
        (@extract1).value.extract_value = [
            ret = size,
            value = value,
            index = index1
        ] !InsnExtractValue

        push_insn(extract1, state)

        let index2 = allocate_ref(int, 1)
        index2(0) = 1

        let ptr = make_local_value(typechecking::pointer((@value.tpe).tpe), null, state)
        let extract2 = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
        (@extract2).value.extract_value = [
            ret = ptr,
            value = value,
            index = index2
        ] !InsnExtractValue

        push_insn(extract2, state)

        let bitcast_ret = make_local_value(typechecking::pointer(null), null, state)
        let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
        (@bitcast).value.convert = [
            ret = bitcast_ret,
            value = ptr
        ] !InsnConvert

        push_insn(bitcast, state)

        let insert1_ret = make_local_value(tpe, null, state)
        let insert1 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
        (@insert1).value.insert_value = [
            ret = insert1_ret,
            value = [ kind = ValueKind::UNDEF, tpe = tpe ] !Value,
            element = size,
            index = index1
        ] !InsnInsertValue

        push_insn(insert1, state)

        let insert2_ret = make_local_value(tpe, null, state)
        let insert2 = make_insn_dbg(InsnKind::INSERTVALUE, loc)
        (@insert2).value.insert_value = [
            ret = insert2_ret,
            value = insert1_ret,
            element = bitcast_ret,
            index = index2
        ] !InsnInsertValue

        push_insn(insert2, state)

        return insert2_ret
    } else {
        return load_value(value, loc, state)
    }
}

def convert_value_to_bool(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if typechecking::is_ref_or_weak(value.tpe) {
        value = state.extract_value(pointer(value.tpe.tpe if value.tpe.tpe else pointer(builtins::int8_)), value, [1], loc)
        value = convert_to(loc, value, builtins::size_t_, state)
    } else if typechecking::is_pointer(value.tpe) {
        // TODO This isn't the correct type, we need something like
        // intptr_t
        value = convert_to(loc, value, builtins::size_t_, state)
    } else if value.tpe and value.tpe.kind == typechecking::TypeKind::CLOSURE {
        let ptr = state.extract_value(value.tpe.fields(0).tpe, value, [0], loc)
        value = convert_to(loc, ptr, builtins::size_t_, state)
    }

    if typechecking::is_float(value.tpe) {
        let ret = make_local_value(builtins::bool_, null, state)
        let insn = make_insn_dbg(InsnKind::FCMP, loc)
        (@insn).value.fcmp = [
            op = CompareFloat::une,
            ret = ret,
            left = value,
            right = [
                kind = ValueKind::FLOAT,
                tpe = value.tpe,
                f = 0.0
            ] !Value
        ] !InsnFcmp
        push_insn(insn, state)
        return ret
    } else if typechecking::is_integer(value.tpe) {
        let ret = make_local_value(builtins::bool_, null, state)
        let insn = make_insn_dbg(InsnKind::ICMP, loc)
        (@insn).value.icmp = [
            op = CompareInt::ne,
            ret = ret,
            left = value,
            right = [
                kind = ValueKind::INT,
                tpe = value.tpe,
                i = 0
            ] !Value
        ] !InsnIcmp
        push_insn(insn, state)
        return ret
    }
    return value
}

def convert_fp_to_closure(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    var ret = [ kind = ValueKind::ZEROINITIALIZER, tpe = tpe ] !Value
    value = state.bitcast(tpe.fields(0).tpe, value, loc)
    ret = state.insert_value(tpe, ret, value, [0], loc)
    add_type_meta(tpe, state)
    return ret
}

def convert_tuple_to_array(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    let len = value.tpe.return_t.length

    let static_arr_tpe = typechecking::make_static_array(tpe.tpe, len)
    let arr = state.alloca(static_arr_tpe)

    for var i in 0..value.tpe.return_t.length {
        let elem = value.tpe.return_t(i)
        let tuple_elem_ptr = state.gep(pointer(elem), pointer(value.tpe), @value.addr, [make_int_value(i)], loc)
        let elem_conv = convert_to(loc, state.load(elem, tuple_elem_ptr, loc), tpe.tpe, state)
        let arr_ptr = state.gep(pointer(tpe.tpe), pointer(static_arr_tpe), arr, [make_int_value(i)], loc)
        state.store(arr_ptr, elem_conv, loc)
    }

    let values = allocate_ref(Value, 2)
    values(0) = [
        kind = ValueKind::INT,
        tpe = builtins::size_t_,
        i = len
    ] !Value
    values(1) = [
        kind = ValueKind::NULL,
        tpe = typechecking::pointer(tpe.tpe)
    ] !Value

    let ret = [
        kind = ValueKind::STRUCT,
        values = values,
        tpe = tpe
    ] !Value

    return state.insert_value(tpe, ret, arr, [1], loc)
}

def convert_tuple_to_static_array(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    let len = value.tpe.return_t.length

    let static_arr_tpe = typechecking::make_static_array(tpe.tpe, len)
    let arr = state.alloca(static_arr_tpe)

    var ret = [ kind = ValueKind::UNDEF, tpe = static_arr_tpe ] !Value
    for var i in 0..value.tpe.return_t.length {
        let elem = value.tpe.return_t(i)
        let tuple_elem_ptr = state.gep(pointer(elem), value.tpe, @value.addr, [make_int_value(0), make_int_value(i)], loc)
        let elem_conv = convert_to(loc, state.load(elem, tuple_elem_ptr, loc), tpe.tpe, state)
        ret = state.insert_value(static_arr_tpe, ret, elem_conv, [i], loc)
    }

    return ret
}

def convert_static_array_to_tuple(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    let len = value.tpe.length

    var ret = [ kind = ValueKind::UNDEF, tpe = tpe ] !Value
    for var i in 0..value.tpe.length {
        let elem = tpe.return_t(i)
        let array_elem_ptr = state.gep(pointer(value.tpe.tpe), value.tpe, @value.addr, [make_int_value(0), make_int_value(i)], loc)
        let elem_conv = convert_to(loc, state.load(value.tpe.tpe, array_elem_ptr, loc), elem, state)
        ret = state.insert_value(tpe, ret, elem_conv, [i], loc)
    }

    return ret
}

def convert_anon_to_struct(tpe: &typechecking::Type, value: Value, loc: &Value, state: &State) -> Value {
    if tpe.field_types.length != value.tpe.field_types.length { return NO_VALUE }
    
    var fast_path = true
    for var i in 0..tpe.field_types.length {
        let tpea = tpe.field_types(i).tpe
        let tpeb = value.tpe.field_types(i).tpe
        if not typechecking::equals(tpea, tpeb) {
            fast_path = false
            break
        }
    }

    if fast_path { return value }

    var res = [ kind = ValueKind::UNDEF, tpe = tpe ] !Value
    for var fielda in @value.tpe.fields {
        let member = state.extract_value(value.tpe.field_types(fielda.index).tpe, value, [fielda.index !int], loc)
        
        var index = fielda.index
        for var fieldb in @tpe.fields {
            if fieldb.name == fielda.name {
                index = fieldb.index
                break
            }
        }
        res = state.insert_value(tpe, res, member, [index !int], loc)
    }

    return res
}

export def convert_to(node: &parser::Node, value: Value, tpe: &typechecking::Type, state: &State) -> Value {
    let loc = make_location(node, state)
    return convert_to(loc, value, tpe, state)
}

def convert_to(kind: InsnKind, loc: &Value, value: Value, tpe: &typechecking::Type, state: &State) -> Value {
    value = load_value(value, loc, state)
    let ret = make_local_value(tpe, null, state)
    let insn = make_insn_dbg(kind, loc)
    (@insn).value.convert = [
        ret = ret,
        value = value
    ] !InsnConvert

    push_insn(insn, state)
    return ret
}

// value gets loaded by this function
def convert_to(loc: &Value, value: Value, tpe: &typechecking::Type, state: &State) -> Value {
    if not value.tpe or not tpe { return NO_VALUE }
    
    if typechecking::equals(value.tpe, tpe) {
        return load_value(value, loc, state)
    }

    if value.tpe.kind != typechecking::TypeKind::NULL {
        let parameter_t = vector::make(NamedParameter)
        parameter_t.push([_tpe = value.tpe] !NamedParameter)
        let conv = scope::find_implicit_function(state.scope, parameter_t, tpe)
        if conv {
            if consteval::is_static {
                consteval::compile_function(conv, state.scope)
            }

            import_structures(conv.tpe, state.module)
            predeclare_function(conv.tpe, state.module)
            state.module.imported.add(conv.tpe.type_name)

            value = load_value(value, loc, state)
            if typechecking::has_copy_constructor(value.tpe) {
                let ret = state.alloca(value.tpe, loc, no_yield_capture = true)
                insert_copy_constructor(ret, value, loc, state)
                value = state.load(value.tpe, ret, loc)
            }

            value = convert_to(loc, value, conv.tpe.parameter_t(0).tpe, state)
            
            let addr = state.alloca(tpe, loc)
            value = call(state, conv.tpe.type_name, tpe, [value], loc)
            state.store(addr, value, loc)
            create_temporary(addr, value, loc, state)
            return value
        }
    }
    if tpe.kind == value.tpe.kind and value.tpe.is_anon and typechecking::is_struct(value.tpe) {
        return convert_anon_to_struct(tpe, value, loc, state)
    }
    if tpe.kind == typechecking::TypeKind::TUNION {
        if value.tpe.kind == typechecking::TypeKind::TUNION {
            return convert_variant_to_variant(tpe, value, loc, state)
        } else {
            return convert_value_to_variant(tpe, load_value(value, loc, state), loc, state)
        }
    } else if value.tpe.kind == typechecking::TypeKind::TUNION {
        return convert_variant_to_value(tpe, value, loc, state)
    }

    if typechecking::is_ref_or_weak(tpe) and typechecking::equals(value.tpe, builtins::Ref_) {
        return convert_ref_to_ref(tpe, load_value(value, loc, state), loc, state)
    }
    if typechecking::equals(tpe, builtins::Ref_) and typechecking::is_ref_or_weak(value.tpe) {
        return convert_ref_to_ref(tpe, load_value(value, loc, state), loc, state)
    }
    if typechecking::is_pointer(tpe) and typechecking::is_ref_or_weak(value.tpe) {
        return convert_ref_to_ptr(tpe, load_value(value, loc, state), loc, state)
    }
    if tpe.kind == typechecking::TypeKind::CLOSURE and is_function_pointer(value.tpe) {
        return convert_fp_to_closure(tpe, load_value(value, loc, state), loc, state)
    }
    if tpe.kind == typechecking::TypeKind::ARRAY and value.tpe.kind == typechecking::TypeKind::TUPLE {
        return convert_tuple_to_array(tpe, value, loc, state)
    }
    if tpe.kind == typechecking::TypeKind::STATIC_ARRAY and value.tpe.kind == typechecking::TypeKind::TUPLE {
        return convert_tuple_to_static_array(tpe, value, loc, state)
    }
    if tpe.kind == typechecking::TypeKind::TUPLE and value.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
        return convert_static_array_to_tuple(tpe, value, loc, state)
    }
    if tpe.kind == typechecking::TypeKind::ARRAY {
        return convert_array_to_array(tpe, value, loc, state)
    } 
    if tpe.kind == typechecking::TypeKind::BOOL {
        return convert_value_to_bool(tpe, load_value(value, loc, state), loc, state)
    } 
    if typechecking::is_integer(tpe) {
        var kind: InsnKind
        if value.tpe.kind == typechecking::TypeKind::BOOL {
            return convert_to(InsnKind::ZEXT, loc, value, tpe, state)
        } else if typechecking::is_integer(value.tpe) {
            if (@value.tpe).size == tpe.size {
                // Types only differ in sign, llvm doesn't treat them any different
                let val = load_value(value, loc, state)
                val.tpe = tpe
                return val
            } else if (@value.tpe).size > tpe.size {
                return convert_to(InsnKind::TRUNC, loc, value, tpe, state)
            } else if tpe.unsig {
                return convert_to(InsnKind::ZEXT, loc, value, tpe, state)
            } else {
                return convert_to(InsnKind::SEXT, loc, value, tpe, state)
            }
        } else if typechecking::is_float(value.tpe) {
            if tpe.unsig {
                return convert_to(InsnKind::FPTOUI, loc, value, tpe, state)
            } else {
                return convert_to(InsnKind::FPTOSI, loc, value, tpe, state)
            }
        } else if typechecking::is_pointer(value.tpe) {
            return convert_to(InsnKind::PTRTOINT, loc, value, tpe, state)
        }
    }
    if typechecking::is_float(tpe) {
        if typechecking::is_integer(value.tpe) {
            if (@value.tpe).unsig {
                return convert_to(InsnKind::UITOFP, loc, value, tpe, state)
            } else {
                return convert_to(InsnKind::SITOFP, loc, value, tpe, state)
            }
        } else if typechecking::is_float(value.tpe) {
            if (@value.tpe).size > tpe.size {
                return convert_to(InsnKind::FPTRUNC, loc, value, tpe, state)
            } else {
                return convert_to(InsnKind::FPEXT, loc, value, tpe, state)
            }
        }
    }
    if typechecking::is_pointer(tpe) {
        if (@value.tpe).kind == typechecking::TypeKind::NULL {
            return [ 
                kind = ValueKind::NULL, 
                tpe = tpe 
            ] !Value
        } else if typechecking::is_pointer(value.tpe) or (@value.tpe).kind == typechecking::TypeKind::NULL {
            return convert_to(InsnKind::BITCAST, loc, value, tpe, state)
        } else if typechecking::is_integer(value.tpe) {
            return convert_to(InsnKind::INTTOPTR, loc, value, tpe, state)
        }
    } 
    if typechecking::is_ref_or_weak(tpe) and typechecking::is_ref_or_weak(value.tpe) {
        return convert_ref_to_ref(tpe, load_value(value, loc, state), loc, state)
    }
    if typechecking::is_ref_or_weak(tpe) and (typechecking::is_assignable(tpe.tpe, value.tpe, state.module) or 
        typechecking::is_assignable(tpe, typechecking::reference(value.tpe), state.module) or 
        tpe.tpe == null or value.tpe.kind == typechecking::TypeKind::NULL) {
        return convert_value_to_ref(tpe, load_value(value, loc, state), loc, state)
    }

    return load_value(value, loc, state)
}

def walk_Cast(node: &parser::Node, state: &State) -> Value {
    let tpe = node.value.bin_op.right
    scope::create_dependency_on_type(state.current_value(), tpe)

    let value = walk_and_load_expression(node.value.bin_op.left, state)
    import_structures(node.tpe, state.module)
    add_type_meta(node.value.bin_op.left.tpe, state)
    add_type_meta(node.tpe, state)
    return convert_to(node, value, node.tpe, state)
}

def walk_StructLitUnion(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let args = node.value.struct_lit.args
    let kwargs = node.value.struct_lit.kwargs
    var tpe = node.tpe

    if typechecking::is_ref(tpe) {
        tpe = tpe.tpe
    }

    let largs = vector::length(args)
    let lkwargs = vector::length(kwargs)
    if largs > 1 or lkwargs > 1 or largs == 1 and lkwargs == 1 {
        errors::errorn(node, "Union initalizer can only have one argument")
        return NO_VALUE
    } else if largs == 0 and lkwargs == 0 {
        return [
            kind = ValueKind::ZEROINITIALIZER,
            tpe = tpe
        ] !Value
    }

    var arg: &parser::Node = null
    var arg_tpe: &typechecking::Type = null
    if largs == 1 {
        arg = args(0)
        arg_tpe = tpe.fields(0).tpe
    } else {
        let kwarg = kwargs(0)
        arg = (@kwarg).value.named_arg.value
        let name = typechecking::last_ident_to_str((@kwarg).value.named_arg.name)

        for var j in 0..tpe.fields.size {
            let field = tpe.fields(j)
            if field.name == name {
                arg_tpe = field.tpe
                break
            }
        }
    }

    var value = convert_to(arg, walk_expression(arg, state), arg_tpe, state)
    if typechecking::is_ref(arg_tpe) {
        increase_ref_count_of_value(value, loc, state)
    } else if typechecking::has_copy_constructor(arg_tpe) {
        let ret = state.alloca(arg_tpe, loc, no_yield_capture = true)
        insert_copy_constructor(ret, value, loc, state)
        value = state.load(arg_tpe, ret, loc)
    }

    let alloca_ret = state.alloca(tpe, loc)

    let index = allocate_ref(Value, 2)
    index(0) = make_int_value(0)
    index(1) = make_int_value(0)
    let gep_ret = make_local_value(typechecking::pointer([ kind = typechecking::TypeKind::WORD, size = tpe.align ] !&typechecking::Type), null, state)
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    (@gep).value.gep = [
        ret = gep_ret,
        tpe = tpe,
        value = alloca_ret,
        index = index
    ] !InsnGetElementPtr
    push_insn(gep, state)

    let bitcast_ret = make_local_value(typechecking::pointer(arg_tpe), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    (@bitcast).value.convert = [
        ret = bitcast_ret,
        value = gep_ret
    ] !InsnConvert
    push_insn(bitcast, state)

    let store = make_insn_dbg(InsnKind::STORE, loc)
    (@store).value.store = [
        loc = bitcast_ret,
        value = value
    ] !InsnStore
    push_insn(store, state)

    let load_ret = make_local_value(tpe, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = [
        value = load_ret,
        loc = alloca_ret
    ] !InsnLoad
    push_insn(load, state)

    return load_ret
}

def locals_to_insert_value(value: &Value, state: &State) {
    let values = value.values
    for var i in 0..values.size {
        let val = values(i)
        if val.kind == ValueKind::LOCAL or val.kind == ValueKind::GLOBAL {
            values(i) = [
                kind = ValueKind::UNDEF,
                tpe = val.tpe
            ] !Value

            let ret = make_local_value(value.tpe, null, state)
            
            let index = allocate_ref(int, 1)
            index(0) = i
            let insert = make_insn(InsnKind::INSERTVALUE)
            (@insert).value.insert_value = [
                ret = ret,
                value = @value,
                element = val,
                index = index
            ] !InsnInsertValue
            
            push_insn(insert, state)
            @value = ret
        }
    }
}
 
def walk_StructLit(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let args = node.value.struct_lit.args
    let kwargs = node.value.struct_lit.kwargs

    var tpe = node.tpe
    if not tpe { return NO_VALUE }
    if typechecking::is_ref(tpe) {
        tpe = tpe.tpe
    }
        
    var value: &Value = NO_VALUE
    if typechecking::is_array(tpe) {
        return walk_ArrayLit(node, state)
    } else if tpe.kind == typechecking::TypeKind::UNION {
        value = walk_StructLitUnion(node, state)
    } else {
        var types = vector::make(type &typechecking::Type)
        if tpe.kind == typechecking::TypeKind::TUPLE {
            types = tpe.return_t
        } else {
            for var field in @tpe.fields {
                types.push(field.tpe)
            }
        }

        let values = allocate_ref(Value, types.length)
        for var i in 0..values.size {
            values(i) = [
                kind = ValueKind::ZEROINITIALIZER,
                tpe = types(i)
            ] !Value
        }
        for var i in 0..vector::length(args) {
            let arg = args(i)
            let arg_tpe = types(i)
            let value = walk_expression(arg, state)
            values(i) = convert_to(arg, value, arg_tpe, state)
            if typechecking::is_ref(arg_tpe) {
                increase_ref_count_of_value(values(i), loc, state)
            } else if typechecking::has_copy_constructor(arg_tpe) {
                let ret = state.alloca(values(i).tpe, loc, no_yield_capture = true)
                insert_copy_constructor(ret, values(i), loc, state)
                values(i) = state.load(values(i).tpe, ret, loc)
            }
        }
        for var i in 0..vector::length(kwargs) {
            let kwarg = kwargs(i)
            let name = typechecking::last_ident_to_str((@kwarg).value.named_arg.name)
            let value = walk_expression((@kwarg).value.named_arg.value, state)
            
            for var j in 0..tpe.fields.size {
                let field = tpe.fields(j)
                if field.name == name {
                    values(j) = convert_to(kwarg, value, field.tpe, state)
                    if typechecking::is_ref(field.tpe) {
                        increase_ref_count_of_value(values(j), loc, state)
                    } else if typechecking::has_copy_constructor(field.tpe) {
                        let ret = state.alloca(values(j).tpe, loc, no_yield_capture = true)
                        insert_copy_constructor(ret, values(j), loc, state)
                        values(j) = state.load(values(j).tpe, ret, loc)
                    }
                    break
                }
            }
        }
        value = [
            kind = ValueKind::STRUCT,
            values = values,
            tpe = tpe
        ] !&Value

        locals_to_insert_value(value, state)
    }

    let addr = state.alloca(tpe, loc)
    state.store(addr, @value, loc)
    create_temporary(addr, @value, loc, state)
    value.addr = addr

    return @value
}

def push_array_lit(tpe: &typechecking::Type, loc: &Value, values: &[Value], state: &State, temporary: bool = false) -> Value {
    var value = [
        kind = ValueKind::ARRAY,
        values = values,
        tpe = tpe
    ] !Value

    for var i in 0..values.size {
        let val = values(i)

        if val.kind == ValueKind::LOCAL or val.kind == ValueKind::GLOBAL {
            values(i) = [
                kind = ValueKind::UNDEF,
                tpe = val.tpe
            ] !Value

            let ret = make_local_value(tpe, null, state)
            
            let index = allocate_ref(int, 1)
            index(0) = i
            let insert = make_insn_dbg(InsnKind::INSERTVALUE, loc)
            (@insert).value.insert_value = [
                ret = ret,
                value = value,
                element = val,
                index = index
            ] !InsnInsertValue
            
            push_insn(insert, state)
            value = ret
        }
    }

    let ret = state.alloca(tpe, loc)
    value.addr = ret

    let store = make_insn_dbg(InsnKind::STORE, loc)
    (@store).value.store = [
        value = value,
        loc = ret
    ] !InsnStore
    push_insn(store, state)

    if temporary {
        create_temporary(ret, value, loc, state)
    }

    return value
}

def walk_ArrayLit(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let tpe = node.tpe

    let len = vector::length(node.value.struct_lit.args)
    let values = allocate_ref(Value, len)
    for var i in 0..len {
        let v = node.value.struct_lit.args(i)
        var element = walk_and_load_expression(v, state)
        if is_ref(element.tpe) {
            increase_ref_count_of_value(element, loc, state)
        } else if typechecking::has_copy_constructor(element.tpe) {
            let ret = state.alloca(element.tpe, loc, no_yield_capture = true)
            insert_copy_constructor(ret, element, loc, state)
            element = state.load(element.tpe, ret, loc)
        }
        values(i) = element
    }

    return push_array_lit(tpe, loc, values, state, true)
}

def walk_ArithmeticOp(node: &parser::Node, insn_kind: InsnKind, tpe: &typechecking::Type, state: &State) -> Value {
    let loc = make_location(node, state)
    let left = convert_to(node, walk_expression(node.value.bin_op.left, state), tpe, state)
    let right = convert_to(node, walk_expression(node.value.bin_op.right, state), tpe, state)

    let value = make_local_value(tpe, null, state)
    let insn = make_insn_dbg(insn_kind, loc)
    (@insn).value.arith = [
        left = left,
        right = right,
        ret = value
    ] !InsnArithmetic

    push_insn(insn, state)

    return value
}

def walk_USub(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let tpe = node.tpe
    if not tpe { return NO_VALUE }
    let expr = walk_and_load_expression(node.value.expr, state)

    let ret = make_local_value(tpe, null, state)
    if tpe.kind == typechecking::TypeKind::FLOAT {
        let fneg = make_insn_dbg(InsnKind::FNEG, loc)
        (@fneg).value.fneg = [
            ret = ret,
            value = expr
        ] !InsnFneg
        push_insn(fneg, state)
    } else {
        let sub = make_insn_dbg(InsnKind::SUB, loc)
        (@sub).value.arith = [
            ret = ret,
            left = [ kind = ValueKind::INT, i = 0, tpe = tpe ] !Value,
            right = expr
        ] !InsnArithmetic
        push_insn(sub, state)
    }
    return ret
}

def walk_UAdd(node: &parser::Node, state: &State) -> Value {
    return walk_and_load_expression(node.value.expr, state)
}

def walk_Not(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let expr = convert_to(node, walk_expression(node.value.expr, state), builtins::bool_, state)
    
    let ret = make_local_value(builtins::bool_, null, state)
    let xor = make_insn_dbg(InsnKind::XOR, loc)
    (@xor).value.arith = [
        ret = ret,
        left = expr,
        right = [ kind = ValueKind::BOOL, i = 1, tpe = builtins::bool_ ] !Value
    ] !InsnArithmetic

    push_insn(xor, state)
    return ret
}

// TODO It would be nice if and/or could work by returning the values themselves
def walk_And(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)

    node.value.bin_op.left.scope.clear_temporaries()
    let left_expr = walk_expression(node.value.bin_op.left, state)
    insert_destructors(node.value.bin_op.left.scope, loc, state)
    let left = convert_to(node, left_expr, builtins::bool_, state)

    let ret_alloca = state.alloca(builtins::bool_, loc)
    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = [
        cond = left
    ] !InsnBr

    let to_end = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(br, state)

    let if_false = make_label(state)
    push_label(if_false, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    (@store1).value.store = [
        value = [ kind = ValueKind::BOOL, i = 0, tpe = builtins::bool_ ] !Value,
        loc = ret_alloca
    ] !InsnStore

    push_insn(store1, state)
    push_insn(to_end, state)

    let if_true = make_label(state)
    push_label(if_true, state)

    node.value.bin_op.right.scope.clear_temporaries()
    let right_expr = walk_expression(node.value.bin_op.right, state)
    insert_destructors(node.value.bin_op.right.scope, loc, state)
    let right = convert_to(node, right_expr, builtins::bool_, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    (@store2).value.store = [
        value = right,
        loc = ret_alloca
    ] !InsnStore

    push_insn(store2, state)
    push_insn(to_end, state)

    let end = make_label(state)
    push_label(end, state)

    (@br).value.br.if_true = if_true
    (@br).value.br.if_false = if_false
    (@to_end).value.br_unc.label_ = end

    let ret = make_local_value(builtins::bool_, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = [
        value = ret,
        loc = ret_alloca
    ] !InsnLoad

    push_insn(load, state)

    return ret
}

def walk_Or(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)

    node.value.bin_op.left.scope.clear_temporaries()
    let left_expr = walk_expression(node.value.bin_op.left, state)
    insert_destructors(node.value.bin_op.left.scope, loc, state)
    let left = convert_to(node, left_expr, builtins::bool_, state)

    let ret_alloca = state.alloca(builtins::bool_, loc)

    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = [
        cond = left
    ] !InsnBr

    let to_end = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(br, state)

    let if_true = make_label(state)
    push_label(if_true, state)

    let store1 = make_insn_dbg(InsnKind::STORE, loc)
    (@store1).value.store = [
        value = [ kind = ValueKind::BOOL, i = 1, tpe = builtins::bool_ ] !Value,
        loc = ret_alloca
    ] !InsnStore

    push_insn(store1, state)
    push_insn(to_end, state)

    let if_false = make_label(state)
    push_label(if_false, state)

    node.value.bin_op.right.scope.clear_temporaries()
    let right_expr = walk_expression(node.value.bin_op.right, state)
    insert_destructors(node.value.bin_op.right.scope, loc, state)
    let right = convert_to(node, right_expr, builtins::bool_, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    (@store2).value.store = [
        value = right,
        loc = ret_alloca
    ] !InsnStore

    push_insn(store2, state)
    push_insn(to_end, state)

    let end = make_label(state)
    push_label(end, state)

    (@br).value.br.if_true = if_true
    (@br).value.br.if_false = if_false
    (@to_end).value.br_unc.label_ = end

    let ret = make_local_value(builtins::bool_, null, state)
    let load = make_insn_dbg(InsnKind::LOAD, loc)
    (@load).value.load = [
        value = ret,
        loc = ret_alloca
    ] !InsnLoad

    push_insn(load, state)

    return ret
}

def walk_Add(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::ADD
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FADD
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Sub(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SUB
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FSUB 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mul(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::MUL
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FMUL 
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Mod(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SREM
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FREM 
    } else if tpe.unsig {
        insn_kind = InsnKind::UREM
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Div(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    if not tpe { return NO_VALUE }

    var insn_kind = InsnKind::SDIV
    if typechecking::is_float(tpe) {
        insn_kind = InsnKind::FDIV 
    } else if tpe.unsig {
        insn_kind = InsnKind::UDIV
    }
    return walk_ArithmeticOp(node, insn_kind, tpe, state)
}

def walk_Shl(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    return walk_ArithmeticOp(node, InsnKind::SHL, tpe, state)
}

def walk_Shr(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    if tpe.unsig {
        return walk_ArithmeticOp(node, InsnKind::LSHR, tpe, state)
    } else {
        return walk_ArithmeticOp(node, InsnKind::ASHR, tpe, state)
    }
}

def walk_BAnd(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    return walk_ArithmeticOp(node, InsnKind::AND, tpe, state)
}

def walk_BOr(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    return walk_ArithmeticOp(node, InsnKind::OR, tpe, state)
}

def walk_BXor(node: &parser::Node, state: &State) -> Value {
    let tpe = node.tpe
    return walk_ArithmeticOp(node, InsnKind::XOR, tpe, state)
}

def walk_BNot(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let expr = walk_and_load_expression(node.value.expr, state)

    let ret = make_local_value(node.tpe, null, state)
    let xor = make_insn_dbg(InsnKind::XOR, loc)
    xor.value.arith = [
        ret = ret,
        left = expr,
        right = [ kind = ValueKind::INT, i = -1, tpe = node.tpe ] !Value
    ] !InsnArithmetic

    push_insn(xor, state)
    return ret
}

def insert_call(
    node: &parser::Node, name_v: Value, args: &[Value], proto: &[typechecking::NamedParameter], ret: &typechecking::Type, 
    varargs_loc: &Vector(&Value), addr: Value, loc: &Value, 
    multiple_returns: bool, state: &State) {

    for var i in 0..args.size {
        if i >= proto.size { continue }
        // Replace interfaces in proto with the actual type
        let np = proto(i)
        if np._tpe and np._tpe.kind == typechecking::TypeKind::STRUCTURAL {
            np._tpe = typechecking::make_interface_impl(np._tpe, args(i).tpe, state.scope)
            proto(i) = np
        }
    }
    
    let value = state.call(name_v, ret, args, node.value.func_call.inline, proto, loc)

    for var i in 0..vector::length(varargs_loc) {
        let ptr = @(varargs_loc(i))
        insert_destructor(ptr, loc, state)
    }

    if ret {
        let store = make_insn_dbg(InsnKind::STORE, loc)
        (@store).value.store = [
            value = value,
            loc = addr
        ] !InsnStore
        push_insn(store, state)

        if multiple_returns {
            for var i in 0..ret.fields.size {
                let field = ret.fields(i)
                let ret2 = state.gep(pointer(field.tpe), ret, addr, [make_int_value(0), make_int_value(i)])
                create_temporary(ret2, state.load(field.tpe, ret2, loc), loc, state)
            }
        } else {
            create_temporary(addr, value, loc, state)
        }
    }
}

// TODO Refactor this
def walk_Call(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let left = node.value.func_call.left
    var tpe = node.function
    if not left { return NO_VALUE }

    if left.tpe and left.tpe.kind == typechecking::TypeKind::TUPLE {
        return walk_TupleSubscript(node, state)
    }

    // Special case for arrays
    if left.tpe and (left.tpe.kind == typechecking::TypeKind::ARRAY or 
        left.tpe.kind == typechecking::TypeKind::STATIC_ARRAY or
        is_ref(left.tpe) and left.tpe.tpe and is_array(left.tpe.tpe)) {
        
        return walk_ArraySubscript(node, state)
    }

    if not tpe {
        if left.kind == parser::NodeKind::MEMBER_ACCESS and node.value.func_call.args.length == 0 {
            // "Call" a field
            return walk_MemberAccess(left, state)
        }
    }
    if not tpe { return NO_VALUE }

    var is_fp = false
    if typechecking::is_function_pointer(tpe) {
        tpe = tpe.tpe
        is_fp = true
    } else if tpe.kind == typechecking::TypeKind::CLOSURE {
        is_fp = true
    }

    // Filter out type arguments
    let parameter_t = vector::make(NamedParameter)
    let call_args = vector::make(type &parser::Node)
    let call_kwargs = vector::make(type &parser::Node)

    for var i in 0..vector::length(tpe.parameter_t) {
        let np = tpe.parameter_t(i)
        if not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE {
            parameter_t.push(np)
        } 
    }
    for var i in 0..vector::length(node.value.func_call.args) {
        let n = node.value.func_call.args(i)
        if not n { continue }
        var np: NamedParameter
        if i < vector::length(tpe.parameter_t) {
            np = tpe.parameter_t(i)
        }
        if not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE {
            call_args.push(n)
        }
    }
    
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let n = node.value.func_call.kwargs(i)
        if not n { continue }
        let name = typechecking::last_ident_to_str(n.value.named_arg.name)
        for var j in 0..vector::length(parameter_t) {
            let np = parameter_t(j)
            if np.name == name and (not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE) {
                call_kwargs.push(n)
            }
        }
    }

    var args: &[Value]
    var varargs: &[Value]

    var len = vector::length(parameter_t) !int64    // TODO We decrement this, instead figure out why and avoid it at that position
    var pass_varargs_as_array = false
    var last_np: *NamedParameter = null
    if vector::length(parameter_t) > 0 {
        last_np = parameter_t.get(parameter_t.length - 1)
        pass_varargs_as_array = last_np.varargs and last_np.tpe
    }
    var pass_array_as_varargs = false

    let last_arg = vector::peek(call_args) if vector::length(call_args) > 0 else null !&parser::Node
    if pass_varargs_as_array and last_arg and typechecking::is_array(last_arg.tpe) and
        typechecking::equals(last_arg.tpe.tpe, last_np.tpe) {
        pass_varargs_as_array = false
        pass_array_as_varargs = true
    }

    let total_defined_args = vector::length(call_args) + vector::length(call_kwargs)
    var total_args = total_defined_args
    if last_np and last_np.varargs {
        total_args = max(total_defined_args, len - 1) !int
    } else {
        total_args = max(total_defined_args, len) !int
    }
    let num_varargs = total_args - len + 1

    if pass_varargs_as_array {
        args = allocate_ref(Value, len)
        varargs = allocate_ref(Value, num_varargs)
    } else {
        args = allocate_ref(Value, total_args)
    }

    let varargs_loc = vector::make(type &Value)

    for var i in 0..vector::length(call_args) {
        let n = call_args(i)
        if not n { continue }
        if i == len - 1 and pass_array_as_varargs {
            var expr = walk_expression(n, state)
            expr = convert_to(n, expr, typechecking::array(last_np.tpe), state)
            args(i) = expr
        } else if i < len - 1 or i == len - 1 and not last_np.varargs {
            let p = parameter_t(i)
            var expr = walk_expression(n, state)
            expr = convert_to(n, expr, p.tpe, state)
            args(i) = expr
        } else if last_np and last_np.varargs {
            if last_np.tpe {
                create_type(last_np.tpe, state.module)
                var expr = walk_expression(n, state)
                expr = convert_to(n, expr, last_np.tpe, state)
                if typechecking::has_copy_constructor(expr.tpe) {
                    let ret = state.alloca(expr.tpe, loc, no_yield_capture = true)
                    insert_copy_constructor(ret, expr, loc, state)
                    expr = state.load(expr.tpe, ret, loc)
                }
                if typechecking::is_ref(last_np.tpe) and not typechecking::is_ref(n.tpe) {
                    create_type(reference(n.tpe), state.module)
                    // We need to increase the ref count and add the destructor call
                    // because the called function recieves an array
                    
                    let converted = convert_ref_to_ref(reference(n.tpe), expr, loc, state)
                    let ptr = state.alloca(reference(n.tpe), loc)
                    state.store(ptr, converted)
                    increase_ref_count(ptr, loc, state)

                    varargs_loc.push(ptr)
                }

                varargs(i - len + 1) = expr
                continue
            } else {
                args(i) = walk_and_load_expression(n, state)
            }
        } else {
            return NO_VALUE
        }
        let old = args(i)
        // TODO Factor this out into a function
        if typechecking::has_copy_constructor(old.tpe) {
            let ret = state.alloca(old.tpe, loc, no_yield_capture = true)
            insert_copy_constructor(ret, old, loc, state)
            args(i) = state.load(old.tpe, ret, loc)
        }
    }
    for var i in 0..vector::length(call_kwargs) {
        let n = call_kwargs(i)
        assert((@n).kind == parser::NodeKind::NAMED_ARG)
        // Find named parameter
        let name = typechecking::last_ident_to_str((@n).value.named_arg.name)
        let value = (@n).value.named_arg.value
        for var j in 0..vector::length(parameter_t) {
            let p = parameter_t(j)
            if p.name == name {
                var expr = walk_expression(value, state)
                expr = convert_to(n, expr, p.tpe, state)

                if typechecking::has_copy_constructor(expr.tpe) {
                    let ret = state.alloca(expr.tpe, loc, no_yield_capture = true)
                    insert_copy_constructor(ret, expr, loc, state)
                    expr = state.load(expr.tpe, ret, loc)
                }
                args(j) = expr
            }
        }
    }

    for var i in 0..args.size {
        if args(i).tpe != null { continue }
        if i >= vector::length(parameter_t) { continue }
        let arg = parameter_t(i)
        if arg.value == null { continue }

        if arg.value.kind == ValueKind::GLOBAL {
            if not map::contains(state.module.result.globals, arg.value.name) {
                let global = left.svalue.node.module.result.globals(arg.value.name)
                global.value = null
                global.external = true

                state.module.result.globals(arg.value.name) = global
                state.module.imported.add(arg.value.name)
            }

            let ret = make_local_value(arg.tpe, null, state)
            let load = make_insn_dbg(InsnKind::LOAD, loc)
            load.value.load = [
                value = ret,
                loc = @arg.value
            ] !InsnLoad
            push_insn(load, state)

            args(i) = ret
        } else {
            arg.value.tpe = arg.tpe // This is because consteval may not know about the type beforehand
            if arg.value.tpe.kind == typechecking::TypeKind::REFERENCE {
                arg.value.values(1).tpe = pointer(arg.tpe.tpe)
            }
            args(i) = @arg.value
        }
    }
    
    var array_val: Value
    if pass_varargs_as_array {
        for var i in 0..varargs.size {
            if varargs(i).tpe.kind == typechecking::TypeKind::REFERENCE {
                increase_ref_count_of_value(varargs(i), loc, state)
            }
        }
        let sarray_t = typechecking::make_static_array(last_np.tpe, num_varargs)
        array_val = push_array_lit(sarray_t, null, varargs, state)
        args(args.size - 1) = convert_to(node, array_val, typechecking::array(last_np.tpe), state)
    }

    var proto: &[typechecking::NamedParameter]
    var name_v: Value
    var ret: &typechecking::Type = null
    var multiple_returns = false
    if is_fp {
        if vector::length(tpe.return_t) > 1 {
            ret = make_return_type(tpe)
        } else if vector::length(tpe.return_t) == 1 {
            ret = vector::peek(tpe.return_t)
        }
        name_v = walk_and_load_expression(node.value.func_call.left, state)
        proto = allocate_ref(typechecking::NamedParameter, vector::length(parameter_t))
        for var i in 0..vector::length(parameter_t) {
            proto(i) = parameter_t(i)
        }
    } else {    
        var name = tpe.type_name
        let function = predeclare_function(tpe, state.module)
        if not function { return NO_VALUE }
        ret = function.ret
        multiple_returns = function.multiple_returns
        
        import_structures(tpe, state.module)
        state.module.imported.add(name)

        /*let svalue = node.value.func_call.left.svalue
        if svalue and svalue.state {
            svalue.state.module.imported.add(name)
        }*/

        let len = vector::length(parameter_t)
        proto = allocate_ref(typechecking::NamedParameter, len)
        for var i in 0..len {
            proto(i) = parameter_t(i)
        }

        name_v = [
            kind = ValueKind::GLOBAL,
            name = name
        ] !Value
    }

    var addr = NO_VALUE
    if ret {
        addr = make_named_local(ret, null, state)
        
        let alloca = make_insn(InsnKind::ALLOCA)
        (@alloca).value.alloca = [
            ret = addr
        ] !InsnAlloca
        push_alloca(alloca, state)
        
        addr.tpe = typechecking::pointer(ret)
    }

    var stored_fun: &typechecking::Type
    if tpe.kind == typechecking::TypeKind::CLOSURE {
        let call_v = state.extract_value(tpe.fields(0).tpe, name_v, [0], loc)
        let state_ref = state.extract_value(tpe.fields(1).tpe, name_v, [1], loc)

        stored_fun = tpe.fields(0).tpe._tpe

        let function_tpe = typechecking::make_function_type()
        function_tpe.return_t = stored_fun.return_t.copy()
        function_tpe.parameter_t = stored_fun.parameter_t.copy()
        function_tpe.parameter_t.remove(0)
        name_v = state.bitcast(pointer(function_tpe), call_v, loc)

        let state_ptr = state.extract_value(pointer(null), state_ref, [1], loc)
        let state_value = state.ptr_to_int(state_ptr, loc)
        let cond = state.icmp(CompareInt::eq, state_value, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value)

        let br = make_insn_dbg(InsnKind::BR, loc)
        br.value.br = [ cond = cond ] !InsnBr
        push_insn(br, state)
        let exit = make_insn_dbg(InsnKind::BR_UNC, loc)

        let if_true = make_label(state)
        push_label(if_true, state)

        insert_call(node, name_v, args, proto, ret, varargs_loc, addr, loc, multiple_returns, state)

        push_insn(exit, state)

        let if_false = make_label(state)
        push_label(if_false, state)

        let args2 = allocate_ref(Value, args.size + 1)
        for var i in 0..args.size {
            args2(i + 1) = args(i)
        }
        args2(0) = state_ref

        let proto2 = allocate_ref(typechecking::NamedParameter, proto.size + 1)
        for var i in 0..proto.size {
            proto2(i + 1) = proto(i)
        }
        proto2(0) = [ name = "__data", _tpe = typechecking::reference(null) ] !typechecking::NamedParameter

        insert_call(node, call_v, args2, proto2, ret, varargs_loc, addr, loc, multiple_returns, state)

        push_insn(exit, state)

        let end = make_label(state)
        push_label(end, state)

        exit.value.br_unc.label_ = end
        br.value.br.if_true = if_true
        br.value.br.if_false = if_false

    } else {
        // TODO This should be a closure by all means
        insert_call(node, name_v, args, proto, ret, varargs_loc, addr, loc, multiple_returns, state)
    }

    if pass_varargs_as_array {
        insert_destructor(@array_val.addr, loc, state)
    }

    var value = NO_VALUE
    if ret {
        value = state.load(ret, addr, loc)
        value.addr = addr
    }
    return value
}

def walk_Identifier(node: &parser::Node, state: &State) -> Value {
    var val = node.svalue
    if not val { return NO_VALUE }

    if val.tpe and val.tpe.kind == typechecking::TypeKind::TYPE {
        val = change_value_to_type(node.tpe.tpe.tpe, state)
    }
    if not val { return NO_VALUE }

    let tpe = node.tpe
    if tpe and tpe.kind == typechecking::TypeKind::CLOSURE {
        add_type_meta(tpe, state)
    }

    import_structures(tpe, state.module)
    if (@val).global {
        (@(@state).module).imported.add((@val).assembly_name(state))
    }

    if (@val).value {
        return @val.value
    }

    let name = (@val).assembly_name(state)
    var kind = ValueKind::LOCAL
    if (@val).global {
        kind = ValueKind::GLOBAL
    }

    let locv = [
        kind = kind,
        name = name,
        tpe = typechecking::pointer(tpe)
    ] !&Value

    if not typechecking::is_function(tpe) {
        let value = make_address_value(tpe, locv, state)
        return value
    } else {
        locv.name = tpe.type_name
        let value = [ 
            kind = ValueKind::LOCAL, 
            name = name, 
            tpe = tpe, 
            addr = locv
        ] !Value
        return value
    }
}

// This function assumes that value.tpe has a copy constructor
def insert_copy_constructor(addr: Value, value: Value, loc: &Value, state: &State, no_yield_capture: bool = true) -> Value {
    if not value.tpe { return NO_VALUE }
    state.store(addr, [ kind = ValueKind::ZEROINITIALIZER, tpe = addr.tpe.tpe ] !Value, loc) 

    if value.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
        let array_loc = state.alloca(value.tpe, loc, no_yield_capture = no_yield_capture)
        state.store(array_loc, value)

        let counter_ptr = state.alloca(builtins::size_t_, loc, no_yield_capture = no_yield_capture)
        state.store(counter_ptr, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 0 ] !Value, loc)
        
        let br_to_start = make_insn_dbg(InsnKind::BR_UNC, loc)
        push_insn(br_to_start, state)

        let loop_start = make_label(state)
        push_label(loop_start, state)
        br_to_start.value.br_unc.label_ = loop_start
        
        let counter_value = state.load(builtins::size_t_, counter_ptr, loc)
        let cond = state.icmp(CompareInt::eq, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = value.tpe.length ] !Value, loc)
        let br = make_insn_dbg(InsnKind::BR, loc)
        br.value.br = [ cond = cond ] !InsnBr
        push_insn(br, state)

        let loop_inner = make_label(state)
        push_label(loop_inner, state)
        br.value.br.if_false = loop_inner

        let array_ptr = state.gep(pointer(value.tpe.tpe), value.tpe, addr, [make_int_value(0), counter_value])
        if typechecking::is_ref(value.tpe.tpe) {
            increase_ref_count(array_ptr, loc, state)
        } else {
            let value_ptr = state.gep(pointer(value.tpe.tpe), value.tpe, array_loc, [make_int_value(0), counter_value])
            value = state.load(value.tpe.tpe, value_ptr)
            insert_copy_constructor(array_ptr, value, loc, state, no_yield_capture)
        }

        let counter_inc = state.add(builtins::size_t_, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value, loc)
        state.store(counter_ptr, counter_inc)

        push_insn(br_to_start, state)

        let loop_end = make_label(state)
        push_label(loop_end, state)
        br.value.br.if_true = loop_end

        return NO_VALUE
    } else {
        var ctor = typechecking::get_constructor(addr.tpe.tpe)
        if not ctor { return NO_VALUE }
        if consteval::is_static {
            consteval::compile_function(ctor, state.scope)
        }
        predeclare_function(ctor.tpe, state.module)
        state.module.imported.add(ctor.tpe.type_name)

        // allocate set value
        let ret = state.alloca(value.tpe, loc, no_yield_capture = no_yield_capture)
        state.store(ret, value, loc)
        state.call(ctor.tpe.type_name, null, [addr, ret], loc)

        return ret
    }
}

def insert_destructors(scpe: &scope::Scope, loc: &Value, state: &State) {
    let keys = map::reverse_keys(scpe.fields)
    for var i in 0..keys.size {
        let key = keys(i)
        let value = scpe.fields(key)

        let name = value.assembly_name(state)
        var kind = ValueKind::LOCAL
        if value.global {
            kind = ValueKind::GLOBAL
        }
        if state.current_function and not map::contains(state.current_function.function_locals, name) { continue }
        insert_destructor([ kind = kind, tpe = pointer(value.tpe), name = name ] !Value, loc, state)
    }
    if scpe.is_function and scpe.underscore {
        insert_destructor([ 
            kind = ValueKind::LOCAL, 
            tpe = pointer(scpe.underscore.tpe), 
            name = scpe.underscore.assembly_name(state) 
        ] !Value, loc, state)
    }
}

def insert_destructor(value: Value, loc: &Value, state: &State) {
    if value.tpe.tpe and value.tpe.tpe.kind == typechecking::TypeKind::STATIC_ARRAY and typechecking::has_destructor(value.tpe.tpe) {
        let counter_ptr = state.alloca(builtins::size_t_, loc)
        state.store(counter_ptr, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 0 ] !Value, loc)
        
        let br_to_start = make_insn_dbg(InsnKind::BR_UNC, loc)
        push_insn(br_to_start, state)

        let loop_start = make_label(state)
        push_label(loop_start, state)
        br_to_start.value.br_unc.label_ = loop_start
        
        let counter_value = state.load(builtins::size_t_, counter_ptr, loc)
        let cond = state.icmp(CompareInt::eq, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = value.tpe.tpe.length ] !Value, loc)
        let br = make_insn_dbg(InsnKind::BR, loc)
        br.value.br = [ cond = cond ] !InsnBr
        push_insn(br, state)

        let loop_inner = make_label(state)
        push_label(loop_inner, state)
        br.value.br.if_false = loop_inner

        let element = state.gep(pointer(value.tpe.tpe.tpe), value.tpe.tpe, value, [make_int_value(0), counter_value])
        insert_destructor(element, loc, state)

        let counter_inc = state.add(builtins::size_t_, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value, loc)
        state.store(counter_ptr, counter_inc)

        push_insn(br_to_start, state)

        let loop_end = make_label(state)
        push_label(loop_end, state)
        br.value.br.if_true = loop_end
        
    } else if typechecking::has_destructor(value.tpe.tpe) {
        import_structures(value.tpe.tpe, state.module)

        var destructor = typechecking::get_builtin_destructor(value.tpe.tpe)
        if not destructor { return }
        predeclare_function(destructor.tpe, state.module)

        if consteval::is_static {
            let udtor = get_user_defined_destructor(value.tpe.tpe)
            if udtor {
                consteval::compile_function(udtor, state.scope)
            }
        }

        state.module.imported.add(destructor.tpe.type_name)
        state.call(destructor.tpe.type_name, null, [value], loc)

        // If we insert a destructor the variable doesn't need to be freed anymoree
        if value.name and state.current_function.has_yield {
            state.current_function.current_snapshot.peek().remove(value.name)
        }
    }
}

def increase_pointer_by_one(value: Value, loc: &Value, state: &State) {
    let ptr_addr = state.ptr_to_int(value, loc)
    let cond = state.icmp(CompareInt::eq, ptr_addr, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value)
    
    let br = make_insn_dbg(InsnKind::BR, loc)
    br.value.br = [ cond = cond ] !InsnBr
    push_insn(br, state)

    let if_false = make_label(state)
    push_label(if_false, state)
    br.value.br.if_false = if_false

    let ptr_value = state.load(builtins::int64_, value, loc)
    let ptr_add = state.add(builtins::int64_, ptr_value, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 1 ] !Value, loc)
    state.store(value, ptr_add, loc)

    let if_true = make_label(state)
    let br_unc = make_insn_dbg(InsnKind::BR_UNC, loc)
    br_unc.value.br_unc.label_ = if_true
    push_insn(br_unc, state)

    push_label(if_true, state)
    br.value.br.if_true = if_true
}

def increase_ref_count_of_value(value: Value, loc: &Value, state: &State) {
    let index = allocate_ref(int, 1)
    index(0) = 0

    let extract_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let extract = make_insn_dbg(InsnKind::EXTRACTVALUE, loc)
    extract.value.extract_value = [
        ret = extract_ret,
        value = value,
        index = index
    ] !InsnExtractValue
    push_insn(extract, state)

    increase_pointer_by_one(extract_ret, loc, state)
}
 
def increase_ref_count(value: Value, loc: &Value, state: &State) {
    let index1 = allocate_ref(Value, 2)
    index1(0) = make_int_value(0)
    index1(1) = make_int_value(0)
    
    let gep1_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep1.value.gep = [
        ret = gep1_ret,
        tpe = value.tpe.tpe,
        value = value,
        index = index1
    ] !InsnGetElementPtr
    push_insn(gep1, state)

    let load1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let load1 = make_insn_dbg(InsnKind::LOAD, loc)
    load1.value.load = [
        value = load1_ret,
        loc = gep1_ret
    ] !InsnLoad
    push_insn(load1, state)

    increase_pointer_by_one(load1_ret, loc, state)
}

// Leaving this in because it might be useful
def copy_reference(value: Value, loc: &Value, state: &State) -> Value {
    assert is_ref(value.tpe)
    import_cstd_function("memcpy", state)
    import_cstd_function("malloc", state)

    let size = [ kind = ValueKind::INT, tpe = builtins::int64_, i = value.tpe.tpe.size ] !Value
    let size_int64 = [ kind = ValueKind::INT, tpe = builtins::int64_, i = builtins::int64_.size ] !Value

    let ref_count_ptr_i8 = state.call("malloc", pointer(builtins::int8_), [size_int64], loc)
    let ref_count_ptr = state.bitcast(pointer(builtins::int64_), ref_count_ptr_i8)
    state.store(ref_count_ptr, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value)
    let value_ptr = state.extract_value(pointer(value.tpe.tpe), value, [1], loc)
    let type_ptr = state.extract_value(pointer(builtins::Type_), value, [2], loc)
    
    let value_ptr_i8 = state.bitcast(pointer(builtins::int8_), value_ptr, loc)
    let copy_ptr_i8 = state.call("malloc", pointer(builtins::int8_), [size], loc)
    state.call("memcpy", pointer(builtins::int8_), [copy_ptr_i8, value_ptr_i8, size], loc)
    let copy_ptr = state.bitcast(pointer(value.tpe.tpe), copy_ptr_i8, loc)

    var ret = [ kind = ValueKind::UNDEF, tpe = value.tpe ] !Value
    ret = state.insert_value(value.tpe, ret, ref_count_ptr, [0], loc)
    ret = state.insert_value(value.tpe, ret, copy_ptr, [1], loc)
    ret = state.insert_value(value.tpe, ret, type_ptr, [2], loc)

    return ret
}

def assign_ref(value: Value, addr: Value, loc: &Value, is_initializer: bool, state: &State) {
    if not value.addr { return }

    // First increase the ref count of the assigned value
    increase_ref_count(@value.addr, loc, state)

    // Now decrease the ref count of the stored value
    if not is_initializer {
        insert_destructor(addr, loc, state)
    }

    // Set the values for the new reference
    let index1 = allocate_ref(Value, 2)
    index1(0) = make_int_value(0)
    index1(1) = make_int_value(0)

    let gep1_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep1.value.gep = [
        ret = gep1_ret,
        tpe = value.tpe,
        value = value,
        index = index1
    ] !InsnGetElementPtr
    push_insn(gep1, state)

    let load1_ret = make_local_value(typechecking::pointer(builtins::int64_), null, state)
    let load1 = make_insn_dbg(InsnKind::LOAD, loc)
    load1.value.load = [
        value = load1_ret,
        loc = gep1_ret
    ] !InsnLoad
    push_insn(load1, state)
    
    let gep2_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::int64_)), null, state)
    let gep2 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep2.value.gep = [
        ret = gep2_ret,
        tpe = addr.tpe.tpe,
        value = addr,
        index = index1
    ] !InsnGetElementPtr
    push_insn(gep2, state)

    let index3 = allocate_ref(Value, 2)
    index3(0) = make_int_value(0)
    index3(1) = make_int_value(1)

    let gep3_ret = make_local_value(typechecking::pointer(typechecking::pointer(addr.tpe.tpe.tpe)), null, state)
    let gep3 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep3.value.gep = [
        ret = gep3_ret,
        tpe = addr.tpe.tpe,
        value = addr,
        index = index3
    ] !InsnGetElementPtr
    push_insn(gep3, state)

    let index4 = allocate_ref(Value, 2)
    index4(0) = make_int_value(0)
    index4(1) = make_int_value(2)

    let gep4_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::Type_)), null, state)
    let gep4 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep4.value.gep = [
        ret = gep4_ret,
        tpe = addr.tpe.tpe,
        value = addr,
        index = index4
    ] !InsnGetElementPtr
    push_insn(gep4, state)

    let gep5_ret = make_local_value(typechecking::pointer(typechecking::pointer(value.tpe.tpe)), null, state)
    let gep5 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep5.value.gep = [
        ret = gep5_ret,
        tpe = value.tpe,
        value = @value.addr,
        index = index3
    ] !InsnGetElementPtr
    push_insn(gep5, state)

    let gep6_ret = make_local_value(typechecking::pointer(typechecking::pointer(builtins::Type_)), null, state)
    let gep6 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    gep6.value.gep = [
        ret = gep6_ret,
        tpe = value.tpe,
        value = @value.addr,
        index = index4
    ] !InsnGetElementPtr
    push_insn(gep6, state)

    let load3_ret = make_local_value(typechecking::pointer(value.tpe.tpe), null, state)
    let load3 = make_insn_dbg(InsnKind::LOAD, loc)
    load3.value.load = [
        value = load3_ret,
        loc = gep5_ret
    ] !InsnLoad
    push_insn(load3, state)

    let bitcast_ret = make_local_value(typechecking::pointer(addr.tpe.tpe.tpe), null, state)
    let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
    bitcast.value.convert = [
        ret = bitcast_ret,
        value = load3_ret
    ] !InsnConvert
    push_insn(bitcast, state)

    let load4_ret = make_local_value(typechecking::pointer(builtins::Type_), null, state)
    let load4 = make_insn_dbg(InsnKind::LOAD, loc)
    load4.value.load = [
        value = load4_ret,
        loc = gep6_ret
    ] !InsnLoad
    push_insn(load4, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    store2.value.store = [
        loc = gep2_ret,
        value = load1_ret
    ] !InsnStore
    push_insn(store2, state)

    let store3 = make_insn_dbg(InsnKind::STORE, loc)
    store3.value.store = [
        loc = gep3_ret,
        value = bitcast_ret
    ] !InsnStore
    push_insn(store3, state)

    let store4 = make_insn_dbg(InsnKind::STORE, loc)
    store4.value.store = [
        loc = gep4_ret,
        value = load4_ret
    ] !InsnStore
    push_insn(store4, state)
}

def call_set_attribute(n: &parser::Node, l: &parser::Node, value_type: &typechecking::Type, value: Value, loc: &Value, state: &State) -> bool {
    if not l or l.kind != parser::NodeKind::MEMBER_ACCESS { return false }

    let args = vector::make(typechecking::NamedParameter)
    args.push([ _tpe = l.value.bin_op.left.tpe ] !typechecking::NamedParameter)
    args.push([ _tpe = value_type ] !typechecking::NamedParameter)

    let name = l.value.bin_op.right
    if not name or name.kind != parser::NodeKind::IDENTIFIER { return false }

    let set_attrib = scope::get_function(state.scope, parser::make_identifier("__set_" + parser::identifier_to_str(name) + "__"), args)
    if set_attrib {
        let left = (set_attrib.tpe.parameter_t(0)).tpe
        let right = (set_attrib.tpe.parameter_t(1)).tpe

        var obj = walk_and_load_expression(l.value.bin_op.left, state)
        obj = convert_to(n, obj, left, state)
        if typechecking::has_copy_constructor(obj.tpe) {
            let ret = state.alloca(obj.tpe, loc, no_yield_capture = true)
            insert_copy_constructor(ret, obj, loc, state)
            obj = state.load(obj.tpe, ret, loc)
        }

        value = convert_to(n, value, right, state)
        if typechecking::has_copy_constructor(value.tpe) {
            let ret = state.alloca(value.tpe, loc, no_yield_capture = true)
            insert_copy_constructor(ret, value, loc, state)
            value = state.load(value.tpe, ret, loc)
        }

        predeclare_function(set_attrib.tpe, state.module)
        state.module.imported.add(set_attrib.tpe.type_name)
        state.call(set_attrib.tpe.type_name, null, [obj, value], loc)
        
        return true
    }
    return false
}

def create_temporary(addr: Value, ret: Value, loc: &Value, state: &State) {
    var name = addr.name
    let is_global = scope::is_global(state.scope)
    if is_global {
        name = state.module.module + ".__tmp." + state.global_counter
        state.global_counter += 1
    }

    let ident = parser::make_identifier(name)
    if not scope::get(state.scope, ident) {
        let v = scope::create_variable(
            state.scope, 
            ident,
            parser::ShareMarker::NONE,
            parser::VarDecl::LET,
            ret.tpe, true, null // extern so that we don't change the variable name
        )
        v.is_internal = true
        v.identifier = ident // TODO Strong reference
    }

    if is_global {
        let global = [
            name = name,
            tpe = ret.tpe,
            private = true
        ] !&Global
        
        state.module.result.globals((@global).name) = global
        state.module.imported.add(global.name)
        
        state.store([ kind = ValueKind::GLOBAL, tpe = pointer(ret.tpe), name = name ] !Value, ret, loc)
    } else {
        state.current_function.function_locals.add(name)
    }
}

def assign_post(n: &parser::Node, l: &parser::Node, value_type: &typechecking::Type, ret: &Value, loc: &Value, state: &State) -> bool {
    // Just look at this madness
    if not n or not l or not n.tpe or 
        not ret or not ret.tpe { 
        return false 
    }

    if not call_set_attribute(n, l, value_type, @ret, loc, state) {
        
        /*if l.kind == parser::NodeKind::FUNC_CALL {
            errors::errorn(l, "Can't assign to function return value")
            return false
        }*/
        let addr = walk_expression(l, state).addr
        if not addr {
            errors::errorn(l, "Can't assign, expression has no address")
            return false
        }

        if not l.tpe { return false }
        /*if (l.tpe.kind == typechecking::TypeKind::ARRAY or 
            (l.tpe.kind == typechecking::TypeKind::REFERENCE and 
            l.tpe.tpe and l.tpe.tpe.kind == typechecking::TypeKind::ARRAY)) and 
            ret.tpe.kind == typechecking::TypeKind::STATIC_ARRAY and
            n.kind == parser::NodeKind::ARRAY_LIT {

            // We need to store the array so we can destruct it
            create_temporary(@ret.addr, @ret, loc, state)
        }*/
        
        @ret = convert_to(n, @ret, (@l).tpe, state)

        if has_copy_constructor(ret.tpe) {
            let tmp = state.alloca(ret.tpe, loc, no_yield_capture = true)
            insert_copy_constructor(tmp, @ret, loc, state)
            @ret = state.load(ret.tpe, tmp, loc)
        }

        if typechecking::is_ref(l.tpe) and ret.addr and typechecking::is_ref(ret.addr.tpe) {
            assign_ref(@ret.addr, @addr, loc, l.is_initializer, state)
        } else {
            if not l.is_initializer {
                insert_destructor(@addr, loc, state)
            } else if l.svalue and l.svalue.previous_underscore {
                let pu = l.svalue.previous_underscore
                let addr = [ kind = ValueKind::LOCAL, name = pu.assembly_name(state), tpe = pointer(pu.tpe) ] !Value
                insert_destructor(addr, loc, state)
            }
            
            let store = make_insn_dbg(InsnKind::STORE, loc)
            (@store).value.store = [
                value = @ret,
                loc = @addr
            ] !InsnStore

            push_insn(store, state)

            if typechecking::is_ref(l.tpe) {
                increase_ref_count(@addr, loc, state)
            }
        }
    }
    return true
}

export def walk_Assign(node: &parser::Node, state: &State) -> Value {
    if not node { return NO_VALUE }
    
    // TODO Make this possible: a, b = c, d = e, f
    // Right now we can only return one value

    let loc = make_location(node, state)
    let right = node.value.assign.right
    let left = node.value.assign.left
    var last_value: &Value = NO_VALUE

    var j = 0
    for var i in 0..vector::length(right) {
        let n = right(i)
        if not n { break }

        var is_undef = false
        var value: &Value = NO_VALUE
        if n.kind == parser::NodeKind::UNDEF { 
            is_undef = true
        } else {
            if j >= vector::length(left) { return NO_VALUE }
            let l = left(j)

            let current_variable = state.current_variable
            if node.parent.kind == parser::NodeKind::PROGRAM {
                state.current_variable = l.svalue
            }

            value = walk_and_load_expression(n, state)
            state.current_variable = current_variable
        }
        let tpe = (@n).tpe
        if not tpe { continue }
        if tpe.kind == typechecking::TypeKind::TUPLE and vector::length(left) > 1 {
            for var k in 0..vector::length(tpe.return_t) {
                let t = tpe.return_t(k)
                if j >= vector::length(left) { return NO_VALUE }
                let l = left(j)
                
                if l.svalue and l.svalue.name == "_" {
                    let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
                    alloca.value.alloca = [
                        ret = [ kind = ValueKind::LOCAL, name = l.svalue.assembly_name(state), tpe = l.svalue.tpe ] !Value
                    ] !InsnAlloca
                    push_alloca(alloca, state)
                }

                let gep_ret = make_local_value(typechecking::pointer(t), null, state)

                let index = allocate_ref(Value, 2)
                index(0) = make_int_value(0)
                index(1) = make_int_value(k)

                let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
                (@gep).value.gep = [
                    ret = gep_ret,
                    tpe = value.tpe,
                    value = @value.addr,
                    index = index
                ] !InsnGetElementPtr

                push_insn(gep, state)
                
                let ret = make_local_value(t, gep_ret, state)

                let load = make_insn_dbg(InsnKind::LOAD, loc)
                (@load).value.load = [
                    value = ret,
                    loc = gep_ret
                ] !InsnLoad

                push_insn(load, state)

                if not assign_post(n, l, t, ret, loc, state) { return NO_VALUE }
                
                last_value = ret
                j += 1
            }
        } else {
            if j >= vector::length(left) { return NO_VALUE }
            let l = left(j)

            if not l.is_initializer and is_undef {
                errors::errorn(n, "Undef used outside of initializer")
            }

            if l.svalue and l.svalue.name == "_" {
                let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
                alloca.value.alloca = [
                    ret = [ kind = ValueKind::LOCAL, name = l.svalue.assembly_name(state), tpe = l.svalue.tpe ] !Value
                ] !InsnAlloca
                push_alloca(alloca, state)
            }

            if not assign_post(n, l, tpe, value, loc, state) { return NO_VALUE }
            
            last_value = value
            j += 1
        }
    }
    return @last_value
}

def walk_AssignEq(node: &parser::Node, state: &State) -> Value {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right

    var kind: parser::NodeKind
    switch node.kind !int {
        case parser::NodeKind::PADD_EQ; kind = parser::NodeKind::PADD
        case parser::NodeKind::PSUB_EQ; kind = parser::NodeKind::PSUB
        case parser::NodeKind::ADD_EQ;  kind = parser::NodeKind::ADD
        case parser::NodeKind::SUB_EQ;  kind = parser::NodeKind::SUB
        case parser::NodeKind::MUL_EQ;  kind = parser::NodeKind::MUL
        case parser::NodeKind::DIV_EQ;  kind = parser::NodeKind::DIV
        case parser::NodeKind::MOD_EQ;  kind = parser::NodeKind::MOD
        case parser::NodeKind::AND_EQ;  kind = parser::NodeKind::BAND
        case parser::NodeKind::OR_EQ;   kind = parser::NodeKind::BOR
        case parser::NodeKind::XOR_EQ;  kind = parser::NodeKind::BXOR
        case parser::NodeKind::SHL_EQ;  kind = parser::NodeKind::SHL
        case parser::NodeKind::SHR_EQ;  kind = parser::NodeKind::SHR
        case; assert(false)
    }

    let arithmetic = [
        kind = kind,
        loc = node.loc,
        scope = node.scope,
        tpe = node.tpe
    ] !&parser::Node
    
    arithmetic.value.bin_op = [
        left = left,
        right = right
    ] !parser::NodeBinaryOp

    let left_vec = vector::make(type &parser::Node)
    left_vec.push(left)
    let right_vec = vector::make(type &parser::Node)
    right_vec.push(arithmetic)

    let assign_eq_node = [
        kind = parser::NodeKind::ASSIGN,
        loc = node.loc,
        scope = node.scope,
        parent = node.parent
    ] !&parser::Node
    
    assign_eq_node.value.assign = [
        left = left_vec,
        right = right_vec
    ] !parser::NodeAssign

    return walk_and_load_expression(assign_eq_node, state)
}

def walk_Deref(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    var value = walk_and_load_expression(node.value.expr, state)
    let tpe = value.tpe
    if not tpe { return NO_VALUE }

    if typechecking::is_ref_or_weak(tpe) {
        let index = allocate_ref(int, 1)
        index(0) = 1
        let extract_ret = make_local_value(typechecking::pointer(tpe.tpe), null, state)
        let extract = make_insn_dbg(InsnKind::EXTRACTVALUE, make_location(node, state))
        extract.value.extract_value = [
            ret = extract_ret,
            value = value,
            index = index
        ] !InsnExtractValue
        push_insn(extract, state)

        value = extract_ret
    }

    let ret = make_address_value(tpe.tpe, value, state)
    return ret
}

def walk_Ptr(node: &parser::Node, state: &State) -> Value {
    let value = walk_expression(node.value.expr, state)
    if not value.addr { return NO_VALUE }
    if value.tpe.kind == typechecking::TypeKind::CLOSURE {
        return value
    }

    return @(value.addr)
}

def walk_MemberAccess_gep(node: &parser::Node, tpe: &typechecking::Type, 
    mtpe: &typechecking::Type, value: Value, index: &[Value], state: &State) -> Value {

    let loc = make_location(node, state)
    let gep_ret = make_local_value(typechecking::pointer(mtpe), null, state) 
    let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
    (@gep).value.gep = [
        ret = gep_ret,
        tpe = tpe,
        value = @value.addr,
        index = index
    ] !InsnGetElementPtr
    push_insn(gep, state)

    let ret = make_address_value(mtpe, gep_ret, state)
    return ret
}

type Member = struct {
    index: int
    tpe: &typechecking::Type
}

// This list needs to be reversed to find the actual indices
def resolve_member(vec: &Vector(Member), tpe: &typechecking::Type, name: Str) -> bool {
    let fields = tpe.fields
    if not fields { return false }
    for var i in 0..fields.size {
        let field = fields(i)
        if field.name {
            if field.name == name {
                let member = [
                    index = field.index !int,
                    tpe = field.tpe
                ] !Member
                vec.push(member)
                return true
            }
        } else {
            let found = resolve_member(vec, field.tpe, name)
            if found {
                let member = [
                    index = field.index !int,
                    tpe = field.tpe
                ] !Member
                vec.push(member)
                return true
            }
        }
    }
    return false
}

def walk_MemberAccess_struct(node: &parser::Node, tpe: &typechecking::Type, member: &Member, value: Value, state: &State) -> Value {
    let loc = make_location(node, state)

    var member_type = member.tpe
    if member.tpe.kind == typechecking::TypeKind::BOX {
        member_type = member.tpe.weak
    }
    
    if tpe.kind == typechecking::TypeKind::UNION {

        let index = allocate_ref(Value, 2)
        index(0) = make_int_value(0)
        index(1) = make_int_value(0)

        let gep_ret = make_local_value(typechecking::pointer([ kind = typechecking::TypeKind::WORD, size = tpe.align ] !&typechecking::Type), null, state)
        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = [
            ret = gep_ret,
            tpe = tpe,
            value = @value.addr,
            index = index
        ] !InsnGetElementPtr
        push_insn(gep, state)

        let bitcast_ret = make_local_value(typechecking::pointer(member_type), null, state)
        let bitcast = make_insn_dbg(InsnKind::BITCAST, loc)
        (@bitcast).value.convert = [
            ret = bitcast_ret,
            value = gep_ret
        ] !InsnConvert
        push_insn(bitcast, state)

        let ret = make_address_value(member_type, bitcast_ret, state)
        return ret
    } else {
        let index = allocate_ref(Value, 2)
        index(0) = make_int_value(0)
        index(1) = make_int_value((@member).index)
        return walk_MemberAccess_gep(node, tpe, member_type, value, index, state)
    }
}

def walk_MemberAccess(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    if not node.tpe { return NO_VALUE }

    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    var tpe = (@left).tpe
    if not tpe { return NO_VALUE }

    var value = walk_expression(left, state)
    if not value.addr {
        if typechecking::equals(value.tpe, typechecking::pointer(builtins::Type_)) {
            // TODO This should be handled in typechecking
            value.addr = value
        } else {
            errors::errorn(node, "Can't use member access, expression has no address")
            return NO_VALUE
        }
    }

    // TODO This might double error
    let name = typechecking::last_ident_to_str(right)

    if name == "type" {
        var res = NO_VALUE
        if typechecking::is_ref_or_weak(tpe) {
            value = load_value(value, loc, state)
            res = state.extract_value(pointer(builtins::Type_), value, [2], loc)
        } else if tpe.kind == typechecking::TypeKind::TUNION {
            value = load_value(value, loc, state)
            res = state.extract_value(pointer(builtins::Type_), value, [0], loc)
        }

        return res
    }

    if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
        if name == "size" {
            let i = make_int_value(tpe.length !int)
            i.tpe = builtins::size_t_
            return i
        } else if name == "value" {
            let index = allocate_ref(Value, 2)
            index(0) = make_int_value(0)
            index(0).tpe = builtins::size_t_
            index(1) = make_int_value(0)
            index(1).tpe = builtins::size_t_

            let gep_ret = make_local_value(node.tpe, null, state)
            let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
            (@gep).value.gep = [
                ret = gep_ret,
                tpe = tpe,
                value = @value.addr,
                index = index
            ] !InsnGetElementPtr

            push_insn(gep, state)
            return gep_ret
        } else { assert(false) }
    } else if tpe.kind == typechecking::TypeKind::ARRAY {
        let index = allocate_ref(Value, 2)
        index(0) = make_int_value(0)

        if name == "size" {
            index(1) = make_int_value(0)
        } else if name == "value" {
            index(1) = make_int_value(1)
        } else {
            assert(false)
        }

        return walk_MemberAccess_gep(node, tpe, node.tpe, value, index, state)
    } else {
        let vec = vector::make(Member)
        if not resolve_member(vec, tpe, name) {
            return NO_VALUE
        }
        let len = vector::length(vec)
        for var i in 0..len {
            let j = len - i - 1
            let member = vec(j)
            value = walk_MemberAccess_struct(node, tpe, member, value, state)
            tpe = member.tpe
        }
        return value
    }
}

def walk_TupleSubscript(node: &parser::Node, state: &State) -> Value {
    if not node.tpe { return NO_VALUE }
    let loc = make_location(node, state)

    let left = node.value.func_call.left
    let right = node.value.func_call.args(0)

    let tuple = walk_and_load_expression(left, state)
    let index = right.value.i

    return state.extract_value(node.tpe, tuple, [index !int], loc)
}

// TODO Lots of duplicate code
def walk_ArraySubscript(node: &parser::Node, state: &State) -> Value {
    if not node.tpe { return NO_VALUE }
    let loc = make_location(node, state)

    let left = node.value.func_call.left
    
    if node.value.func_call.args.length != 1 { return NO_VALUE }
    let right = node.value.func_call.args(0)
    
    var array_tpe = (@left).tpe
    var left_value = walk_expression(left, state)
    let right_value = walk_and_load_expression(right, state)

    if is_ref(array_tpe) {
        let array_ref = state.load(array_tpe, @left_value.addr, loc)
        let array = state.extract_value(pointer(array_tpe.tpe), array_ref, [1], loc)
        let array_val = state.load(array_tpe.tpe, array, loc)

        array_val.addr = array
        left_value = array_val
        array_tpe = array_tpe.tpe
    }

    if (@array_tpe).kind == typechecking::TypeKind::ARRAY {
        let index1 = allocate_ref(Value, 2)
        index1(0) = make_int_value(0)
        index1(1) = make_int_value(1)

        let gep_ret1 = make_local_value(typechecking::pointer(typechecking::pointer(node.tpe)), null, state)
        
        let gep1 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep1).value.gep = [
            ret = gep_ret1,
            tpe = array_tpe,
            value = @left_value.addr,
            index = index1
        ] !InsnGetElementPtr

        let load1_value = make_local_value(typechecking::pointer(node.tpe), null, state)

        let load1 = make_insn_dbg(InsnKind::LOAD, loc)
        (@load1).value.load = [
            value = load1_value,
            loc = gep_ret1
        ] !InsnLoad

        let index2 = allocate_ref(Value, 1)
        index2(0) = right_value

        let gep_ret2 = make_local_value(typechecking::pointer(node.tpe), null, state)

        let gep2 = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep2).value.gep = [
            ret = gep_ret2,
            tpe = node.tpe,
            value = load1_value,
            index = index2
        ] !InsnGetElementPtr
        
        let ret = make_address_value(node.tpe, gep_ret2, state)

        push_insn(gep1, state)
        push_insn(load1, state)
        push_insn(gep2, state)
        
        return ret
    } else if (@array_tpe).kind == typechecking::TypeKind::STATIC_ARRAY {  
        var index = allocate_ref(Value, 2)
        index(0) = make_int_value(0)
        index(1) = right_value

        let gep_ret = make_local_value(typechecking::pointer(node.tpe), null, state)

        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = [
            ret = gep_ret,
            tpe = array_tpe,
            value = @left_value.addr,
            index = index
        ] !InsnGetElementPtr

        let ret = make_address_value(node.tpe, gep_ret, state)

        push_insn(gep, state)
        return ret
    } else if typechecking::is_pointer(array_tpe) {
        left_value = load_value(left_value, loc, state)

        var index = allocate_ref(Value, 1)
        index(0) = right_value

        let gep_ret = make_local_value(typechecking::pointer(node.tpe), null, state)

        let gep = make_insn_dbg(InsnKind::GETELEMENTPTR, loc)
        (@gep).value.gep = [
            ret = gep_ret,
            tpe = node.tpe,
            value = left_value,
            index = index
        ] !InsnGetElementPtr

        let ret = make_address_value(node.tpe, gep_ret, state)

        push_insn(gep, state)        
        return ret
    } else {
        assert(false)
    }
}

def walk_SizeOf(node: &parser::Node, state: &State) -> Value {
    if not node.value.expr { return NO_VALUE }
    var tpe = (@node.value.expr).tpe
    if not tpe {
        errors::errorn(node, "Invalid expression")
        return NO_VALUE
    }
    let value = make_int_value(tpe.size !int)
    value.tpe = builtins::size_t_
    
    return value
}

def walk_AlignOf(node: &parser::Node, state: &State) -> Value {
    if not node.value.expr { return NO_VALUE }
    var tpe = (@node.value.expr).tpe
    if not tpe {
        errors::errorn(node, "Invalid expression")
        return NO_VALUE
    }
    let value = make_int_value(tpe.align !int)
    value.tpe = builtins::size_t_
    
    return value
}

def convert_ref_to_int(node: &parser::Node, value: Value, loc: &Value, state: &State) -> Value {
    let gep_ret = state.extract_value(pointer(value.tpe.tpe), value, [1], loc)
    return state.ptr_to_int(gep_ret, loc)
}

def compare(node: &parser::Node, left: Value, right: Value, state: &State) -> Value {
    if not left.tpe or not right.tpe { return NO_VALUE }
    let loc = make_location(node, state)

    if typechecking::equals(left.tpe, right.tpe) { 
        if typechecking::equals(left.tpe, builtins::string_) {
            import_cstd_function("strcmp", state)

            let args = allocate_ref(Value, 2)
            args(0) = charp_str(left, state)
            args(1) = charp_str(right, state)

            let call_ret = make_local_value(builtins::int_, null, state)
            let call = make_insn_dbg(InsnKind::CALL, loc)
            (@call).value.call = [
                name = [
                    kind = ValueKind::GLOBAL,
                    name = "strcmp"
                ] !Value,
                ret = call_ret,
                args = args
            ] !InsnCall
            push_insn(call, state)

            var op: CompareInt
            switch node.kind !int {
                case parser::NodeKind::EQ;  op = CompareInt::eq
                case parser::NodeKind::NEQ; op = CompareInt::ne
                case parser::NodeKind::GT;  op = CompareInt::ugt
                case parser::NodeKind::LT;  op = CompareInt::ult
                case parser::NodeKind::GEQ; op = CompareInt::uge
                case parser::NodeKind::LEQ; op = CompareInt::ule
                case; assert(false)
            }

            let cmp_ret = make_local_value(builtins::bool_, null, state)
            let cmp = make_insn_dbg(InsnKind::ICMP, loc)
            (@cmp).value.icmp = [
                op = op,
                ret = cmp_ret,
                left = call_ret,
                right = [
                    kind = ValueKind::INT,
                    tpe = builtins::int_,
                    i = 0
                ] !Value
            ] !InsnIcmp
            push_insn(cmp, state)

            return cmp_ret
            // TODO There might be better ways of handling this
        } else if builtins::Type_ and typechecking::equals(left.tpe, typechecking::pointer(builtins::Type_)) {
            let svalue = scope::get(toolchain::runtime_.scope, parser::make_identifier("equals"), not consteval::is_static)
            if consteval::is_static {
                consteval::compile_function(svalue, state.scope)
            }
            predeclare_function(svalue.tpe, state.module)
            state.module.imported.add(svalue.tpe.type_name)

            let args = allocate_ref(Value, 2)
            args(0) = left
            args(1) = right

            let call_ret = make_local_value(builtins::bool_, null, state)
            let call = make_insn_dbg(InsnKind::CALL, loc)
            call.value.call = [
                name = [ kind = ValueKind::GLOBAL, name = svalue.tpe.type_name ] !Value,
                ret = call_ret,
                args = args
            ] !InsnCall
            push_insn(call, state)

            var ret: Value
            if node.kind == parser::NodeKind::NEQ {
                ret = make_local_value(builtins::bool_, null, state)
                let xor = make_insn_dbg(InsnKind::XOR, loc)
                (@xor).value.arith = [
                    ret = ret,
                    left = call_ret,
                    right = [ kind = ValueKind::BOOL, i = 1, tpe = builtins::bool_ ] !Value
                ] !InsnArithmetic
                push_insn(xor, state)
            } else if node.kind == parser::NodeKind::EQ {
                ret = call_ret
            } else {
                errors::errorn(node, "Can't compare types")
                return NO_VALUE
            }

            return ret
        }
    }

    var tpe: &typechecking::Type = null
    if typechecking::is_enum(left.tpe) {
        left.tpe = (@left.tpe).tpe
    }
    if typechecking::is_enum(right.tpe) {
        right.tpe = (@right.tpe).tpe
    }
    if typechecking::is_pointer(left.tpe) {
        // TODO We need something like intptr_t, but for now size_t will suffice
        left = convert_to(node, left, builtins::size_t_, state)
    }
    if typechecking::is_pointer(right.tpe) {
        right = convert_to(node, right, builtins::size_t_, state)
    }
    if typechecking::is_ref_or_weak(left.tpe) {
        left = convert_ref_to_int(node, left, loc, state)
    }
    if typechecking::is_ref_or_weak(right.tpe) {
        right = convert_ref_to_int(node, right, loc, state)
    }
    if (@left.tpe).kind == typechecking::TypeKind::NULL {
        left = make_int_value(0)
        left.tpe = builtins::size_t_
    }
    if (@right.tpe).kind == typechecking::TypeKind::NULL {
        right = make_int_value(0)
        right.tpe = builtins::size_t_
    }
    if typechecking::is_arithmetic(left.tpe) and typechecking::is_arithmetic(right.tpe) {
        tpe = typechecking::common_type(left.tpe, right.tpe)
        if not tpe {
            errors::errorn(node, "Can't compare ", debug::type_to_str(left.tpe), " and ", debug::type_to_str(right.tpe))
            return NO_VALUE
        }

        left = convert_to(node, left, tpe, state)
        right = convert_to(node, right, tpe, state)

        let ret = make_local_value(node.tpe, null, state)

        var insn: &Insn = null
        if typechecking::is_float(tpe) {
            var op: CompareFloat
            switch node.kind !int {
                case parser::NodeKind::EQ;  op = CompareFloat::ueq
                case parser::NodeKind::NEQ; op = CompareFloat::une
                case parser::NodeKind::GT;  op = CompareFloat::ugt
                case parser::NodeKind::LT;  op = CompareFloat::ult
                case parser::NodeKind::GEQ; op = CompareFloat::uge
                case parser::NodeKind::LEQ; op = CompareFloat::ule
                case; assert(false)
            }
            insn = make_insn_dbg(InsnKind::FCMP, loc)
            (@insn).value.fcmp = [
                op = op,
                ret = ret,
                left = left,
                right = right
            ] !InsnFcmp
        } else {
            var op: CompareInt
            if tpe.unsig {
                switch node.kind !int {
                    case parser::NodeKind::EQ;  op = CompareInt::eq
                    case parser::NodeKind::NEQ; op = CompareInt::ne
                    case parser::NodeKind::GT;  op = CompareInt::ugt
                    case parser::NodeKind::LT;  op = CompareInt::ult
                    case parser::NodeKind::GEQ; op = CompareInt::uge
                    case parser::NodeKind::LEQ; op = CompareInt::ule
                    case; assert(false)
                }
            } else {
                switch node.kind !int {
                    case parser::NodeKind::EQ;  op = CompareInt::eq
                    case parser::NodeKind::NEQ; op = CompareInt::ne
                    case parser::NodeKind::GT;  op = CompareInt::sgt
                    case parser::NodeKind::LT;  op = CompareInt::slt
                    case parser::NodeKind::GEQ; op = CompareInt::sge
                    case parser::NodeKind::LEQ; op = CompareInt::sle
                    case; assert(false)
                }
            }
            insn = make_insn_dbg(InsnKind::ICMP, loc)
            (@insn).value.icmp = [
                op = op,
                ret = ret,
                left = left,
                right = right
            ] !InsnIcmp
        }

        push_insn(insn, state)

        return ret
    }
    return NO_VALUE
}

def walk_ComparisionOp(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right

    if not left or not right { return NO_VALUE }
    if not (@left).tpe or not (@right).tpe { return NO_VALUE }

    if (@left).kind >= parser::NodeKind::EQ and (@left).kind <= parser::NodeKind::LEQ {
        let value_left = walk_and_load_expression(left, state)
        // These two values get compared
        let value_leftc = walk_and_load_expression((@left).value.bin_op.right, state)
        let value_rightc = walk_and_load_expression(right, state)
        let value = compare(node, value_leftc, value_rightc, state)
        
        let ret = make_local_value(builtins::bool_, null, state)

        let insn_and = make_insn_dbg(InsnKind::AND, loc)
        (@insn_and).value.arith = [
            ret = ret,
            left = value_left,
            right = value
        ] !InsnArithmetic

        push_insn(insn_and, state)

        return ret
    } else {
        let value_left = walk_and_load_expression(left, state)
        let value_right = walk_and_load_expression(right, state)
        return compare(node, value_left, value_right, state)
    }
}

def walk_PointerOp(node: &parser::Node, kind: InsnKind, state: &State) -> Value {
    let loc = make_location(node, state)
    // TODO This is not the correct type
    let value_left = convert_to(node, walk_expression(node.value.bin_op.left, state), builtins::size_t_, state)
    var value_right = convert_to(node, walk_expression(node.value.bin_op.right, state), builtins::size_t_, state)
    value_right = state.mul(builtins::size_t_, value_right, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = node.tpe.tpe.size if node.tpe.tpe else 1 !size_t ] !Value, loc)

    let ret_arith = make_local_value(builtins::size_t_, null, state)

    let arith = make_insn_dbg(kind, loc)
    (@arith).value.arith = [
        ret = ret_arith,
        left = value_left,
        right = value_right
    ] !InsnArithmetic
    push_insn(arith, state)

    let ret_inttoptr = make_local_value(node.tpe, null, state)

    let inttoptr = make_insn_dbg(InsnKind::INTTOPTR, loc)
    (@inttoptr).value.convert = [
        ret = ret_inttoptr,
        value = ret_arith
    ] !InsnConvert
    push_insn(inttoptr, state)

    return ret_inttoptr
}

def walk_IfExpr(node: &parser::Node, state: &State) -> Value {
    let loc = make_location(node, state)
    let cond = convert_to(node, walk_expression(node.value.if_expr.cond, state), builtins::bool_, state)
    let if_true = node.value.if_expr.if_true
    let if_false = node.value.if_expr.if_false

    let ret_alloca = make_named_local(node.tpe, null, state)
    let alloca1 = make_insn_dbg(InsnKind::ALLOCA, loc)
    alloca1.value.alloca = [
        ret = ret_alloca
    ] !InsnAlloca
    push_insn(alloca1, state)
    ret_alloca.tpe = typechecking::pointer(ret_alloca.tpe)

    let entry_label = make_label(state)
    let br = make_insn_dbg(InsnKind::BR, loc)
    br.value.br = [
        cond = cond,
        if_true = entry_label
    ] !InsnBr
    push_insn(br, state)
    push_label(entry_label, state)
    
    var true_value = convert_to(if_true, walk_expression(if_true, state), node.tpe, state)
    if typechecking::is_ref(if_true.tpe) {
        increase_ref_count_of_value(true_value, loc, state)
    } else if typechecking::has_copy_constructor(if_true.tpe) {
        let ret = state.alloca(if_true.tpe, loc, no_yield_capture = true)
        insert_copy_constructor(ret, true_value, loc, state)
        true_value = state.load(if_true.tpe, ret, loc)
    }

    let loc_true = make_location(if_true, state)
    insert_destructors(if_true.scope, loc_true, state)
    let store1 = make_insn_dbg(InsnKind::STORE, loc_true)
    store1.value.store = [
        loc = ret_alloca,
        value = true_value
    ] !InsnStore
    push_insn(store1, state)

    let exit = make_insn_dbg(InsnKind::BR_UNC, loc)
    push_insn(exit, state)

    let false_label = make_label(state)
    br.value.br.if_false = false_label
    push_label(false_label, state)

    var false_value = convert_to(if_false, walk_expression(if_false, state), node.tpe, state)
    if typechecking::is_ref(if_false.tpe) {
        increase_ref_count_of_value(false_value, loc, state)
    } else if typechecking::has_copy_constructor(if_false.tpe) {
        let ret = state.alloca(if_false.tpe, loc, no_yield_capture = true)
        insert_copy_constructor(ret, false_value, loc, state)
        false_value = state.load(if_false.tpe, ret, loc)
    }

    let loc_false = make_location(if_false, state) 
    insert_destructors(if_false.scope, loc_false, state)
    let store2 = make_insn_dbg(InsnKind::STORE, loc_false)
    store2.value.store = [
        loc = ret_alloca,
        value = false_value
    ] !InsnStore
    push_insn(store2, state)
    push_insn(exit, state)

    let exit_label = make_label(state)
    push_label(exit_label, state)
    exit.value.br_unc.label_ = exit_label

    let value = state.load(node.tpe, ret_alloca, loc)
    state.scope = node.scope
    create_temporary(ret_alloca, value, loc, state)

    value.addr = ret_alloca
    return value
}

def walk_Type(node: &parser::Node, state: &State) -> Value {
    let expr = node.value.t_parr.tpe
    node.svalue = change_value_to_type(node.tpe.tpe.tpe, state)
    if not node.svalue { return NO_VALUE }
    return @node.svalue.value
}

def walk_TypeOfT(node: &parser::Node, state: &State) -> Value {
    let expr = node.value.expr
    node.svalue = change_value_to_type(expr.tpe, state)
    if not node.svalue { return NO_VALUE }
    return @node.svalue.value
}

export def walk_expression(node: &parser::Node, state: &State) -> Value {
    var expr = NO_VALUE
    if not node { return NO_VALUE }
    let scpe = state.scope
    
    if node.scope {
        state.scope = node.scope
    }

    switch node.kind !int {
        case parser::NodeKind::NULL
            expr = walk_Null(node, state)
        case parser::NodeKind::UNDEF
            errors::errorn(node, "Undef used outside of initializer")
            expr = NO_VALUE
        case parser::NodeKind::IDENTIFIER
            expr = walk_Identifier(node, state)
        case parser::NodeKind::INTEGER
            expr = walk_Integer(node, state)
        case parser::NodeKind::FLOAT
            expr = walk_Float(node, state)
        case parser::NodeKind::BOOLEAN
            expr = walk_Boolean(node, state)
        case parser::NodeKind::CHAR
            expr = walk_Char(node, state)
        case parser::NodeKind::STRING
            expr = walk_String(node, state)
        case parser::NodeKind::SIZE_OF
            expr = walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF
            expr = walk_AlignOf(node, state)
        case parser::NodeKind::CAST
            expr = walk_Cast(node, state)
        case parser::NodeKind::USUB
            expr = walk_USub(node, state)
        case parser::NodeKind::UADD
            expr = walk_UAdd(node, state)
        case parser::NodeKind::NOT
            expr = walk_Not(node, state)
        case parser::NodeKind::AND
            expr = walk_And(node, state)
        case parser::NodeKind::OR
            expr = walk_Or(node, state)
        case parser::NodeKind::ADD
            expr = walk_Add(node, state)
        case parser::NodeKind::SUB
            expr = walk_Sub(node, state)
        case parser::NodeKind::MUL
            expr = walk_Mul(node, state)
        case parser::NodeKind::MOD
            expr = walk_Mod(node, state)
        case parser::NodeKind::DIV
            expr = walk_Div(node, state)
        case parser::NodeKind::SHL
            expr = walk_Shl(node, state)
        case parser::NodeKind::SHR
            expr = walk_Shr(node, state)
        case parser::NodeKind::BAND
            expr = walk_BAnd(node, state)
        case parser::NodeKind::BOR
            expr = walk_BOr(node, state)
        case parser::NodeKind::BXOR
            expr = walk_BXor(node, state)
        case parser::NodeKind::BNOT
            expr = walk_BNot(node, state)
        case parser::NodeKind::PADD
            expr = walk_PointerOp(node, InsnKind::ADD, state)
        case parser::NodeKind::PSUB
            expr = walk_PointerOp(node, InsnKind::SUB, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ
            expr = walk_ComparisionOp(node, state)
        case parser::NodeKind::FUNC_CALL
            expr = walk_Call(node, state)
        case parser::NodeKind::ASSIGN
            expr = walk_Assign(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::SHR_EQ
            expr = walk_AssignEq(node, state)
        case parser::NodeKind::DEREF
            expr = walk_Deref(node, state)
        case parser::NodeKind::PTR
            expr = walk_Ptr(node, state)
        case parser::NodeKind::MEMBER_ACCESS
            expr = walk_MemberAccess(node, state)
        //case parser::NodeKind::ARRAY_SUBSCRIPT
        //    expr = walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT
            expr = walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_STATIC_T, parser::NodeKind::PTR_T, parser::NodeKind::WEAK_REF_T,
            parser::NodeKind::REF_T, parser::NodeKind::ARRAY_T, parser::NodeKind::FUNCTION_T, parser::NodeKind::CLOSURE_T
            expr = walk_Type(node, state)
        case parser::NodeKind::TYPE_OF_T
            expr = walk_TypeOfT(node, state)
        case parser::NodeKind::IF_EXPR
            expr = walk_IfExpr(node, state)
        case parser::NodeKind::RANGE, parser::NodeKind::RANGE_INC
        case parser::NodeKind::LAMBDA
            expr = walk_Lambda(node, state)
        case;
            error(node.kind, "\n")
            assert(false)
    }
    
    if node.parent and node.parent.body and node.kind != parser::NodeKind::FUNC_CALL and node.kind != parser::NodeKind::ASSIGN and
        expr.kind != ValueKind::NULL and expr.kind != ValueKind::ADDRESS and expr.tpe and expr.tpe.kind != typechecking::TypeKind::POINTER {

        let loc = make_location(node, state)
        let addr = state.alloca(expr.tpe, loc)
        state.store(addr, expr, loc)
        if is_ref(expr.tpe) {
            increase_ref_count(addr, loc, state)
        }
        insert_destructor(addr, loc, state)
    }

    state.scope = scpe
    return expr
}

def walk_If(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)

    let cond = convert_to(node.value.if_.cond, walk_expression(node.value.if_.cond, state), builtins::bool_, state)
    let entry_label = make_label(state)
    var entry = make_insn_dbg(InsnKind::BR, loc)
    (@entry).value.br = [
        cond = cond,
        if_true = entry_label
    ] !InsnBr

    let exit = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(entry, state)
    push_label(entry_label, state)
    push_scope(node, state)
    var last_node = node
    for var i in 0..vector::length(node.value.if_.body) {
        let stmt = node.value.if_.body(i)
        walk(stmt, state)
        last_node = stmt
    }
    insert_destructors(node.inner_scope, make_location(last_node, state), state)
    pop_scope(state)
    push_insn(exit, state)

    for var i in 0..vector::length(node.value.if_.else_if) {
        let br_label = make_label(state)
        (@entry).value.br.if_false = br_label
        push_label(br_label, state)
        
        let else_if = node.value.if_.else_if(i)
        let cond = convert_to((@else_if).value.else_if.cond, walk_expression((@else_if).value.else_if.cond, state), builtins::bool_, state)
        insert_destructors(else_if.scope, make_location(else_if, state), state)

        entry = make_insn_dbg(InsnKind::BR, make_location(else_if, state))
        (@entry).value.br = [
            cond = cond
        ] !InsnBr
        push_insn(entry, state)
        let entry_label = make_label(state)
        (@entry).value.br.if_true = entry_label

        push_label(entry_label, state)
        push_scope(else_if, state)
        var last_node = else_if
        for var i in 0..vector::length((@else_if).value.else_if.body) {
            let stmt = (@else_if).value.else_if.body(i)
            walk(stmt, state)
            last_node = stmt
        }
        insert_destructors(else_if.inner_scope, make_location(last_node, state), state)
        pop_scope(state)
        push_insn(exit, state)
    }

    let else_ = node.value.if_.else_
    if else_ {
        let entry_label = make_label(state)
        (@entry).value.br.if_false = entry_label
        push_label(entry_label, state)
        push_scope(else_, state)
        var last_node = else_
        for var i in 0..vector::length((@else_).value.body) {
            let stmt = (@else_).value.body(i)
            walk(stmt, state)
            last_node = stmt
        }
        insert_destructors(else_.inner_scope, make_location(last_node, state), state)
        pop_scope(state)
        push_insn(exit, state)
    }

    let exit_label = make_label(state)
    if not else_ {
        (@entry).value.br.if_false = exit_label
    }
    (@exit).value.br_unc.label_ = exit_label
    push_label(exit_label, state)
}

let max_cases = 25

def walk_Switch(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let swexpr = walk_and_load_expression(node.value.switch_.expr, state)
    let tpe = (@node.value.switch_.expr).tpe
    
    let switch_values = vector::make(SwitchValue)
    let swtch = make_insn_dbg(InsnKind::SWITCH, loc)
    (@swtch).value.switch_ = [
        value = swexpr,
        switch_values = switch_values
    ] !InsnSwitch
    push_insn(swtch, state)

    let end = make_insn_dbg(InsnKind::BR_UNC, loc)

    var otherwise: &parser::Node = null
    let if_stmts = vector::make(type &parser::Node)

    // TODO We need to check if the ranges overlap
    for var i in 0..vector::length(node.value.switch_.body) {
        let cse = node.value.switch_.body(i)
        let len = vector::length((@cse).value.case_.expr)

        if len == 0 {
            if otherwise {
                errors::errorn(cse, "More than one default case")
                return
            } else {
                otherwise = cse
            }
        } else {
            var out_of_bounds = false
            for var j in 0..len {
                let expr = (@cse).value.case_.expr(j)
                if (@expr).kind == parser::NodeKind::RANGE or
                    (@expr).kind == parser::NodeKind::RANGE_INC {
                    let left = (@expr).value.bin_op.left
                    let right = (@expr).value.bin_op.right
                    if not left.svalue or not right.svalue { return }
                    var min = left.svalue.value.i
                    var max = right.svalue.value.i
                    if (max >= min) and (max - min > max_cases) {
                        if_stmts.push(cse)
                        out_of_bounds = true
                        break
                    }
                }
            }
            if not out_of_bounds {
                let start = make_label(state)
                push_label(start, state)

                for var j in 0..len {
                    let expr = (@cse).value.case_.expr(j)
                    if (@expr).kind == parser::NodeKind::RANGE or
                        (@expr).kind == parser::NodeKind::RANGE_INC {
                        let left = (@expr).value.bin_op.left
                        let right = (@expr).value.bin_op.right
                        var min = left.svalue.value.i
                        var max = right.svalue.value.i
                        if (max >= min) {
                            if (@expr).kind == parser::NodeKind::RANGE_INC {
                                max += 1
                            }
                            for var k in min..max {
                                let svalue = [
                                    label_ = start,
                                    value = [ kind = ValueKind::INT, i = k, tpe = tpe ] !Value
                                ] !SwitchValue
                                switch_values.push(svalue)
                            } 
                        } else {
                            errors::errorn(expr, "Invalid range")
                            return
                        }
                    } else {
                        if not expr.svalue { return }
                        let value = expr.svalue.value.i
                        let svalue = [
                            label_ = start,
                            value = [ kind = ValueKind::INT, i = value, tpe = tpe ] !Value
                        ] !SwitchValue
                        switch_values.push(svalue)
                    }
                }
                
                push_scope(cse, state)
                var last_node = cse
                for var j in 0..vector::length((@cse).value.case_.body) {
                    let stmt = (@cse).value.case_.body(j)
                    walk(stmt, state)
                    last_node = stmt
                }
                insert_destructors(cse.inner_scope, make_location(last_node, state), state)
                pop_scope(state)

                push_insn(end, state)
            }
        }  
    }

    let olabel = make_label(state)
    push_label(olabel, state)

    for var i in 0..vector::length(if_stmts) {
        let cse = if_stmts(i)
        let len = vector::length((@cse).value.case_.expr)

        let brs = vector::make(type &Insn)
        var last: &Insn = null
        for var j in 0..len {
            if last {
                let lbl = make_label(state)
                push_label(lbl, state)
                (@last).value.br.if_false = lbl
            }
            let expr = (@cse).value.case_.expr(j)
            if (@expr).kind == parser::NodeKind::RANGE or 
                (@expr).kind == parser::NodeKind::RANGE_INC {
                let left = (@expr).value.bin_op.left
                let right = (@expr).value.bin_op.right
                var min = left.svalue.value.i
                var max = right.svalue.value.i

                if max < min {
                    errors::errorn(expr, "Invalid range")
                    return
                }
                
                let sub_ret = make_local_value(tpe, null, state)
                let sub = make_insn_dbg(InsnKind::SUB, loc)
                (@sub).value.arith = [
                    ret = sub_ret,
                    left = swexpr,
                    right = [ kind = ValueKind::INT, i = min, tpe = tpe ] !Value
                ] !InsnArithmetic
                push_insn(sub, state)

                var op = CompareInt::ule
                if (@expr).kind == parser::NodeKind::RANGE {
                    op = CompareInt::ult
                }
                let cmp_ret = make_local_value(builtins::bool_, null, state)
                let cmp = make_insn_dbg(InsnKind::ICMP, loc)
                (@cmp).value.icmp = [
                    op = op,
                    ret = cmp_ret,
                    left = sub_ret,
                    right = [ kind = ValueKind::INT, i = max - min, tpe = tpe ] !Value
                ] !InsnIcmp
                push_insn(cmp, state)

                let br = make_insn_dbg(InsnKind::BR, loc)
                (@br).value.br = [
                    cond = cmp_ret
                ] !InsnBr
                push_insn(br, state)
                
                last = br
                brs.push(br)
            } else {
                let value = expr.svalue.value.i

                let cmp_ret = make_local_value(builtins::bool_, null, state)
                let cmp = make_insn_dbg(InsnKind::ICMP, loc)
                (@cmp).value.icmp = [
                    op = CompareInt::eq,
                    ret = cmp_ret,
                    left = swexpr,
                    right = [ kind = ValueKind::INT, i = value, tpe = tpe ] !Value
                ] !InsnIcmp
                push_insn(cmp, state)

                let br = make_insn_dbg(InsnKind::BR, loc)
                (@br).value.br = [
                    cond = cmp_ret
                ] !InsnBr
                push_insn(br, state)
                
                last = br
                brs.push(br)
            }
        }

        let lbl = make_label(state)
        push_label(lbl, state)

        for var i in 0..vector::length(brs) {
            let br = brs(i)
            (@br).value.br.if_true = lbl
        }

        push_scope(cse, state)
        var last_node = cse
        for var j in 0..vector::length((@cse).value.case_.body) {
            let stmt = (@cse).value.case_.body(j)
            walk(stmt, state)
            last_node = stmt
        }
        insert_destructors(cse.inner_scope, make_location(last_node, state), state)
        pop_scope(state)

        push_insn(end, state)

        if last {
            let lbl = make_label(state)
            push_label(lbl, state)
            (@last).value.br.if_false = lbl
        }
    }

    if otherwise {
        push_scope(otherwise, state)
        var last_node = otherwise
        for var i in 0..vector::length((@otherwise).value.case_.body) {
            let stmt = (@otherwise).value.case_.body(i)
            walk(stmt, state)
            last_node = stmt
        }
        insert_destructors(otherwise.inner_scope, make_location(last_node, state), state)
        pop_scope(state)
    }

    push_insn(end, state)
    (@swtch).value.switch_.otherwise = olabel

    let end_label = make_label(state)
    push_label(end_label, state)
    (@end).value.br_unc.label_ = end_label
}

def return_post(expr: Value, loc: &Value, state: &State) -> Value {
    if is_ref(expr.tpe) {
        increase_ref_count_of_value(expr, loc, state)
    }
    if typechecking::has_copy_constructor(expr.tpe) {
        let ret = state.alloca(expr.tpe, loc, no_yield_capture = true)
        insert_copy_constructor(ret, expr, loc, state)
        expr = state.load(expr.tpe, ret, loc)
    }
    return expr
}

def walk_Return(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let current_function = state.current_function()
    if not current_function { return }

    var value: &Value = NO_VALUE
    if (@current_function).multiple_returns {
        let ret_args = allocate_ref(Value, vector::length(node.value.body))
        for var i in 0..ret_args.size {
            let n = node.value.body(i)
            let tpe = (@(@current_function).ret).fields(i).tpe
            var expr = convert_to(n, walk_expression(n, state), tpe, state)
            ret_args(i) = return_post(expr, loc, state)
        }
        value = [
            kind = ValueKind::STRUCT,
            values = ret_args,
            tpe = (@current_function).ret
        ] !&Value

        locals_to_insert_value(value, state)
    } else {
        let tpe = (@current_function).ret
        if tpe and vector::length(node.value.body) > 0 {
            let arg = vector::peek(node.value.body)
            value = convert_to(arg, walk_expression(arg, state), tpe, state)
            value = return_post(@value, loc, state)
        }
    }

    if current_function.has_defer {
        defer_unroll(node, state)
    }

    var scpe = state.scope
    while not scpe.is_function {
        insert_destructors(scpe, loc, state)
        scpe = scpe.parent 
    }
    insert_destructors(scpe, loc, state)
    if current_function.has_yield {
        state.store(
            [ kind = ValueKind::LOCAL, tpe = pointer(builtins::bool_), name = "__is_at_end" ] !Value,
            [ kind = ValueKind::BOOL, tpe = builtins::bool_, i = 1 ] !Value
        )

        state.store(
            [ kind = ValueKind::LOCAL, tpe = pointer(builtins::int_), name = "__block" ] !Value,
            [ kind = ValueKind::INT, tpe = builtins::int_, i = -1 ] !Value
        )

        let tpe = (@current_function).ret
        if tpe and vector::length(node.value.body) > 0 {
            var ret_value = [ kind = ValueKind::ZEROINITIALIZER, tpe = current_function.optional ] !Value
            ret_value = state.insert_value(current_function.optional, ret_value, [ kind = ValueKind::BOOL, tpe = builtins::bool_, i = 1 ] !Value, [0])
            ret_value = state.insert_value(current_function.optional, ret_value, @value, [1])

            state.ret(ret_value)
        } else {
            state.ret([ kind = ValueKind::ZEROINITIALIZER, tpe = current_function.optional ] !Value)
        }
    } else {
        if state.is_inline() {
            if current_function.ret {
                state.store(state.return_address, @value, loc)
                push_insn(state.return_br, state)
            }
        } else {
            let ret = make_insn_dbg(InsnKind::RET, loc)
            (@ret).value.ret.value = @value
            push_insn(ret, state)
        }
    }
    if not state.is_inline() {
        push_label(make_label(state), state)
    }
}

def walk_YieldFrom(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let function = state.current_function()
    if not function { return }
    if not node.value.expr { return }
    let tpe = node.value.expr.tpe
    if not tpe { return }
    if not node.svalue { return }

    let ident = node.svalue.identifier
    let iddecl = [ kind = parser::NodeKind::FOR_ID_DECL, loc = node.loc ] !&parser::Node
    iddecl.value.for_id_decl = [
        kw = parser::VarDecl::VAR,
        ident = ident
    ] !parser::NodeForIdDecl
    iddecl.tpe = tpe.tpe.tc_args(0)

    let yield_body = vector::make(type &parser::Node)
    yield_body.push(ident)
    let yield_ = [ kind = parser::NodeKind::YIELD, loc = node.loc ] !&parser::Node
    yield_.value.body = yield_body

    let body = vector::make(type &parser::Node)
    body.push(yield_)

    let for_ = [ kind = parser::NodeKind::FOR, loc = node.loc, inner_scope = node.inner_scope ] !&parser::Node
    for_.value.for_loop = [
        iddecl = iddecl,
        expr = node.value.expr,
        body = body
    ] !parser::NodeFor

    for_setup_generator(node.value.expr, for_, state.scope)
    walk_For(for_, state)
}

def walk_Yield(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let current_function = state.current_function()
    var value = NO_VALUE
    var tpe = current_function.ret
    if tpe and vector::length(node.value.body) > 0 {
        tpe = tpe.tpe.tc_args(0)
        let arg = vector::peek(node.value.body)
        value = convert_to(arg, walk_expression(arg, state), tpe, state)
        value = return_post(value, null, state)
    }

    state.store(
        [ kind = ValueKind::LOCAL, tpe = pointer(builtins::int_), name = "__block" ] !Value,
        [ kind = ValueKind::INT, tpe = builtins::int_, i = current_function.yield_index ] !Value,
        loc
    )

    var ret_value = [ kind = ValueKind::ZEROINITIALIZER, tpe = current_function.optional ] !Value
    ret_value = state.insert_value(current_function.optional, ret_value, [ kind = ValueKind::BOOL, tpe = builtins::bool_, i = 1 ] !Value, [0], loc)
    ret_value = state.insert_value(current_function.optional, ret_value, value, [1], loc)

    state.ret(ret_value, loc)
    let label_ = make_label(state)
    push_label(label_, state)

    current_function.yield_switch.value.switch_.switch_values.push(
        [ value = [ kind = ValueKind::INT, tpe = builtins::int_, i = current_function.yield_index ] !Value, label_ = label_] !SwitchValue
    ) 

    current_function.take_snapshot()
    current_function.yield_index += 1
}

def walk_Break(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let loop_state_opt = get_loop_state(state)
    if not loop_state_opt.exists {
        errors::errorn(node, "break used outside of a loop")
        return
    }
    let loop_state = loop_state_opt.get()
    
    var scpe = state.scope
    while scpe != loop_state.scope {
        insert_destructors(scpe, loc, state)
        scpe = scpe.parent
    }
    insert_destructors(scpe, loc, state)

    push_insn(loop_state.break_insn, state)
    push_label(make_label(state), state)
}

def walk_Continue(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let loop_state_opt = get_loop_state(state)
    if not loop_state_opt.exists {
        errors::errorn(node, "continue used outside of a loop")
        return
    }
    let loop_state = loop_state_opt.get()
    
    var scpe = state.scope
    while scpe != loop_state.scope {
        insert_destructors(scpe, loc, state)
        scpe = scpe.parent
    }
    insert_destructors(scpe, loc, state)

    push_insn(loop_state.continue_insn, state)
    push_label(make_label(state), state)
}

def walk_Loop(node: &parser::Node, state: &State) {
    push_loop_state(state, node.inner_scope)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)
    push_scope(node, state)
    var last_node = node
    for var i in 0..vector::length(node.value.body) {
        let n = node.value.body(i)
        walk(n, state)
        last_node = n
    }
    insert_destructors(node.inner_scope, make_location(last_node, state), state)
    pop_scope(state)
    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def walk_While(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    push_loop_state(state, node.inner_scope)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    push_scope(node, state)
    let cond = convert_to(node, walk_expression(node.value.while_loop.expr, state), builtins::bool_, state)
    
    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = [
        cond = cond
    ] !InsnBr
    
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    (@br).value.br.if_true = inner

    var last_node = node
    for var i in 0..vector::length(node.value.while_loop.body) {
        let n = node.value.while_loop.body(i)
        walk(n, state)
        last_node = n
    }
    insert_destructors(node.inner_scope, make_location(last_node, state), state)
    pop_scope(state)

    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def walk_For_array(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let expr = node.value.for_loop.expr
    let iddecl = node.value.for_loop.iddecl

    let is_static = expr.tpe.kind == typechecking::TypeKind::STATIC_ARRAY

    push_scope(node, state)

    let start_value = [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value

    var end_value: Value
    var addr: Value
    if is_static {
        let array = walk_expression(expr, state)
        if array.addr { addr = @array.addr }
        else {
            addr = state.alloca(expr.tpe)
            state.store(addr, load_value(array, loc, state))
        }
        end_value = [ kind = ValueKind::INT, tpe = builtins::int64_, i = expr.tpe.length ] !Value
    } else {
        let array = walk_and_load_expression(expr, state)
        end_value = state.extract_value(builtins::size_t_, array, [0], loc)
        addr = state.extract_value(pointer(expr.tpe.tpe), array, [1], loc)
    }

    let end_value_ptr = state.alloca(builtins::int64_)
    state.store(end_value_ptr, end_value)
    let addr_ptr = state.alloca(addr.tpe)
    state.store(addr_ptr, addr)

    let locv = for_create_var(iddecl, loc, state)
    let index_ptr = state.alloca(builtins::int64_)
    state.store(index_ptr, start_value)

    push_loop_state(state, node.inner_scope)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)
    let start_insn = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(start_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    var index = state.load(builtins::int64_, index_ptr)
    let should_break = state.icmp(CompareInt::slt, index, state.load(builtins::int64_, end_value_ptr), loc)

    let br = make_insn_dbg(InsnKind::BR, loc)
    br.value.br = [
        cond = should_break
    ] !InsnBr
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    br.value.br.if_true = inner

    let addr_value = state.load(addr.tpe, addr_ptr)
    var value_ptr: Value
    if is_static {
        value_ptr = state.gep(pointer(expr.tpe.tpe), expr.tpe, addr_value, [make_int_value(0), index], loc)
    } else {
        value_ptr = state.gep(pointer(expr.tpe.tpe), expr.tpe.tpe, addr_value, [index], loc)
    }
    var value = state.load(expr.tpe.tpe, value_ptr, loc)
    state.store(locv, value)
    
    if is_ref(expr.tpe.tpe) {
        increase_ref_count(locv, loc, state)
    } else if has_copy_constructor(expr.tpe.tpe) {
        insert_copy_constructor(locv, value, loc, state)
    }
    //create_temporary(locv, state.load(iddecl.tpe, locv, loc), loc, state)

    var last_node = node
    for var i in 0..vector::length(node.value.for_loop.body) {
        let n = node.value.for_loop.body(i)
        walk(n, state)
        last_node = n
    }
    insert_destructors(node.inner_scope, make_location(last_node, state), state)

    push_insn(continue_insn, state)
    let inc_label = make_label(state)
    push_label(inc_label, state)

    index = state.load(builtins::int64_, index_ptr)
    let inc = state.add(builtins::int64_, index, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 1 ] !Value)
    state.store(index_ptr, inc)

    push_insn(start_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    br.value.br.if_false = end_label

    start_insn.value.br_unc.label_ = start_label
    continue_insn.value.br_unc.label_ = inc_label
    break_insn.value.br_unc.label_ = end_label
    pop_loop_state(state)

    pop_scope(state)
}

def walk_For_generator(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)
    let expr = node.value.for_loop.expr
    let iddecl = node.value.for_loop.iddecl

    push_loop_state(state, node.inner_scope)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)

    let expr_loc = make_location(expr, state)
    var gen = walk_expression(expr, state)
    let gen_ptr = @gen.addr

    push_scope(node, state)
    let outer_scope = state.scope
    state.scope = node.inner_scope

    push_insn(continue_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    let next_function = node.value.for_loop.generator_next.tpe
    predeclare_function(next_function, state.module)
    state.module.imported.add(next_function.type_name)

    gen = state.load(expr.tpe, gen_ptr)
    let next = state.call(next_function.type_name, next_function.return_t(0), [gen], expr_loc)
    let cond = state.extract_value(builtins::bool_, next, [0], expr_loc)
    let locv = for_create_var(iddecl, loc, state)
    
    let br = make_insn_dbg(InsnKind::BR, loc)
    (@br).value.br = [
        cond = cond
    ] !InsnBr
    
    push_insn(br, state)
    let inner = make_label(state)
    push_label(inner, state)
    (@br).value.br.if_true = inner

    let get_function = node.value.for_loop.generator_get.tpe
    predeclare_function(get_function, state.module)
    state.module.imported.add(get_function.type_name)

    let next_value = state.call(get_function.type_name, iddecl.tpe, [next], expr_loc)
    state.store(locv, next_value)

    if has_copy_constructor(iddecl.tpe) {
        let copy = insert_copy_constructor(locv, next_value, loc, state, no_yield_capture = false)
        create_temporary(copy, state.load(iddecl.tpe, copy, loc), loc, state)
    }

    var last_node = node
    for var i in 0..vector::length(node.value.for_loop.body) {
        let n = node.value.for_loop.body(i)
        walk(n, state)
        last_node = n
    }
    let last_loc = make_location(last_node, state)
    //insert_destructor(locv, loc, state)
    insert_destructors(node.inner_scope, last_loc, state)
    pop_scope(state)
    state.scope = outer_scope

    push_insn(continue_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@continue_insn).value.br_unc.label_ = start_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)
}

def for_create_var(iddecl: &parser::Node, loc: &Value, state: &State) -> Value {
    let tpe = iddecl.tpe
    if iddecl.kind == parser::NodeKind::FOR_ID_DECL {
        let value = iddecl.value.for_id_decl.ident.svalue
        if not value { return NO_VALUE }

        state.add_local(current_function(state), value, tpe)
        
        let ret = [
            kind = ValueKind::LOCAL,
            name = value.assembly_name(state),
            tpe = tpe
        ] !Value

        let alloca = make_insn_dbg(InsnKind::ALLOCA, loc)
        (@alloca).value.alloca = [
            ret = ret
        ] !InsnAlloca
        push_alloca(alloca, state)

        ret.tpe = typechecking::pointer(tpe)
        push_declare(iddecl.value.for_id_decl.ident, ret, value.name, state)

        let current_function = state.current_function()
        if current_function and not current_function.is_global {
            current_function.function_locals.add(value.assembly_name(state))
        }

        return [
            kind = ValueKind::LOCAL,
            name = value.assembly_name(state),
            tpe = typechecking::pointer(tpe)
        ] !Value
    } else {
        let addr = walk_and_load_expression(iddecl, state).addr
        if not addr { return NO_VALUE }
        return @addr
    }
}

// TODO The locations seem off for this
def walk_For(node: &parser::Node, state: &State) {
    
    let expr = node.value.for_loop.expr
    if not expr or not expr.tpe { return }

    if expr.tpe.kind == typechecking::TypeKind::ARRAY or expr.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
        walk_For_array(node, state)
        return
    } else if expr.tpe.kind == typechecking::TypeKind::REFERENCE and expr.tpe.tpe and expr.tpe.tpe.tc_tpe == builtins::Generator_ {
        walk_For_generator(node, state)
        return
    }
    
    var op = CompareInt::slt
    if expr.kind == parser::NodeKind::RANGE_INC {
        op = CompareInt::sle
    }

    let iddecl = node.value.for_loop.iddecl
    let tpe = iddecl.tpe
    if not tpe { return }

    push_scope(node, state)

    let left = expr.value.bin_op.left
    let right = expr.value.bin_op.right
    let startv = convert_to(left, walk_expression(left, state), tpe, state)
    var endv = convert_to(right, walk_expression(right, state), tpe, state)
    let endv_ptr = state.alloca(tpe)
    state.store(endv_ptr, endv)

    let loc = make_location(node, state)
    let locv = for_create_var(iddecl, loc, state)
    
    let store = make_insn_dbg(InsnKind::STORE, loc)
    (@store).value.store = [
        loc = locv,
        value = startv
    ] !InsnStore

    push_insn(store, state)

    push_loop_state(state, node.inner_scope)
    let continue_insn = get_continue_insn(state)
    let break_insn = get_break_insn(state)
    let start_insn = make_insn_dbg(InsnKind::BR_UNC, loc)

    push_insn(start_insn, state)
    let start_label = make_label(state)
    push_label(start_label, state)

    let load_ret = state.load(builtins::int_, locv, loc)

    endv = state.load(tpe, endv_ptr)
    let tpe2 = typechecking::common_type(load_ret.tpe, endv.tpe)
    let left2 = convert_to(node, load_ret, tpe2, state)
    let right2 = convert_to(node, endv, tpe2, state)

    let cmp_ret = make_local_value(builtins::bool_, null, state)
    let cmp = make_insn_dbg(InsnKind::ICMP, loc)
    cmp.value.icmp = [
        op = op,
        ret = cmp_ret,
        left = left2,
        right = right2
    ] !InsnIcmp

    push_insn(cmp, state)

    let br = make_insn_dbg(InsnKind::BR, loc)
    br.value.br = [
        cond = cmp_ret
    ] !InsnBr
    
    push_insn(br, state)

    let inner = make_label(state)
    push_label(inner, state)
    br.value.br.if_true = inner

    var last_node = node
    for var i in 0..vector::length(node.value.for_loop.body) {
        let n = node.value.for_loop.body(i)
        walk(n, state)
        last_node = n
    }
    insert_destructors(node.inner_scope, make_location(last_node, state), state)

    push_insn(continue_insn, state)
    let inc_label = make_label(state)
    push_label(inc_label, state)

    let index = state.load(builtins::int_, locv, loc)
    let add_ret = make_local_value(builtins::int_, null, state)
    let add = make_insn_dbg(InsnKind::ADD, loc)
    (@add).value.arith = [
        ret = add_ret,
        left = index,
        right = [ kind = ValueKind::INT, i = 1, tpe = builtins::int_ ] !Value
    ] !InsnArithmetic

    push_insn(add, state)

    let store2 = make_insn_dbg(InsnKind::STORE, loc)
    (@store2).value.store = [
        loc = locv,
        value = add_ret
    ] !InsnStore

    push_insn(store2, state)

    push_insn(start_insn, state)
    let end_label = make_label(state)
    push_label(end_label, state)
    (@br).value.br.if_false = end_label

    (@start_insn).value.br_unc.label_ = start_label
    (@continue_insn).value.br_unc.label_ = inc_label
    (@break_insn).value.br_unc.label_ = end_label
    pop_loop_state(state)

    pop_scope(state)
}

export def walk_VarDecl(node: &parser::Node, state: &State, set_constant: bool = false) {
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let kw = node.value.var_decl.kw

    if kw == parser::VarDecl::CONST and not set_constant {
        return
    }

    let loc = make_location(node, state)
    let assign_left = vector::make(type &parser::Node)

    for var i in 0..vector::length(left) {
        let n = left(i)
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            let type_lit = (@n).value.id_decl.tpe
            let tpe = (@v).tpe
            import_structures(tpe, state.module)

            if type_lit and (type_lit.kind == parser::NodeKind::STRUCT_T or
                type_lit.kind == parser::NodeKind::UNION_T) {
                verify_struct(state.current_value(), type_lit)
            }

            let value = v.svalue
            if not value { continue }
            if value.name != "_" {
                let ret = [
                    kind = ValueKind::LOCAL,
                    name = value.assembly_name(state),
                    tpe = tpe
                ] !Value

                let current_function = state.current_function()
                if current_function and not current_function.is_global {
                    current_function.function_locals.add(value.assembly_name(state))
                }

                let insn = make_insn_dbg(InsnKind::ALLOCA, loc)
                (@insn).value.alloca = [
                    ret = ret
                ] !InsnAlloca
                push_alloca(insn, state)

                ret.tpe = typechecking::pointer(tpe)
                push_declare(v, ret, (@value).name, state)

                var is_undef = false
                if i < vector::length(right) {
                    let r = right(i)
                    if r { 
                        create_dependency(current_function.value, r.svalue) 
                        if r.kind == parser::NodeKind::UNDEF {
                            is_undef = true
                        }
                    }
                }
                if not is_undef {
                    state.store(ret, [ kind = ValueKind::ZEROINITIALIZER, tpe = tpe ] !Value)
                }
            }

            state.add_local(state.current_function(), value, value.tpe)

            v.is_initializer = true
            assign_left.push(v)
        } else {
            assign_left.push((@n).value.expr)
        }
    }

    if vector::length(right) > 0 {
        let assign = [
            kind = parser::NodeKind::ASSIGN,
            loc = node.loc,
            scope = node.scope,
            parent = node.parent
        ] !&parser::Node
        
        (@assign).value.assign = [
            left = assign_left,
            right = right
        ] !parser::NodeAssign
        walk_Assign(assign, state)
    }
}

def walk_Lambda(node: &parser::Node, state: &State) -> Value {
    import_cstd_function("malloc", state)
    let function = node.value.lambda.function
    if not function { return NO_VALUE }

    let loc = make_location(node, state)
    let context_tpe = function.state

    let ret = state.alloca(node.value.lambda.closure_type, loc)

    typechecking::create_type_entry(typechecking::reference(context_tpe))
    let context_ptr = create_closure_context(function, ret, loc, state, insert_temporary = true)

    predeclare_function(function)
    create_function(node, function.tpe, node.value.lambda.body, node.inner_scope, null, state, is_closure = true, params = node.value.lambda.parameters)
    state.module.imported.add(node.tpe.type_name)

    let context = create_closure_context_captures(function, loc, state)
    state.store(context_ptr, context, loc)
    
    push_local_var(context_tpe.type_name, reference(context_tpe), state.current_function)
    
    return state.load(node.value.lambda.closure_type, ret, loc)
}

def walk_Def(node: &parser::Node, state: &State) {
    import_cstd_function("malloc", state)
    let function = node.value.def_.function
    if not function { return }

    let name = node.value.def_.name
    let loc = make_location(node, state)
    let context_tpe = function.state

    typechecking::create_type_entry(typechecking::reference(context_tpe))

    let value = state.scope.get(name)
    if not value { return }
    
    let ret = [
        kind = ValueKind::LOCAL,
        name = value.assembly_name(state),
        tpe = value.tpe
    ] !Value

    state.current_function().function_locals.add(value.assembly_name(state))

    let insn = make_insn_dbg(InsnKind::ALLOCA, loc)
    insn.value.alloca = [
        ret = ret
    ] !InsnAlloca
    push_alloca(insn, state)
    ret.tpe = pointer(ret.tpe)

    push_declare(node, ret, value.name, state)

    let context_ptr = create_closure_context(function, ret, loc, state)

    predeclare_function(function)
    create_function(node, node.tpe, node.value.def_.body, node.inner_scope, null, state, is_closure = true, params = node.value.def_.params)
    state.module.imported.add(node.tpe.type_name)

    let context = create_closure_context_captures(function, loc, state)
    state.store(context_ptr, context, loc)

    push_local_var(context_tpe.type_name, reference(context_tpe), state.current_function)
}

def create_closure_context(function: &Function, ret: Value, loc: &Value, state: &State, insert_temporary: bool = false) -> Value {
    let context_tpe = function.state

    let context_ptr_i8 = state.call("malloc", pointer(builtins::int8_), [[ kind = ValueKind::INT, tpe = builtins::size_t_, i = context_tpe.size ] !Value], loc)
    let ref_count_i8 = state.call("malloc", pointer(builtins::int8_), [[ kind = ValueKind::INT, tpe = builtins::size_t_, i = builtins::int64_.size ] !Value], loc)
    let ref_count = state.bitcast(pointer(builtins::int64_), ref_count_i8, loc)
    state.store(ref_count, [ kind = ValueKind::INT, tpe = ValueKind::int64_, i = 1 ] !Value, loc)

    let context_tpe_value = do_create_type(reference(context_tpe), state.module)

    var closure = [ kind = ValueKind::UNDEF, tpe = typechecking::reference(null) ] !Value
    closure = state.insert_value(typechecking::reference(null), closure, ref_count, [0], loc)
    closure = state.insert_value(typechecking::reference(null), closure, context_ptr_i8, [1], loc)
    closure = state.insert_value(typechecking::reference(null), closure, context_tpe_value, [2], loc)

    let context_fun_ptr = state.gep(pointer(pointer(function.tpe)), ret.tpe.tpe, ret, [make_int_value(0), make_int_value(0)], loc)
    state.store(context_fun_ptr, [ kind = ValueKind::GLOBAL, tpe = pointer(function.tpe), name = function.tpe.type_name ] !Value, loc)
    let context_ref_ptr = state.gep(pointer(typechecking::reference(null)), ret.tpe.tpe, ret, [make_int_value(0), make_int_value(1)], loc)
    state.store(context_ref_ptr, closure, loc)

    if insert_temporary {
        let ctx = state.alloca(typechecking::reference(null), loc)
        state.store(ctx, closure, loc)
        create_temporary(ctx, closure, loc, state)
    }

    let context_ptr = state.bitcast(pointer(context_tpe), context_ptr_i8, loc)
    return context_ptr
}

def create_closure_context_captures(function: &Function, loc: &Value, state: &State) -> Value {
    let context_tpe = function.state
    var context = [ kind = ValueKind::UNDEF, tpe = context_tpe ] !Value

    for var i in 0..function.captures.length {
        let capture = function.captures(i)
        var svalue = scope::get(state.scope, parser::make_identifier(capture.name))
        var value = NO_VALUE
        if capture.name.starts_with("__ref.") and not svalue {
            svalue = scope::get(state.scope, parser::make_identifier(capture.name.substring(6, capture.name.length)))
            value = [ kind = ValueKind::LOCAL, tpe = capture.tpe, name = svalue.assembly_name(state) ] !Value
        } else {
            let addr = [ kind = ValueKind::LOCAL, tpe = pointer(capture.tpe), name = svalue.assembly_name(state) ] !Value
            if is_ref(addr.tpe.tpe) {
                increase_ref_count(addr, loc, state)
                value = state.load(capture.tpe, addr, loc)
            } else if has_copy_constructor(addr.tpe.tpe) {
                value = state.load(capture.tpe, addr, loc)
                insert_copy_constructor(addr, value, loc, state)
            } else {
                value = state.load(capture.tpe, addr, loc)
            }
        }
        context = state.insert_value(context_tpe, context, value, [i], loc)
    }
    return context
}

def walk_Defer(node: &parser::Node, state: &State) {
    let current_function = state.current_function()
    let current_block = state.current_block
    if not current_function.locals { return }

    let defer_name = current_function.name + ".defer." + state.global_counter
    state.global_counter += 1

    let parameter_t = vector::make(typechecking::NamedParameter)
    parameter_t.push([
        name = "__env",
        _tpe = typechecking::pointer(current_function.env)
    ] !typechecking::NamedParameter)

    let tpe = typechecking::make_function_type_n(parser::make_identifier("defer"), parameter_t, vector::make(type &typechecking::Type))

    let keys_locals = map::keys(current_function.locals)
    
    var env = [ kind = ValueKind::UNDEF, tpe = current_function.env ] !Value
    for var i in 0..keys_locals.size {
        let key = keys_locals(i)
        let tpe = current_function.locals(key)

        let load = make_insn(InsnKind::LOAD)
        let value = make_local_value(tpe, null, state)
        load.value.load = [
            loc = [ kind = ValueKind::LOCAL, tpe = typechecking::pointer(tpe), name = key ] !Value,
            value = value
        ] !InsnLoad
        push_insn(load, state)

        let index = allocate_ref(int, 1)
        index(0) = i
        let ret = make_local_value(current_function.env, null, state)
        let insert = make_insn(InsnKind::INSERTVALUE)
        insert.value.insert_value = [
            ret = ret,
            value = env,
            element = value,
            index = index
        ] !InsnInsertValue
        push_insn(insert, state)
        env = ret
    }
    
    var alloca_ret: Value
    if current_function.is_global {
        import_cstd_function("malloc", state)
        let call_ret = state.call(
            "malloc", 
            pointer(builtins::int8_),
            [[ kind = ValueKind::INT, tpe = builtins::int64_, i = current_function.defers.size ] !Value]
        )
        alloca_ret = state.bitcast(pointer(current_function.defers), call_ret)
    } else {
        alloca_ret = make_local_value(current_function.defers, null, state)
        let alloca = make_insn(InsnKind::ALLOCA)
        alloca.value.alloca = [
            ret = alloca_ret
        ] !InsnAlloca
        push_insn(alloca, state)
        alloca_ret.tpe = typechecking::pointer(alloca_ret.tpe)
    }

    let load_ret = make_local_value(typechecking::pointer(current_function.defers), null, state)
    let load = make_insn(InsnKind::LOAD)
    load.value.load = [
        loc = [ kind = ValueKind::GLOBAL if current_function.is_global else ValueKind::LOCAL, 
            tpe = typechecking::pointer(typechecking::pointer(current_function.defers)), 
            name = "__defers" 
        ] !Value,
        value = load_ret
    ] !InsnLoad
    push_insn(load, state)

    let index1 = allocate_ref(int, 1)
    index1(0) = 0
    let insert1_ret = make_local_value(current_function.defers, null, state)
    let insert1 = make_insn(InsnKind::INSERTVALUE)
    insert1.value.insert_value = [
        ret = insert1_ret,
        value = [ kind = ValueKind::UNDEF, tpe = current_function.defers ] !Value,
        element = env,
        index = index1
    ] !InsnInsertValue
    push_insn(insert1, state)

    let index2 = allocate_ref(int, 1)
    index2(0) = 1
    let insert2_ret = make_local_value(current_function.defers, null, state)
    let insert2 = make_insn(InsnKind::INSERTVALUE)
    insert2.value.insert_value = [
        ret = insert2_ret,
        value = insert1_ret,
        element = [ kind = ValueKind::GLOBAL, tpe = typechecking::pointer(tpe), name = defer_name ] !Value,
        index = index2
    ] !InsnInsertValue
    push_insn(insert2, state)
    
    let index3 = allocate_ref(int, 1)
    index3(0) = 2
    let insert3_ret = make_local_value(current_function.defers, null, state)
    let insert3 = make_insn(InsnKind::INSERTVALUE)
    insert3.value.insert_value = [
        ret = insert3_ret,
        value = insert2_ret,
        element = load_ret,
        index = index3
    ] !InsnInsertValue
    push_insn(insert3, state)

    let store1 = make_insn(InsnKind::STORE)
    store1.value.store = [
        value = insert3_ret,
        loc = alloca_ret
    ] !InsnStore
    push_insn(store1, state)

    let store2 = make_insn(InsnKind::STORE)
    store2.value.store = [
        value = alloca_ret,
        loc = [ kind = ValueKind::GLOBAL if current_function.is_global else ValueKind::LOCAL, 
            tpe = typechecking::pointer(typechecking::pointer(current_function.defers)), 
            name = "__defers" 
        ] !Value
    ] !InsnStore
    push_insn(store2, state)

    let block = make_block()
    let function = [
        name = defer_name,
        unmangled = "defer",
        args = parameter_t,
        allocas = vector::make(type &Insn),
        block = block,
        module = state.module,
        function_locals = set::make()
    ] !&Function

    var scope: &Value = null
    if toolchain::debug_sym {
        scope = vector::pop(state.discope)
        create_debug_info(node, function, tpe, state)
    }

    state.current_block = function.block
    state.function_stack.push(function)

    for var i in 0..keys_locals.size {
        let key = keys_locals(i)
        let tpe = current_function.locals(key)

        let index = allocate_ref(Value, 2)
        index(0) = make_int_value(0)
        index(1) = make_int_value(i)

        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = [
            ret = [ kind = ValueKind::LOCAL, tpe = pointer(tpe), name = key ] !Value,
            tpe = current_function.env,
            value = [ kind = ValueKind::LOCAL, tpe = typechecking::pointer(current_function.env), name = "__env.value" ] !Value,
            index = index
        ] !InsnGetElementPtr
        push_insn(gep, state)
    }
    
    for var i in 0..vector::length(node.value.body) {
        walk(node.value.body(i), state)
    }

    let ret = make_insn(InsnKind::RET)
    ret.value.ret.value = NO_VALUE
    push_insn(ret, state)

    state.current_block = current_block
    state.function_stack.pop()
    
    if toolchain::debug_sym { 
        state.discope.pop()
        state.discope.push(scope) 
    }

    if not current_function.defer_functions {
        current_function.defer_functions = vector::make(type &Function)
    }
    current_function.defer_functions.push(function)

    vector::insert(function.block.insn, 0, function.allocas)
    state.module.imported.add(function.name)
    insert_function(state.module, function)
}

def walk_Assert(node: &parser::Node, state: &State) {
    let loc = make_location(node, state)

    let cond = node.value.assert_.cond
    let msg = node.value.assert_.message

    if state.current_function().test {
        // Call assertion_handler
        let env = state.load(builtins::TestEnvironment_, [
            kind = ValueKind::LOCAL,
            tpe = pointer(builtins::TestEnvironment_),
            name = "__env"
        ] !Value)
        let handler_fun_type = builtins::TestEnvironment_.fields(2).tpe
        let assertion_handler = state.extract_value(handler_fun_type, env, [2])
        if not cond {
            let handler_call = make_insn(InsnKind::CALL)
            handler_call.value.call = [
                name = assertion_handler,
                ret = NO_VALUE,
                args = [
                    [ kind = ValueKind::BOOL, tpe = builtins::bool_, i = 0 ] !Value,
                    [ kind = ValueKind::NULL, tpe = pointer(builtins::char_) ] !Value
                ]
            ] !InsnCall
            push_insn(handler_call, state)
        } else {
            let expr = convert_to(cond, walk_expression(cond, state), builtins::bool_, state)

            if not msg {
                let handler_call = make_insn(InsnKind::CALL)
                handler_call.value.call = [
                    name = assertion_handler,
                    ret = NO_VALUE,
                    args = [expr, [ kind = ValueKind::NULL, tpe = pointer(builtins::char_) ] !Value]
                ] !InsnCall
                push_insn(handler_call, state)
            } else {
                let msg_charp = charp_str(walk_and_load_expression(msg, state), state)

                let handler_call = make_insn(InsnKind::CALL)
                handler_call.value.call = [
                    name = assertion_handler,
                    ret = NO_VALUE,
                    args = [expr, msg_charp]
                ] !InsnCall
                push_insn(handler_call, state)
            }
        }
        return
    }

    import_structures(scope::get(state.scope, parser::make_identifier("fprintf")).tpe, state.module)

    let std_module = toolchain::find_module("std")
    let stderr_fun = scope::get(std_module.scope, parser::make_identifier("stderr")).tpe
    let print_stacktrace_fun = scope::get(std_module.scope, parser::make_identifier("print_stacktrace")).tpe
    //let fun = predeclare_function(stderr_fun, std_module)
    //state.module.result.functions[stderr_fun.type_name] = fun

    state.module.imported.add(stderr_fun.type_name)
    state.module.imported.add(print_stacktrace_fun.type_name)
    import_cstd_function("fprintf", state)
    import_cstd_function("abort", state)

    var br: &Insn
    var fmt: Str
    var args: &[Value]

    if cond {
        let expr = convert_to(cond, walk_expression(cond, state), builtins::bool_, state)
        let if_false = make_label(state)
    
        br = make_insn_dbg(InsnKind::BR, loc)
        br.value.br = [
            cond = expr,
            if_false = if_false
        ] !InsnBr
        push_insn(br, state)

        push_label(if_false, state)

        if msg {
            args = allocate_ref(Value, 7)
            fmt = "%s:%d:%s: Assertion %s failed! %s\n"

            args(6) = charp_str(walk_and_load_expression(msg, state), state)
        } else {
            args = allocate_ref(Value, 6)
            fmt = "%s:%d:%s: Assertion %s failed!\n"
        }

        var msg: StringBuffer = ""
        var line = cond.loc.lines()(cond.loc.line)
        if cond.loc.end_line == cond.loc.line {
            msg += line.substring(cond.loc.column, min(line.length, cond.loc.end_column) !size_t) // TODO We get the wrong end_column, this should be fixed in lexer
        } else {
            msg += line.substring(cond.loc.column, line.length)
        }

        // TODO This doesn't work at all
        for var i in cond.loc.line..(cond.loc.end_line - 1) {
            msg += cond.loc.lines()(i)
        }
        if cond.loc.end_line > cond.loc.line {
            line = cond.loc.lines()(cond.loc.end_line)
            msg += line.substring(0, min(line.length, cond.loc.end_column) !size_t)
        }
    	
        args(5) = charp(msg, state)
    } else {
        args = allocate_ref(Value, 5)
        fmt = "%s:%d:%s: Unreachable!\n"
    }

    let stderr = make_local_value(builtins::File_, null, state)
    let mcall = make_insn_dbg(InsnKind::CALL, loc)
    mcall.value.call = [
        name = [
            kind = ValueKind::GLOBAL,
            name = stderr_fun.type_name
        ] !Value,
        ret = stderr,
        args = allocate_ref(Value, 0)
    ] !InsnCall
    push_insn(mcall, state)

    args(0) = stderr
    args(1) = charp(fmt, state)
    args(2) = charp(node.loc.filename, state)
    args(3) = [ kind = ValueKind::INT, tpe = builtins::int_, i = node.loc.line + 1 ] !Value

    var function_name: Str = "main"
    if state.current_function() {
        function_name = state.current_function().unmangled
    }

    args(4) = charp(function_name, state)
    
    let proto = allocate_ref(typechecking::NamedParameter, 3)
    proto(0) = [ _tpe = builtins::File_ ] !typechecking::NamedParameter
    proto(1) = [ _tpe = typechecking::pointer(builtins::char_) ] !typechecking::NamedParameter
    proto(2) = [ varargs = true ] !typechecking::NamedParameter

    let fprintf = make_insn_dbg(InsnKind::CALL, loc)
    fprintf.value.call = [
        name = [ kind = ValueKind::GLOBAL, name = "fprintf" ] !Value,
        ret = make_local_value(builtins::int_, null, state),
        args = args,
        proto = proto
    ] !InsnCall
    push_insn(fprintf, state)

    state.call(print_stacktrace_fun.type_name, null, [] ![Value], loc)

    let abort = make_insn_dbg(InsnKind::CALL, loc)
    abort.value.call = [
        name = [ kind = ValueKind::GLOBAL, name = "abort" ] !Value,
        ret = NO_VALUE,
        args = allocate_ref(Value, 0)
    ] !InsnCall
    push_insn(abort, state)

    let unreachable = make_insn(InsnKind::UNREACHABLE)
    push_insn(unreachable, state)
    
    let if_true = make_label(state)
    push_label(if_true, state)
    
    if cond {
        br.value.br.if_true = if_true
    }
}

export def walk(node: &parser::Node, state: &State) {
    let scpe = state.scope
    if node.scope {
        state.scope = node.scope
    }

    if not node { return }
    switch node.kind !int {
        case parser::NodeKind::DEF
            walk_Def(node, state)
        case parser::NodeKind::VAR_DECL
            walk_VarDecl(node, state)
        case parser::NodeKind::RETURN
            walk_Return(node, state)
        case parser::NodeKind::YIELD
            walk_Yield(node, state)
        case parser::NodeKind::YIELD_FROM
            walk_YieldFrom(node, state)
        case parser::NodeKind::BREAK
            walk_Break(node, state)
        case parser::NodeKind::CONTINUE
            walk_Continue(node, state)
        case parser::NodeKind::IF
            state.scope = node.inner_scope
            state.scope.clear_temporaries()
            walk_If(node, state)
            state.scope = node.scope
        case parser::NodeKind::SWITCH
            walk_Switch(node, state)
        case parser::NodeKind::LOOP
            state.scope = node.inner_scope
            state.scope.clear_temporaries()
            walk_Loop(node, state)
            state.scope = node.scope
        case parser::NodeKind::WHILE
            state.scope = node.inner_scope
            state.scope.clear_temporaries()
            walk_While(node, state)
            state.scope = node.scope
        case parser::NodeKind::FOR
            state.scope = node.inner_scope
            state.scope.clear_temporaries()
            walk_For(node, state)
            state.scope = node.scope
        case parser::NodeKind::DEFER
            walk_Defer(node, state)
        case parser::NodeKind::ASSERT
            walk_Assert(node, state)
        case parser::NodeKind::TYPE_DECL
            walk_TypeDecl(node, state)
        case parser::NodeKind::FROM
            // Do nothing
        case 
            walk_expression(node, state)
    }
    state.scope = scpe
}

def di_basic_type(tpe: &typechecking::Type, name: Str, c: Str, state: &State) -> &Value {
    let debug_values = allocate_ref(DebugParam, 4)
    debug_values(0) = [
        name = "name", value = [ kind = DebugValueKind::STRING, s = name ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "size", value = [ kind = DebugValueKind::INT, i = tpe.size * 8 ] !DebugValue
    ] !DebugParam
    debug_values(2) = [
        name = "align", value = [ kind = DebugValueKind::INT, i = tpe.align * 8 ] !DebugValue
    ] !DebugParam
    debug_values(3) = [
        name = "encoding", value = [ kind = DebugValueKind::CONST, name = c ] !DebugValue
    ] !DebugParam
    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DIBasicType",
        debug_values = debug_values
    ] !&Value
    return di
}

def di_composite_type(value: &Value, tpe: &typechecking::Type, name: Str, c: Str, state: &State) -> &Value {
    let elementsarr = allocate_ref(Value, tpe.fields.size)
    for var i in 0..tpe.fields.size {
        let elem = tpe.fields(i)
        let debug_values = allocate_ref(DebugParam, 8)
        debug_values(0) = [
            name = "tag", value = [ kind = DebugValueKind::CONST, name = "DW_TAG_member" ] !DebugValue
        ] !DebugParam
        debug_values(1) = [
            name = "name", value = [ kind = DebugValueKind::STRING, s = elem.name if elem.name else to_string(i).to_str() ] !DebugValue
        ] !DebugParam
        debug_values(2) = [
            name = "scope", value = meta_to_debug_value(value)
        ] !DebugParam
        debug_values(3) = [
            name = "file", value = meta_to_debug_value((@state).difile)
        ] !DebugParam
        debug_values(4) = [
            name = "line", value = [ kind = DebugValueKind::INT, i = elem.line + 1 ] !DebugValue
        ] !DebugParam
        debug_values(5) = [
            name = "baseType", value = meta_to_debug_value(di_type(elem.tpe, state))
        ] !DebugParam
        debug_values(6) = [
            name = "size", value = [ kind = DebugValueKind::INT, i = (@elem.tpe).size * 8 ] !DebugValue
        ] !DebugParam
        let type_member = tpe.field_types(elem.index)
        debug_values(7) = [
            name = "offset", value = [ kind = DebugValueKind::INT, i = type_member.offset * 8 ] !DebugValue
        ] !DebugParam

        let di = [
            kind = ValueKind::DEBUG_INFO,
            name = "DIDerivedType",
            debug_values = debug_values
        ] !&Value
        elementsarr(i) = @push_meta(di, state)
    }
    
    let elements = [
        kind = ValueKind::STRUCT,
        metadata = true,
        values = elementsarr
    ] !&Value
    let elementsp = push_meta(elements, state)

    let debug_values = allocate_ref(DebugParam, 6)
    debug_values(0) = [
        name = "tag", value = [ kind = DebugValueKind::CONST, name = c ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "file", value = meta_to_debug_value((@state).difile)
    ] !DebugParam
    debug_values(2) = [
        name = "line", value = [ kind = DebugValueKind::INT, i = tpe.line + 1 ] !DebugValue
    ] !DebugParam
    debug_values(3) = [
        name = "size", value = [ kind = DebugValueKind::INT, i = tpe.size * 8 ] !DebugValue
    ] !DebugParam
    debug_values(4) = [
        name = "elements", value = meta_to_debug_value(elementsp)
    ] !DebugParam
    debug_values(5) = [
        name = "name", value = [ kind = DebugValueKind::STRING, s = name ] !DebugValue
    ] !DebugParam

    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DICompositeType",
        debug_values = debug_values
    ] !&Value
    return di
}

def di_forward_declare(tpe: &typechecking::Type, name: Str, state: &State) -> &Value {
    let debug_values = allocate_ref(DebugParam, 5)
    debug_values(0) = [
        name = "tag", value = [ kind = DebugValueKind::CONST, name = "DW_TAG_structure_type" ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "file", value = meta_to_debug_value((@state).difile)
    ] !DebugParam
    debug_values(2) = [
        name = "line", value = [ kind = DebugValueKind::INT, i = tpe.line + 1 ] !DebugValue
    ] !DebugParam
    debug_values(3) = [
        name = "name", value = [ kind = DebugValueKind::STRING, s = name ] !DebugValue
    ] !DebugParam
    debug_values(4) = [
        name = "flags", value = [ kind = DebugValueKind::CONST, name = "DIFlagFwdDecl" ] !DebugValue
    ] !DebugParam

    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DICompositeType",
        debug_values = debug_values
    ] !&Value
    return di
}

def di_subroutine_type(tpe: &typechecking::Type, state: &State) -> &Value {
    let values = allocate_ref(Value, vector::length(tpe.parameter_t) + 1)

    var ret_tpe: &typechecking::Type = null
    if vector::length(tpe.return_t) > 1 {
        ret_tpe = make_return_type(tpe)
    } else if vector::length(tpe.return_t) == 1 {
        ret_tpe = tpe.return_t(0)
    }

    if ret_tpe {
        values(0) = @di_type(ret_tpe, state)
    } else {
        values(0) = NO_VALUE
    }

    for var i in 0..vector::length(tpe.parameter_t) {
        let np = tpe.parameter_t(i)
        values(i + 1) = @di_type(np.tpe, state)
    }

    let types = [
        kind = ValueKind::STRUCT,
        metadata = true,
        values = values
    ] !&Value
    let typesp = push_meta(types, state)

    let debug_values = allocate_ref(DebugParam, 1)
    debug_values(0) = [
        name = "types", value = meta_to_debug_value(typesp)
    ] !DebugParam

    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DISubroutineType",
        debug_values = debug_values
    ] !&Value

    return push_meta(di, state)
}

def di_function_type(tpe: &typechecking::Type, state: &State) -> &Value {
    let diftpe = di_subroutine_type(tpe, state)

    let debug_values = allocate_ref(DebugParam, 3)
    debug_values(0) = [
        name = "tag", value = [ kind = DebugValueKind::CONST, name = "DW_TAG_pointer_type" ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "baseType", value = meta_to_debug_value(diftpe)
    ] !DebugParam
    debug_values(2) = [
        name = "size", value = [ kind = DebugValueKind::INT, i = (size_of type def [] -> []) * 8 ] !DebugValue
    ] !DebugParam

    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DIDerivedType",
        debug_values = debug_values
    ] !&Value
    return di
}

def di_pointer_type(tpe: &typechecking::Type, state: &State) -> &Value {
    let debug_values = allocate_ref(DebugParam, 3)
    debug_values(0) = [
        name = "tag", value = [ kind = DebugValueKind::CONST, name = "DW_TAG_pointer_type" ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "baseType", value = meta_to_debug_value(di_type(tpe.tpe, state))
    ] !DebugParam
    debug_values(2) = [
        name = "size", value = [ kind = DebugValueKind::INT, i = (size_of type *) * 8 ] !DebugValue
    ] !DebugParam

    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DIDerivedType",
        debug_values = debug_values
    ] !&Value
    return di
}

// TODO More dimensions
def di_static_array_type(tpe: &typechecking::Type, state: &State) -> &Value {
    
    let debug_values1 = allocate_ref(DebugParam, 1)
    debug_values1(0) = [
        name = "count", value = [ kind = DebugValueKind::INT, i = tpe.length ] !DebugValue
    ] !DebugParam
    let value = [
        kind = ValueKind::DEBUG_INFO,
        name = "DISubrange",
        debug_values = debug_values1
    ] !&Value

    let values = allocate_ref(Value, 1)
    values(0) = @push_meta(value, state)
    let elements = [
        kind = ValueKind::STRUCT,
        metadata = true,
        values = values
    ] !&Value

    let debug_values = allocate_ref(DebugParam, 4)
    debug_values(0) = [
        name = "tag", value = [ kind = DebugValueKind::CONST, name = "DW_TAG_array_type" ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "baseType", value = meta_to_debug_value(di_type(tpe.tpe, state))
    ] !DebugParam
    debug_values(2) = [
        name = "size", value = [ kind = DebugValueKind::INT, i = tpe.size * 8 ] !DebugValue
    ] !DebugParam
    debug_values(3) = [
        name = "elements", value = meta_to_debug_value(push_meta(elements, state))
    ] !DebugParam

    let di = [
        kind = ValueKind::DEBUG_INFO,
        name = "DICompositeType",
        debug_values = debug_values
    ] !&Value
    return di
}

def di_array_type(value: &Value, tpe: &typechecking::Type, state: &State) -> &Value {
    // TODO This should probably be an array type instead (see documentation)
    let fields = allocate_ref(typechecking::StructMember, 2)
    fields(0) = [ name = "size", tpe = builtins::size_t_ ] !typechecking::StructMember
    fields(1) = [ name = "value", tpe = typechecking::pointer(tpe.tpe) ] !typechecking::StructMember
    return di_composite_type(value, typechecking::make_struct_type(fields), "<array>", "DW_TAG_structure_type", state)
}

def di_ref_type(value: &Value, tpe: &typechecking::Type, is_weak: bool, state: &State) -> &Value {
    let fields = allocate_ref(typechecking::StructMember, 3)
    fields(0) = [ name = "ref_count", tpe = typechecking::pointer(builtins::int64_) ] !StructMember
    fields(1) = [ name = "value", tpe = typechecking::pointer(tpe.tpe) ] !StructMember
    fields(2) = [ name = "tpe", tpe = typechecking::pointer(builtins::Type_) ] !StructMember
    let ref = typechecking::make_struct_type(fields)
 
    return di_composite_type(value, ref, "<weak_ref>" if is_weak else "<ref>", "DW_TAG_structure_type", state)
}

def di_type(tpe: &typechecking::Type, state: &State) -> &Value {
    if not tpe or tpe.kind == typechecking::TypeKind::STRUCTURAL or 
        tpe.kind == typechecking::TypeKind::TYPE_CONSTRUCTOR { 
        return null 
    }

    let anonymous = tpe.type_name == null
    var ditpe = state.ditypes.get_or_default(tpe, null)
    if ditpe { return ditpe }

    var name = tpe.type_name
    if anonymous {
        name = "<anonymous>"
    }

    if tpe.kind == typechecking::TypeKind::INTERFACE_IMPL {
        return di_type(tpe.tpe, state)
    }

    ditpe = [] !&Value
    let ditpep = push_meta(ditpe, state)
    (@state).ditypes(tpe) = ditpep

    if tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.weak
    }
    switch tpe.kind !int {
        // TODO compare with char for special casing
        case typechecking::TypeKind::WORD
            if tpe.unsig {
                @ditpe = @di_basic_type(tpe, name, "DW_ATE_unsigned", state)
            } else {
                @ditpe = @di_basic_type(tpe, name, "DW_ATE_signed", state)
            }
        case typechecking::TypeKind::CHAR
            @ditpe = @di_basic_type(tpe, name, "DW_ATE_unsigned", state)
        case typechecking::TypeKind::FLOAT
            @ditpe = @di_basic_type(tpe, name, "DW_ATE_float", state)
        case typechecking::TypeKind::BOOL
            @ditpe = @di_basic_type(tpe, name, "DW_ATE_unsigned", state)
        case typechecking::TypeKind::STRUCT, typechecking::TypeKind::CLOSURE
            @ditpe = @di_composite_type(ditpep, tpe, name, "DW_TAG_structure_type", state)
        case typechecking::TypeKind::TUPLE
            // TODO Do this without creating a new type
            let fields = allocate_ref(typechecking::StructMember, tpe.return_t.length)
            for var i in 0..tpe.return_t.length {
                fields(i) = [ tpe = tpe.return_t(i), name = "_" + i ] !typechecking::StructMember
            }
            @ditpe = @di_composite_type(ditpep, make_struct_type(fields), name, "DW_TAG_structure_type", state)
        case typechecking::TypeKind::UNION
            @ditpe = @di_composite_type(ditpep, tpe, name, "DW_TAG_union_type", state)
        case typechecking::TypeKind::ENUM
            // TODO Use enumeration type
            if (@tpe.tpe).unsig {
                @ditpe = @di_basic_type(tpe.tpe, name, "DW_ATE_unsigned", state)
            } else {
                @ditpe = @di_basic_type(tpe.tpe, name, "DW_ATE_signed", state)
            }
        case typechecking::TypeKind::FUNCTION
            @ditpe = @di_function_type(tpe, state)
        case typechecking::TypeKind::POINTER
            @ditpe = @di_pointer_type(tpe, state)
        case typechecking::TypeKind::REFERENCE, typechecking::TypeKind::WEAK_REF
            @ditpe = @di_ref_type(ditpep, tpe, tpe.kind == typechecking::TypeKind::WEAK_REF, state)
        case typechecking::TypeKind::STATIC_ARRAY
            @ditpe = @di_static_array_type(tpe, state)
        case typechecking::TypeKind::ARRAY
            @ditpe = @di_array_type(ditpep, tpe, state)
        case typechecking::TypeKind::STUB
            @ditpe = @di_forward_declare(tpe, name, state)
        case typechecking::TypeKind::TYPE
            @ditpe = @di_composite_type(ditpep, builtins::Type_, "<type>", "DW_TAG_structure_type", state)
        case typechecking::TypeKind::TUNION
            let members = allocate_ref(StructMember, 2)
            members(0) = [ tpe = pointer(builtins::Type_), name = "tpe" ] !StructMember
            members(1) = [ tpe = tpe.tpe, name = "union" ] !StructMember
            @ditpe = @di_composite_type(ditpep, typechecking::make_struct_type(members), "<tagged_union>", "DW_TAG_structure_type", state)
        case
            error(tpe.kind, "\n") 
            assert(false)
    }
    return ditpep
}

def generate_defer_types_pre(state: &State) {
    let function = state.current_function
    if not function.has_defer { return }
    
    function.env = [] !&typechecking::Type
    function.defers = [] !&typechecking::Type
    let defers = function.defers

    // Generate defer stack
    if not function.is_global {
        let alloca = make_insn(InsnKind::ALLOCA)
        alloca.value.alloca = [
            ret = [ kind = ValueKind::LOCAL, tpe = typechecking::pointer(defers), name = "__defers" ] !Value
        ] !InsnAlloca
        push_insn(alloca, state)
    } else {
        let global = [
            private = true,
            name = "__defers",
            tpe = typechecking::pointer(defers)
        ] !&Global
        state.module.result.globals(global.name) = global
    }

    let store = make_insn(InsnKind::STORE)
    store.value.store = [
        value = [ kind = ValueKind::NULL, tpe = typechecking::pointer(defers) ] !Value,
        loc = [ kind = ValueKind::GLOBAL if function.is_global else ValueKind::LOCAL, 
            tpe = typechecking::pointer(typechecking::pointer(defers)), name = "__defers" 
        ] !Value
    ] !InsnStore
    push_insn(store, state)
}

def generate_defer_types_post(state: &State) {
    let function = state.current_function
    if not function.has_defer { return }

    let env_name = function.name + ".env"
    let env_fields = allocate_ref(typechecking::StructMember, map::size(function.locals))

    let keys = map::keys(function.locals)
    for var i in 0..keys.size {
        let tpe = function.locals(keys(i))
        env_fields(i) = [
            tpe = tpe
        ] !typechecking::StructMember
    }
    
    let env = typechecking::make_struct_type(env_fields)
    env.type_name = env_name

    state.module.result.structures(env_name) = env
    @function.env = @env

    let defers_name = function.name + ".defers"
    let defers_fields = allocate_ref(typechecking::StructMember, 3)

    defers_fields(0) = [
        tpe = env
    ] !typechecking::StructMember

    let defer_function = typechecking::make_type_raw(typechecking::TypeKind::FUNCTION)
    defer_function.parameter_t = vector::make(typechecking::NamedParameter)
    defer_function.parameter_t.push([
        _tpe = typechecking::pointer(env)
    ] !typechecking::NamedParameter)
    defer_function.return_t = vector::make(type &typechecking::Type)
    defer_function.align = align_of type def ->
    defer_function.size = size_of type def ->
    
    let defer_functionp = typechecking::pointer(defer_function)
    defers_fields(1) = [
        tpe = defer_functionp
    ] !typechecking::StructMember

    let defersp = typechecking::pointer(null)

    defers_fields(2) = [
        tpe = defersp
    ] !typechecking::StructMember

    let defers = typechecking::make_struct_type(defers_fields)
    defers.type_name = defers_name
    defersp._tpe = typechecking::box(defers)
    state.module.result.structures(defers_name) = defers

    @function.defers = @defers
}

def defer_unroll(node: &parser::Node, state: &State) {
    var previous_block = state.current_block
    
    if state.current_function.is_global {
        state.current_block = state.finalizer.block
    }

    let parameter_t = vector::make(typechecking::NamedParameter)
    parameter_t.push([
        name = "__env",
        _tpe = typechecking::pointer(state.current_function.env)
    ] !typechecking::NamedParameter)

    let tpe = typechecking::make_function_type_n(parser::make_identifier("defer"), parameter_t, vector::make(type &typechecking::Type))

    let br_to_start = make_insn(InsnKind::BR_UNC)
    push_insn(br_to_start, state)

    let start_label = make_label(state)
    push_label(start_label, state)
    br_to_start.value.br_unc.label_ = start_label

    let current_defer_ret = make_local_value(typechecking::pointer(state.current_function.defers), null, state)
    let current_defer = make_insn(InsnKind::LOAD)
    current_defer.value.load = [
        value = current_defer_ret,
        loc = [ kind = ValueKind::GLOBAL if state.current_function.is_global else ValueKind::LOCAL, 
            tpe = typechecking::pointer(typechecking::pointer(state.current_function.defers)), 
            name = "__defers" 
        ] !Value 
    ] !InsnLoad
    push_insn(current_defer, state)

    let ptr_to_int_ret = make_local_value(builtins::int64_, null, state)
    let ptr_to_int = make_insn(InsnKind::PTRTOINT)
    ptr_to_int.value.convert = [
        ret = ptr_to_int_ret,
        value = current_defer_ret
    ] !InsnConvert
    push_insn(ptr_to_int, state)

    let icmp_ret = make_local_value(builtins::bool_, null, state)
    let icmp = make_insn(InsnKind::ICMP)
    icmp.value.icmp = [
        op = CompareInt::ne,
        ret = icmp_ret,
        left = ptr_to_int_ret,
        right = [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value
    ] !InsnIcmp
    push_insn(icmp, state)

    let br = make_insn(InsnKind::BR)
    br.value.br.cond = icmp_ret
    push_insn(br, state)

    let label_body = make_label(state)
    push_label(label_body, state)
    br.value.br.if_true = label_body

    let index1 = allocate_ref(Value, 2)
    index1(0) = make_int_value(0)
    index1(1) = make_int_value(0)
    let gep_env_ret = make_local_value(typechecking::pointer(state.current_function.env), null, state)
    let gep_env = make_insn(InsnKind::GETELEMENTPTR)
    gep_env.value.gep = [
        ret = gep_env_ret,
        tpe = state.current_function.defers,
        value = current_defer_ret,
        index = index1
    ] !InsnGetElementPtr
    push_insn(gep_env, state)

    let index2 = allocate_ref(Value, 2)
    index2(0) = make_int_value(0)
    index2(1) = make_int_value(1)
    let gep_fun_ret = make_local_value(typechecking::pointer(typechecking::pointer(tpe)), null, state)
    let gep_fun = make_insn(InsnKind::GETELEMENTPTR)
    gep_fun.value.gep = [
        ret = gep_fun_ret,
        tpe = state.current_function.defers,
        value = current_defer_ret,
        index = index2
    ] !InsnGetElementPtr
    push_insn(gep_fun, state)

    let index3 = allocate_ref(Value, 2)
    index3(0) = make_int_value(0)
    index3(1) = make_int_value(2)
    let gep_defer_ret = make_local_value(typechecking::pointer(typechecking::pointer(state.current_function.defers)), null, state)
    let gep_defer = make_insn(InsnKind::GETELEMENTPTR)
    gep_defer.value.gep = [
        ret = gep_defer_ret,
        tpe = state.current_function.defers,
        value = current_defer_ret,
        index = index3
    ] !InsnGetElementPtr
    push_insn(gep_defer, state)

    let load_fun_ret = make_local_value(typechecking::pointer(tpe), null, state)
    let load_fun = make_insn(InsnKind::LOAD)
    load_fun.value.load = [
        value = load_fun_ret,
        loc = gep_fun_ret
    ] !InsnLoad
    push_insn(load_fun, state)

    let load_defer_ret = make_local_value(typechecking::pointer(state.current_function.defers), null, state)
    let load_defer = make_insn(InsnKind::LOAD)
    load_defer.value.load = [
        value = load_defer_ret,
        loc = gep_defer_ret
    ] !InsnLoad
    push_insn(load_defer, state)

    let args = allocate_ref(Value, 1)
    args(0) = gep_env_ret
    let call_ = make_insn_dbg(InsnKind::CALL, make_location(node, state))
    call_.value.call = [
        name = load_fun_ret,
        ret = NO_VALUE,
        args = args
    ] !InsnCall
    push_insn(call_, state)

    let store_env = make_insn(InsnKind::STORE)
    store_env.value.store = [
        value = load_defer_ret,
        loc = [ kind = ValueKind::GLOBAL if state.current_function.is_global else ValueKind::LOCAL, 
            tpe = typechecking::pointer(typechecking::pointer(state.current_function.defers)),
            name = "__defers"
        ] !Value
    ] !InsnStore
    push_insn(store_env, state)

    if state.current_function.is_global {
        import_cstd_function("free", state)
        let bitcast = state.bitcast(pointer(builtins::int8_), current_defer_ret)
        state.call("free", null, [bitcast])
    }

    push_insn(br_to_start, state)

    let label_end = make_label(state)
    push_label(label_end, state)
    br.value.br.if_false = label_end

    if state.current_function.is_global {
        state.finalizer.block = state.current_block
        state.current_block = previous_block
    }
}

export def insert_function(module: &toolchain::Module, function: &Function, overwrite: bool = false) {
    if not function.name { return }
    if module.result.functions.contains(function.name) and not overwrite { return }

    module.result.functions(function.name) = function
    if not consteval::const_module.result.functions.contains(function.name) {
        consteval::const_module.result.functions(function.name) = function
    }
} 

export def predeclare_function(tpe: &typechecking::Type, module: &toolchain::Module) -> &Function {
    if not tpe { return null }
    var function = module.result.functions.get_or_default(tpe.type_name, null)
    if function {
        return function 
    } else {
        function = [ 
            tpe = tpe,
            module = module
        ] !&Function
    }
    predeclare_function(function)
    return function
}

export def predeclare_function(function: &Function, overwrite: bool = false) {
    let tpe = function.tpe
    
    function.name = tpe.type_name
    function.unmangled = tpe.name
    function.forward_declare = true
    if not function.allocas {
        function.allocas = vector::make(type &Insn)
    }
    function.function_locals = set::make()

    if vector::length(tpe.parameter_t) > 0 {
        let last_parameter = vector::peek(tpe.parameter_t)
        if last_parameter.varargs and not last_parameter.tpe {
            function.varargs = true
        }
    }
    
    if vector::length(tpe.return_t) > 1 {
        function.ret = make_return_type(tpe)
        function.multiple_returns = true
    } else if vector::length(tpe.return_t) == 1 {
        function.ret = vector::peek(tpe.return_t)
    }

    function.args = vector::make(typechecking::NamedParameter)
    for var i in 0..vector::length(tpe.parameter_t) {
        let np = tpe.parameter_t(i)
        if not np.tpe or np.tpe.kind != typechecking::TypeKind::TYPE {
           function.args.push(np)
        }
    }

    insert_function(function.module, function, overwrite)
}

def create_debug_info(node: &parser::Node, function: &Function, tpe: &typechecking::Type, state: &State) {
    if not toolchain::debug_sym { return }

    var line = -1
    if node { line = node.loc.line }

    let debug_values = allocate_ref(DebugParam, 7)
    debug_values(0) = [
        name = "name", value = [ kind = DebugValueKind::STRING, s = (@function).name ] !DebugValue
    ] !DebugParam
    debug_values(1) = [
        name = "scope", value = meta_to_debug_value(vector::peek((@state).discope))
    ] !DebugParam
    debug_values(2) = [
        name = "file", value = meta_to_debug_value((@state).difile)
    ] !DebugParam
    debug_values(3) = [
        name = "line", value = [ kind = DebugValueKind::INT, i = line + 1 ] !DebugValue
    ] !DebugParam
    debug_values(4) = [
        name = "type", value = meta_to_debug_value(di_subroutine_type(tpe, state))
    ] !DebugParam
    debug_values(5) = [
        name = "scopeLine", value = [ kind = DebugValueKind::INT, i = line + 1 ] !DebugValue
    ] !DebugParam
    debug_values(6) = [
        name = "unit", value = meta_to_debug_value((@state).diunit)
    ] !DebugParam

    let disub = [
        kind = ValueKind::DEBUG_INFO,
        name = "DISubprogram",
        distinct = true,
        debug_values = debug_values
    ] !&Value
    let disubp = push_meta(disub, state)
    (@function).debug = disubp

    (@state).discope.push(disubp)
}

def create_free_context(function: &Function, state: &State) {
    import_cstd_function("free", state)

    let context = function.context
    let context_ptr_i8 = [ kind = ValueKind::LOCAL, name = "__context.value", tpe = pointer(null) ] !Value
    let context_ptr = state.bitcast(pointer(context), context_ptr_i8)

    let index_ptr = state.gep(pointer(builtins::int_), context, context_ptr, [make_int_value(0), make_int_value(0)])
    let index = state.load(builtins::int_, index_ptr)

    let switch_values = vector::make(SwitchValue)
    let insn_switch = make_insn(InsnKind::SWITCH)
    insn_switch.value.switch_ = [
        switch_values = switch_values,
        value = index
    ] !InsnSwitch
    push_insn(insn_switch, state)

    let snapshots = function.snapshots
    for var i in 0..snapshots.length {
        let label_ = state.make_label()
        push_label(label_, state)
        switch_values.push([
            value = make_int_value(i),
            label_ = label_
        ] !SwitchValue)

        let snapshot = snapshots(i)
        for var key in @snapshot.keys() {
            let j = snapshot(key)
            let field_type = context.field_types(j).tpe
            let local_ptr = state.gep(pointer(field_type), context, context_ptr, [make_int_value(0), make_int_value(j)])
            insert_destructor(local_ptr, null, state)
        }
        state.ret(NO_VALUE)
    }

    let end = state.make_label()
    push_label(end, state)
    insn_switch.value.switch_.otherwise = end 
    state.ret(NO_VALUE)
}

def create_generator(
    impl: &typechecking::Type, 
    free_context: &typechecking::Type, 
    tpe: &typechecking::Type, 
    generator: &typechecking::Type, 
    context: &typechecking::Type, 
    state: &State
) {
    import_cstd_function("calloc", state)

    let context_ptr_i8 = state.call("calloc", typechecking::pointer(builtins::int8_), [
        [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value,
        [ kind = ValueKind::INT, tpe = builtins::size_t_, i = context.size ] !Value
    ])
    let context_ptr = state.bitcast(pointer(context), context_ptr_i8)

    for var i in 0..tpe.parameter_t.length {
        let par = tpe.parameter_t(i)
        let local_ptr = state.gep(pointer(par.tpe), context, context_ptr, [make_int_value(0), make_int_value(i + 1)])
        state.store(local_ptr, [ kind = ValueKind::LOCAL, name = par.name + ".value", tpe = par.tpe ] !Value)
        
        if typechecking::is_ref(par.tpe) {
            increase_ref_count(local_ptr, null, state)
        }
    }

    let gen_ptr_i8 = state.call("calloc", typechecking::pointer(builtins::int8_), [
        [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value,
        [ kind = ValueKind::INT, tpe = builtins::size_t_, i = generator.size ] !Value
    ])
    let gen_ptr = state.bitcast(pointer(generator), gen_ptr_i8)
    
    let gen_context_ptr = state.gep(pointer(generator.fields(0).tpe), generator, gen_ptr, [make_int_value(0), make_int_value(0)])
    state.store(gen_context_ptr, [ kind = ValueKind::GLOBAL, name = impl.type_name, tpe = pointer(impl) ] !Value)
    let free_context_ptr = state.gep(pointer(generator.fields(2).tpe), generator, gen_ptr, [make_int_value(0), make_int_value(2)])
    state.store(free_context_ptr, [ kind = ValueKind::GLOBAL, name = free_context.type_name, tpe = pointer(free_context) ] !Value)

    let context_ptr_i8_ptr = state.gep(pointer(generator.fields(1).tpe), generator, gen_ptr, [make_int_value(0), make_int_value(1)])
    state.store(context_ptr_i8_ptr, context_ptr_i8)
    
    let ref_count_ptr_i8 = state.call("malloc", typechecking::pointer(builtins::int8_), [
        [ kind = ValueKind::INT, tpe = builtins::size_t_, i = builtins::size_t_.size ] !Value
    ])
    let ref_count = state.bitcast(pointer(builtins::size_t_), ref_count_ptr_i8)
    state.store(ref_count, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value)

    var gen_ref = [ kind = ValueKind::ZEROINITIALIZER, tpe = reference(generator) ] !Value
    gen_ref = state.insert_value(reference(generator), gen_ref, ref_count, [0])
    gen_ref = state.insert_value(reference(generator), gen_ref, gen_ptr, [1])

    let svalue = do_create_type(reference(generator), state.module)
    gen_ref = state.insert_value(reference(generator), gen_ref, svalue, [2])

    state.ret(gen_ref)
}

def inline_call(node: &parser::Node, function: &Function, tpe: &typechecking::Type, args: &[Value], state: &State) -> Value {
    let name = node.value.def_.name
    let body = node.value.def_.body
    if not function or not function.tpe { return NO_VALUE }

    for var i in 0..state.function_stack.length {
        let fun = state.function_stack(i)
        if not fun.tpe { return NO_VALUE }
        if fun.tpe.type_name == function.tpe.type_name {
            errors::errorn(name, "Could not inline function, recursion detected. Try to use #no_inline.")
            return NO_VALUE
        }
    }

    if function.has_yield {
        errors::errorn(name, "Can't inline function that yields values")
        return NO_VALUE
    }
    if function.is_closure {
        errors::errorn(name, "Can't inline function that is a closure values")
        return NO_VALUE
    }

    let prefix = state.prefix
    state.prefix = state.prefix + "." + state.inline_offset
    state.inline_offset += 1
    let return_address = state.return_address
    let return_br = state.return_br

    state.return_address = state.alloca(tpe)
    state.return_br = make_insn(InsnKind::BR_UNC)

    // Set up arguments
    function.locals = map::make(Str, type &typechecking::Type)
    if node.value.def_.params {
        var j = 0
        for var i in 0..vector::length(node.value.def_.params) {
            let param = node.value.def_.params(i).value.param.name
            let svalue = param.svalue
            if not svalue { continue }
            state.add_local(function, svalue, svalue.tpe)
            let loc = make_location(param, state)

            let addr = [ kind = ValueKind::LOCAL, name = svalue.assembly_name(state), tpe = svalue.tpe ] !Value
            let alloca = make_insn(InsnKind::ALLOCA)
            alloca.value.alloca = [
                ret = addr
            ] !InsnAlloca
            push_alloca(alloca, state)
            addr.tpe = pointer(addr.tpe)

            state.store(addr, args(j), loc)

            j += 1
        }
    }

    state.scope = node.inner_scope
    state.scope.clear_temporaries()

    state.function_stack.push(function)
    function.allocas = vector::make(type &Insn)
    
    var last_node: &Node = node
    for var i in 0..vector::length(body) {
        let node = body(i)
        walk(node, state)
        last_node = node
    }

    insert_destructors(node.inner_scope, make_location(last_node, state), state)
    state.current_block.counter += 1
    push_insn(state.return_br, state)

    vector::insert(state.inline_start_block.insn, 0, function.allocas)

    state.function_stack.pop()

    let at_end = make_label(state)
    push_label(at_end, state)
    state.return_br.value.br_unc.label_ = at_end

    var res = NO_VALUE
    if tpe {
        res = state.load(tpe, state.return_address)
    }

    state.prefix = prefix
    state.return_address = return_address
    state.return_br = return_br

    return res
}

// block and body may be null
export def create_function(
    node: &parser::Node, 
    tpe: &typechecking::Type, 
    body: &Vector(&parser::Node), 
    scpe: &scope::Scope, 
    block: &Block,
    state: &State,
    no_cleanup: bool = false,
    is_closure: bool = false,
    params: &Vector(&Node) = null
) {
    if not tpe { return }
    let function = state.module.result.functions.get_or_default(tpe.type_name, null)
    if not function { return }
    // TODO Return multiple values via tuple
    if function.has_yield and (not function.ret or function.ret.kind == typechecking::TypeKind::TUPLE) { return }
    if not block {
        block = make_block()
    }

    debug::trace("Compiling function " + function.name)

    function.forward_declare = false
    function.allocas = vector::make(type &Insn)
    let current_fun = errors::current_function
    let current_signature = errors::current_signature
    let previous_inline_offset = state.inline_offset
    state.inline_offset = 0
    let previous_inline_start_block = state.inline_start_block
    state.inline_start_block = block

    function.locals = map::make(Str, type &typechecking::Type)
    if params {
        for var i in 0..vector::length(params) {
            let param = params(i).value.param.name
            if not param or not param.svalue { continue }
            state.add_local(function, param.svalue, param.svalue.tpe)
        }
    }

    if body {
        errors::current_function = tpe.type_name
        if node { errors::current_signature = node.signature_hash }
        
        let original_ret = function.ret
        var generator: &typechecking::Type

        function.all_locals = map::make(type &typechecking::Type)
        if function.has_yield {
            // Set up snapshots
            function.current_snapshot = vector::make(type &SMap(int))
            function.current_snapshot.push(map::make(int))
            function.snapshots = vector::make(type &SMap(int))
        }
        function.used_type_meta = set::make(type &typechecking::Type)

        if function.has_yield {
            assert node != null
            generator = tpe.return_t(0).tpe

            let option_ctor = [
                kind = parser::NodeKind::TYPE_CONSTRUCTOR
            ] !&parser::Node
            option_ctor.value.type_constructor = [
                name = parser::make_identifier("optional", "Optional"),
                args = node.value.def_.returns
            ] !parser::NodeTypeConstructor

            state.module.state.scope = node.inner_scope
            function.optional = typechecking::type_lookup(option_ctor, state.module.state)

            function.context = typechecking::make_type_raw(typechecking::TypeKind::STUB)
            function.yield_index = 1
        }

        if is_closure {
            add_type_meta(reference(function.state), state)
        }

        import_structures(tpe, state.module)
        state.module.imported.add(tpe.type_name)
        create_debug_info(node, function, tpe, state)

        state.function_stack.push(function)

        // Add metadata for return type and arguments
        for var i in 0..tpe.return_t.length {
            add_type_meta(tpe.return_t(i), state)
        }
        for var i in 0..tpe.parameter_t.length {
            add_type_meta(tpe.parameter_t(i).tpe, state)
        }

        if params { 
            errors::current_signature = node.signature_hash 
            for var i in 0..vector::length(params) {
                let param = params(i).value.param.name
                if not param { continue }
                scope::create_dependency(state.current_value(), param.svalue)
            }
        }

        function.block = block
        let previous_block = state.current_block
        state.current_block = block

        let previous_counter = state.local_counter
        state.local_counter = 0
        let previous_scope = state.scope
        state.scope = scpe
        state.scope.clear_temporaries()

        var generator_type: &typechecking::Type
        if function.has_yield {
            let generator_ctor = [
                kind = parser::NodeKind::TYPE_CONSTRUCTOR
            ] !&parser::Node
            generator_ctor.value.type_constructor = [
                name = parser::make_identifier("runtime", "Generator"),
                args = node.value.def_.returns
            ] !parser::NodeTypeConstructor

            generator_type = reference(typechecking::type_lookup(generator_ctor, state.module.state))

            let generator_ptr = [ kind = ValueKind::LOCAL, name = "__generator", tpe = pointer(generator_type.tpe) ] !Value
            let deref = make_insn(InsnKind::EXTRACTVALUE)
            deref.value.extract_value = [
                ret = generator_ptr,
                value = [ kind = ValueKind::LOCAL, name = "__context.value", tpe = generator_type ] !Value,
                index = [1]
            ] !InsnExtractValue
            function.allocas.push(deref)

            let generator = make_local_value(generator_type.tpe, null, state)
            let load = make_insn(InsnKind::LOAD)
            load.value.load = [
                loc = generator_ptr,
                value = generator
            ] !InsnLoad
            function.allocas.push(load)

            let context = make_local_value(pointer(null), null, state)
            let ev = make_insn(InsnKind::EXTRACTVALUE)
            ev.value.extract_value = [
                ret = context,
                value = generator,
                index = [1]
            ] !InsnExtractValue
            function.allocas.push(ev)

            let context_cast = make_insn(InsnKind::BITCAST)
            context_cast.value.convert = [
                ret = [ kind = ValueKind::LOCAL, name = "__context", tpe = pointer(function.context) ] !Value,
                value = context
            ] !InsnConvert
            function.allocas.push(context_cast)
        }

        if is_closure {
            let context_ptr_i8 = state.extract_value(pointer(null), [
                kind = ValueKind::LOCAL,
                tpe = typechecking::reference(null),
                name = "__state.value"
            ] !Value, [1])
            let context_ptr = state.bitcast(pointer(function.state), context_ptr_i8)
            let context = state.load(function.state, context_ptr)

            import_structure(function.state, state.module)
            state.module.imported.add(function.state.type_name)

            for var i in 0..function.captures.length {
                let capture = function.captures(i)
                let ret = [
                    kind = ValueKind::LOCAL,
                    name = capture.assembly_name(state),
                    tpe = capture.tpe
                ] !Value

                let alloca = make_insn(InsnKind::ALLOCA)
                alloca.value.alloca = [
                    ret = ret
                ] !InsnAlloca
                push_alloca(alloca, state)
                ret.tpe = pointer(capture.tpe)
                
                let capture_value = state.extract_value(capture.tpe, context, [i])
                state.store(ret, capture_value)
            }
        }

        // Create function arguments
        for var i in 0..vector::length(function.args) {
            let np = function.args(i)
            var value = np.tpe
            if value and value.kind == typechecking::TypeKind::INTERFACE_IMPL {
                value = value.tpe
            }
            if np.varargs and value {
                value = typechecking::array(value)
            }
            if value and value.kind == typechecking::TypeKind::TYPE { continue }
            /*let vars = map::keys((@scpe).fields)
            for var i in 0..vars.size {
                let v = vars[i]
                print(v, "\n")
            }*/
            let old_name = np.name
            let svalue = scope::get(scpe, parser::make_identifier(old_name))
            if not svalue { continue }
            let name = svalue.assembly_name(state)
            let new_name = old_name + ".value"
            // Insert alloca and store instructions

            if state.current_function {
                state.current_function.function_locals.add(name)
            }

            let ret = [
                kind = ValueKind::LOCAL,
                name = name,
                tpe = value
            ] !Value

            let alloca = make_insn(InsnKind::ALLOCA)
            (@alloca).value.alloca = [
                ret = ret
            ] !InsnAlloca
            push_alloca(alloca, state)

            ret.tpe = typechecking::pointer(value)
            if np.node {
                push_declare_arg(np.node, ret, old_name, i + 1, state)
            }
            
            if not function.has_yield {
                let store = make_insn(InsnKind::STORE)
                (@store).value.store = [
                    value = [
                        kind = ValueKind::LOCAL,
                        name = new_name,
                        tpe = value
                    ] !Value,
                    loc = [
                        kind = ValueKind::LOCAL,
                        name = name,
                        tpe = typechecking::pointer(value)
                    ] !Value
                ] !InsnStore

                push_insn(store, state)

                if typechecking::is_ref(value) {
                    increase_ref_count(ret, null, state)
                }
            }
        }

        if function.test {
            let env_addr = [ kind = ValueKind::LOCAL, tpe = builtins::TestEnvironment_, name = "__env" ] !Value
            let env_alloca = make_insn(InsnKind::ALLOCA)
            env_alloca.value.alloca.ret = env_addr
            push_alloca(env_alloca, state)
            env_addr.tpe = pointer(env_addr.tpe)

            let env_val_ptr = state.load(pointer(builtins::TestEnvironment_), [
                kind = ValueKind::LOCAL,
                tpe = pointer(pointer(builtins::TestEnvironment_)),
                name = scope::get(scpe, parser::make_identifier("env")).assembly_name(state)
            ] !Value)
            let env_val = state.load(builtins::TestEnvironment_, env_val_ptr)
            state.store(env_addr, env_val)
        }

        generate_defer_types_pre(state)

        if function.has_yield {
            // Create new snapshot for arguments
            function.take_snapshot()

            // Get is_at_end pointer
            let is_at_end_gep = make_insn(InsnKind::GETELEMENTPTR)
            is_at_end_gep.value.gep = [
                ret = [ kind = ValueKind::LOCAL, tpe = pointer(builtins::bool_), name = "__is_at_end" ] !Value,
                tpe = generator_type.tpe,
                value = [ kind = ValueKind::LOCAL, tpe = pointer(generator_type.tpe), name = "__generator" ] !Value,
                index = [make_int_value(0), make_int_value(3)]
            ] !InsnGetElementPtr
            push_insn(is_at_end_gep, state)

            // Create switch
            let gep = make_insn(InsnKind::GETELEMENTPTR)
            gep.value.gep = [
                ret = [ kind = ValueKind::LOCAL, tpe = pointer(builtins::int_), name = "__block" ] !Value,
                tpe = function.context,
                value = [ kind = ValueKind::LOCAL, tpe = pointer(function.context), name = "__context"] !Value,
                index = [make_int_value(0), make_int_value(0)]
            ] !InsnGetElementPtr
            push_insn(gep, state)
            let value = state.load(builtins::int_, [ kind = ValueKind::LOCAL, tpe = pointer(builtins::int_), name = "__block" ] !Value)
            
            let switch_values = vector::make(SwitchValue)
            let insn_switch = make_insn(InsnKind::SWITCH)
            insn_switch.value.switch_ = [
                switch_values = switch_values,
                value = value
            ] !InsnSwitch
            function.yield_switch = insn_switch
            push_insn(insn_switch, state)
            let label_ = make_label(state)
            switch_values.push([ 
                value = [ kind = ValueKind::INT, tpe = builtins::int_, i = 0 ] !Value, label_ = label_ ] !SwitchValue
            )
            push_label(label_, state)
        }   

        var last_node: &Node = node
        for var i in 0..vector::length(body) {
            let node = body(i)
            walk(node, state)
            last_node = node
        }

        generate_defer_types_post(state)

        if not no_cleanup {
            insert_destructors(scpe, make_location(last_node, state), state)
        }
        if function.has_yield {
            state.store(
                [ kind = ValueKind::LOCAL, tpe = pointer(builtins::bool_), name = "__is_at_end" ] !Value,
                [ kind = ValueKind::BOOL, tpe = builtins::bool_, i = 1 ] !Value
            )
        }

        vector::insert(function.block.insn, 0, function.allocas)
            
        if not function.has_yield {
            // TODO Make another compiler pass that checks for missing return statements and dead code
            // Check for missing return statement
            let last_insn = state.current_block.insn.peek() if vector::length(state.current_block.insn) > 0 else null !&Insn
            if not last_insn or (@last_insn).kind != InsnKind::RET {
                if function.has_defer {
                    defer_unroll(last_node, state)
                }

                var value = NO_VALUE
                if (@function).ret {
                    value = [
                        kind = ValueKind::UNDEF,
                        tpe = (@function).ret
                    ] !Value
                }
                
                let ret = make_insn(InsnKind::RET)
                (@ret).value.ret.value = value
                push_insn(ret, state)
            }
        }

        if function.has_yield {
            // Implementation
            let parameter_t = vector::make(typechecking::NamedParameter)
            parameter_t.push([ name = "__context", _tpe = generator_type ] !typechecking::NamedParameter)
            let return_t = vector::make(type &typechecking::Type)
            return_t.push(function.optional)
            let impl_tpe = typechecking::make_function_type_n(parser::make_identifier(tpe.name + ".impl"),
                parameter_t, return_t, state.module
            )
            impl_tpe.type_name = typechecking::mangle_function_name(impl_tpe.name, tpe.parameter_t)

            state.store(
                [ kind = ValueKind::LOCAL, tpe = pointer(builtins::int_), name = "__block" ] !Value,
                [ kind = ValueKind::INT, tpe = builtins::int_, i = -1 ] !Value
            )
            state.ret([ kind = ValueKind::ZEROINITIALIZER, tpe = function.optional ] !Value)
            // Insert default value for switch
            function.yield_switch.value.switch_.otherwise = [ name = state.current_block.label_ ] !Label
                
            let impl = predeclare_function(impl_tpe, state.module)
            impl.is_compiled = true
            impl.forward_declare = false
            impl.block = block
            impl.args = parameter_t

            state.module.imported.add(impl_tpe.type_name)

            // Make context type
            let keys = function.all_locals.keys()
            let fields = allocate_ref(typechecking::StructMember, keys.size + 1)
            fields(0) = [ name = "__loc", tpe = builtins::int_ ] !typechecking::StructMember
            for var i in 0..keys.size {
                let tpe = function.all_locals(keys(i))
                fields(i + 1) = [ name = to_string(i), tpe = tpe ] !typechecking::StructMember
            }

            @function.context = @make_struct_type(fields)
            let context_name = tpe.type_name + ".context"
            function.context.type_name = context_name
            state.module.result.structures(context_name) = function.context
            add_type_meta(reference(function.context), state)

            // Generate free_context
            var new_block = make_block()
            state.current_block = new_block
            
            let free_context_parameters = vector::make(typechecking::NamedParameter)
            free_context_parameters.push([ name = "__context", _tpe = pointer(null) ] !typechecking::NamedParameter)
            
            let parameter_t2 = vector::make(typechecking::NamedParameter)
            parameter_t2.push([ name = "__context", _tpe = typechecking::pointer(null) ] !typechecking::NamedParameter)
            let free_context_tpe = typechecking::make_function_type_n(parser::make_identifier(tpe.name + ".free_context"),
                free_context_parameters, vector::make(type &typechecking::Type), state.module
            )
            free_context_tpe.type_name = typechecking::mangle_function_name(free_context_tpe.name, tpe.parameter_t)

            let free_context = predeclare_function(free_context_tpe, state.module)
            free_context.is_compiled = true
            free_context.forward_declare = false
            free_context.block = new_block
            free_context.args = parameter_t2

            state.module.imported.add(free_context_tpe.type_name)

            state.function_stack.push(free_context)
            create_free_context(function, state)
            vector::insert(free_context.block.insn, 0, free_context.allocas)
            state.function_stack.pop()

            // Generate generator
            let new_block2 = make_block()
            state.current_block = new_block2
            function.block = new_block2
            
            create_generator(impl_tpe, free_context_tpe, tpe, generator, function.context, state)

            push_local_var(context_name, function.context, function)
        }

        if function.state {
            push_local_var(function.state.type_name, function.state, function)
        }

        if toolchain::debug_sym {
            vector::pop(state.discope)
        }

        state.function_stack.pop()
        state.current_block = previous_block
        state.local_counter = previous_counter
        state.scope = previous_scope
        function.is_compiled = true
    }

    state.inline_offset = previous_inline_offset
    state.inline_start_block = previous_inline_start_block
    errors::current_function = current_fun
    errors::current_signature = current_signature
}

def make_string(str: Str, state: &State) -> Value {
    let cp = charp(str, state)
    
    let values = allocate_ref(Value, 2)
    values(0) = [ kind = ValueKind::INT, tpe = builtins::size_t_, i = str.length() + 1 ] !Value
    values(1) = [ kind = ValueKind::UNDEF, tpe = typechecking::pointer(builtins::char_) ] !Value
    let ret = make_local_value(builtins::string_, null, state)
    let index = allocate_ref(int, 1)
    index(0) = 1
    let insert = make_insn(InsnKind::INSERTVALUE)
    (@insert).value.insert_value = [
        ret = ret,
        value = [ 
            kind = ValueKind::STRUCT, 
            tpe = builtins::string_,
            values = values 
        ] !Value,
        element = cp,
        index = index
    ] !InsnInsertValue
    push_insn(insert, state)
    return ret
}

// TODO This is not going to work for nested type decls (we don't reset the state)
export def walk_TypeDecl(node: &parser::Node, state: &State) {
    if node.parent and node.parent.kind == parser::NodeKind::PROGRAM {
        let current_signature = errors::current_signature
        errors::current_signature = node.signature_hash
        defer errors::current_signature = current_signature
    }

    let left = node.value.type_decl.left
    let right = node.value.type_decl.right
    for var i in 0..vector::length(left) {
        let n = left(i)
        if not n { continue }

        let tpe = n.tpe
        if not tpe { continue }

        let current_variable = state.current_variable
        if node.parent.kind == parser::NodeKind::PROGRAM {
            state.current_variable = n.svalue
        }

        if typechecking::is_struct(tpe) {
            for var i in 0..tpe.fields.size {
                lookup_struct_member(tpe.fields(i))
            }
            import_structures(tpe, state.module)
        } else if typechecking::is_enum(tpe) {
            let parameter_t = vector::make(typechecking::NamedParameter)
            parameter_t.push( [
                name = "enum",
                _tpe = tpe
            ] !typechecking::NamedParameter)

            let svalue = scope::get_function(node.scope, parser::make_identifier("to_string"), parameter_t)
            let type_name = (@(@svalue).tpe).type_name

            let function = [
                name = type_name,
                unmangled = "to_string",
                args = parameter_t,
                ret = builtins::string_,
                module = state.module,
                function_locals = set::make()
            ] !&Function

            let block = make_block()
            (@function).block = block
            (@state).current_block = block
            state.function_stack.push(function)

            let switch_values = vector::make(SwitchValue)
            let swtch = make_insn(InsnKind::SWITCH)
            (@swtch).value.switch_ = [
                value = [ 
                    kind = ValueKind::LOCAL, 
                    name = "enum.value",
                    tpe = tpe.tpe
                ] !Value,
                switch_values = switch_values
            ] !InsnSwitch
            push_insn(swtch, state)
            
            // Create enum strings
            let scpe = tpe.scope
            if not scpe { continue }
            let keys = map::keys((@scpe).fields)
            let used = set::make()
            for var i in 0..keys.size {
                let name = keys(i)
                let value = scpe.fields(name)

                let int_key = to_string(value.value.i)
                if set::contains(used, int_key) {
                    continue
                } else {
                    used.add(int_key)
                }

                let label_ = make_label(state)
                push_label(label_, state)

                let sv = [
                    value = @value.value,
                    label_ = label_
                ] !SwitchValue
                switch_values.push(sv)
            
                let ret = make_string(name, state)
                let retinsn = make_insn(InsnKind::RET)
                (@retinsn).value.ret.value = ret
                push_insn(retinsn, state)
            }
            let otherwise = make_label(state)
            (@swtch).value.switch_.otherwise = otherwise
            push_label(otherwise, state)
            
            let invalid = "INVALID!!"
            let ret = make_string(invalid, state)
            let retinsn = make_insn(InsnKind::RET)
            (@retinsn).value.ret.value = ret
            push_insn(retinsn, state)
            
            import_structures((@svalue).tpe, state.module)
            (@(@state).module).imported.add((@function).name)
            state.module.result.functions(function.name) = function
            state.function_stack.pop()
        }

        if i < vector::length(right) {
            let r = right(i)
            if r and n.kind != NodeKind::TYPE_CONSTRUCTOR and (r.kind == parser::NodeKind::STRUCT_T or
                r.kind == parser::NodeKind::UNION_T) {
                verify_struct(state.current_value(), r)
            }
        }

        state.current_variable = current_variable
    }
}

export def walk_top_VarDecl(node: &parser::Node, state: &State, set_constant: bool) -> &parser::Node {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let right = node.value.var_decl.right

    if kw == parser::VarDecl::CONST and not set_constant {
        return null
    }

    let current_signature = errors::current_signature
    errors::current_signature = node.signature_hash
    defer errors::current_signature = current_signature

    let left = vector::make(type &parser::Node)
    var external = false
    if share !int & parser::ShareMarker::IMPORT !int {
        external = true
    }

    for var i in 0..vector::length(node.value.var_decl.left) {
        let n = node.value.var_decl.left(i)
        if (@n).kind == parser::NodeKind::ID_DECL {
            let v = (@n).value.id_decl.value
            if not v { continue }
            let t = n.value.id_decl.tpe

            if t and (t.kind == parser::NodeKind::STRUCT_T or
                t.kind == parser::NodeKind::UNION_T) {
                verify_struct(n.svalue, t)
            }
            
            let value = scope::get(node.scope, v)
            if not value { continue }
            
            import_structures((@v).tpe, state.module)
            let name = (@value).assembly_name(state)

            let global = [
                external = external,
                name = name,
                tpe = (@v).tpe,
                line = (@v).loc.line,
                dllimport = value.dllimport,
                dllexport = value.dllexport,
                is_var_decl = true
            ] !&Global
            
            state.module.result.globals((@global).name) = global
            state.module.imported.add(global.name)

            let current_function = state.current_function
            if current_function.function_locals {
                current_function.function_locals.add(value.assembly_name(state))
            }
        
            v.is_initializer = true
            left.push(v)
        } else {
            left.push(n.value.expr)
        }
    }
    if vector::length(node.value.var_decl.right) > 0 {
        let node_assign = [
            kind = parser::NodeKind::ASSIGN,
            loc = node.loc,
            scope = node.scope,
            parent = node.parent
        ] !&parser::Node

        node_assign.value.assign = [
            left = left,
            right = right
        ] !parser::NodeAssign
        return node_assign
    }
    return null
}

def walk_top_VarDecl(node: &parser::Node, body: &Vector(&parser::Node), state: &State) {
    let kw = node.value.var_decl.kw
    if kw != parser::VarDecl::CONST {
        let node_assign = walk_top_VarDecl(node, state, false)
        if node_assign {
            body.push(node_assign)
        }
    }
}

def insert_module_main(module: &toolchain::Module, name: &parser::Node, scpe: &scope::Scope, body: &Vector(&parser::Node), state: &State) {
    if not module { return }

    // Build dependency graph
    if module.filename {
        state.module.dependants.add(module)
    }

    let finalizer = module.result.finalizer
    if finalizer {
        let previous_block = state.current_block
        state.current_block = state.finalizer.block

        state.call(finalizer.type_name, null, [] ![Value])

        predeclare_function(finalizer, state.module)
        state.module.imported.add(finalizer.type_name)
        
        state.current_block = previous_block
    }

    let args = vector::make(type &parser::Node)
    let arg = parser::make_identifier("args")
    (@arg).scope = scpe
    (@arg).tpe = typechecking::array(builtins::string_)
    (@arg).svalue = scope::get((@arg).scope, arg)
    args.push(arg)

    let name_size = vector::length(name.value.identifier.path)
    let array = zero_allocate(type String, name_size + 1)
    defer delete(array)
    for var j in 0..name_size {
        array(j) = name.value.identifier.path(j)
    }
    array(array.size - 1) = "__main__"
    let ident = parser::make_identifier(array)
    (@ident).scope = scpe

    let main_value = module.scope.fields.get_or_default("__main__", null) // TODO This is a bit ugly, use scope::get instead
    if not main_value { return }

    let call = [
        kind = parser::NodeKind::FUNC_CALL,
    	scope = scpe,
        function = (@main_value).tpe
    ] !&parser::Node
    
    call.value.func_call = [
        left = ident,
        args = args,
        kwargs = vector::make(type &parser::Node)
    ] !parser::NodeFuncCall

    let fun = module.result.functions.get_or_default(main_value.tpe.type_name, null)
    insert_function(state.module, fun)

    body.push(call)
}

def walk_top_Import(node: &parser::Node, body: &Vector(&parser::Node), state: &State) {
    let imports = node.value.body
    for var i in 0..vector::length(imports) {
        let imprt = imports(i)
        let name = (@imprt).value.import_module.name
        if not name { return }

        let module = toolchain::compile_module(name, state.module)
        toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)
        insert_module_main(module, name, node.scope, body, state)
    }
}

export def create_builtin_functions {
    create_destructors()
    create_constructors()
}

export def create_dyn_dispatch(dyn_dispatch: &Vector(&typechecking::Type), state: &State) {
    while dyn_dispatch.length > 0 {
        let tpe = dyn_dispatch(0)
        dyn_dispatch.remove(0)
        let function = predeclare_function(tpe, state.module)
        generate_vtable_function(function, tpe, state)
        consteval::const_module.result.functions(function.name) = function
    }
}

export let constructors = map::make(type &typechecking::Type)
def create_constructors {
    var done = set::make()
    loop {
        var new_constructors = 0
        var keys = map::keys(constructors)
        for var i in 0..keys.size {
            let key = keys(i)
            if set::contains(done, key) { continue }
            let tpe = constructors(key)

            create_constructor(tpe)

            new_constructors += 1
            done.add(key)
        }
        if new_constructors == 0 { break }
    }
}

export def create_constructor(tpe: &typechecking::Type) {
    if not tpe { return }
    let state = toolchain::types_state
    if typechecking::is_polymorph(tpe) { return }
            
    let function = predeclare_function(tpe, state.module)
    consteval::const_module.result.functions(function.name) = function
    function.forward_declare = false
    state.module.imported.add(tpe.type_name)
    import_structures(tpe, state.module)
    
    state.function_stack.push(function)
    let block = make_block()
    state.current_function.block = block
    let previous_block = state.current_block
    state.current_block = block

    let first_arg = tpe.parameter_t(0).tpe
    let copy = [ kind = ValueKind::LOCAL, tpe = first_arg, name = "__copy.value" ] !Value
    let this = [ kind = ValueKind::LOCAL, tpe = first_arg, name = "__this.value" ] !Value
    state.store(copy, state.load(this.tpe.tpe, this))
    create_constructor(copy, this, state)

    state.ret(NO_VALUE)
    vector::insert(block.insn, 0, state.current_function.allocas)
    
    state.function_stack.pop()
    state.current_block = previous_block
}

def create_constructor(copy: Value, this: Value, state: &State) {
    if this.tpe.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
        let counter_ptr = state.alloca(builtins::size_t_)
        state.store(counter_ptr, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 0 ] !Value)
        
        let br_to_start = make_insn(InsnKind::BR_UNC)
        push_insn(br_to_start, state)

        let loop_start = make_label(state)
        push_label(loop_start, state)
        br_to_start.value.br_unc.label_ = loop_start
        
        let counter_value = state.load(builtins::size_t_, counter_ptr)
        let cond = state.icmp(CompareInt::eq, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = this.tpe.tpe.length ] !Value)
        let br = make_insn(InsnKind::BR)
        br.value.br = [ cond = cond ] !InsnBr
        push_insn(br, state)

        let loop_inner = make_label(state)
        push_label(loop_inner, state)
        br.value.br.if_false = loop_inner

        let copy_ptr = state.gep(pointer(copy.tpe.tpe.tpe), copy.tpe.tpe, copy, [make_int_value(0), counter_value])
        if typechecking::has_copy_constructor(this.tpe.tpe.tpe) {
            let this_ptr = state.gep(pointer(this.tpe.tpe.tpe), this.tpe.tpe, this, [make_int_value(0), counter_value])
            if typechecking::has_user_defined_copy_constructor(this.tpe.tpe) {
                insert_copy_constructor(copy_ptr, state.load(this.tpe.tpe.tpe, this_ptr), null, state)
            } else {
                create_constructor(copy_ptr, this_ptr, state)
            }
        } else {
            increase_ref_count(copy_ptr, null, state)
        }
        
        let counter_inc = state.add(builtins::size_t_, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value)
        state.store(counter_ptr, counter_inc)

        push_insn(br_to_start, state)

        let loop_end = make_label(state)
        push_label(loop_end, state)
        br.value.br.if_true = loop_end
    } else {
        let stpe = this.tpe.tpe
        if stpe.kind == typechecking::TypeKind::TUNION {
            let tpeptrptr = state.gep(pointer(pointer(builtins::Type_)), stpe, this, [make_int_value(0), make_int_value(0)])
            let tpeptr = state.load(pointer(builtins::Type_), tpeptrptr)
            let tpev = state.load(builtins::Type_, tpeptr)
            let tpe_id = state.extract_value(builtins::int64_, tpev, [14])
            
            let union_tpe = pointer([ kind = typechecking::TypeKind::WORD, size = this.tpe.tpe.tpe.align ] !&typechecking::Type)
            let frm = state.gep(union_tpe, stpe, this, [make_int_value(0), make_int_value(1), make_int_value(0)])
            let to = state.gep(union_tpe, stpe, copy, [make_int_value(0), make_int_value(1), make_int_value(0)])
        
            let switch_values = vector::make(SwitchValue)

            let swtch = make_insn(InsnKind::SWITCH)
            (@swtch).value.switch_ = [
                value = tpe_id,
                switch_values = switch_values
            ] !InsnSwitch
            push_insn(swtch, state)

            for var variant in @stpe.variants.keys() {
                if has_copy_constructor(variant) {
                    let constructor = typechecking::get_builtin_constructor(variant)
                    let if_true = make_label(state)
                    push_label(if_true, state)

                    let svalue = [
                        label_ = if_true,
                        value = [ kind = ValueKind::INT, i = variant.hash !int64, tpe = builtins::int64_ ] !Value
                    ] !SwitchValue
                    switch_values.push(svalue)

                    var casted_from = state.bitcast(pointer(variant), frm)
                    let casted_to = state.bitcast(pointer(variant), to)
                    casted_from = state.load(variant, casted_from) // This shouldn't be necessary

                    insert_copy_constructor(casted_to, casted_from, null, state)
                    state.ret(NO_VALUE)
                }
            }
            var end = state.make_label()
            push_label(end, state)
            swtch.value.switch_.otherwise = end

        } else if stpe.kind != typechecking::TypeKind::UNION {
            assert stpe.kind == typechecking::TypeKind::STRUCT or stpe.kind == typechecking::TypeKind::CLOSURE

            for var i in 0..vector::length(stpe.field_types) {
                let member = stpe.field_types(i)

                if typechecking::has_copy_constructor(member.tpe) {
                    let this_ptr = state.gep(pointer(member.tpe), this.tpe.tpe, this, [make_int_value(0), make_int_value(i)])
                    let copy_ptr = state.gep(pointer(member.tpe), copy.tpe.tpe, copy, [make_int_value(0), make_int_value(i)])

                    if typechecking::has_user_defined_copy_constructor(member.tpe) {
                        insert_copy_constructor(copy_ptr, state.load(member.tpe, this_ptr), null, state)
                    } else {
                        let ctor = typechecking::get_constructor(member.tpe)
                        state.call(ctor.tpe.type_name, null, [copy_ptr, this_ptr])
                    }
                } else if typechecking::is_ref(member.tpe) {
                    let copy_ptr = state.gep(pointer(member.tpe), copy.tpe.tpe, copy, [make_int_value(0), make_int_value(i)])
                    increase_ref_count(copy_ptr, null, state)
                }
            }
        }
    }
}

// Vector of (function) Type
export let destructors = map::make(type &typechecking::Type)
def create_destructors {
    // Need to import the free function because the types module doesn't import cstd
    let state = toolchain::types_state
    import_cstd_function("free", state)

    // TODO This looping is very inefficient
    var done = set::make()
    loop {
        var new_destructors = 0
        var keys = map::keys(destructors)
        for var i in 0..keys.size {
            let key = keys(i)
            if map::contains(done, key) { continue }
            let tpe = destructors(key)

            create_destructor(tpe)
            
            new_destructors += 1
            done.add(key)
        }
        if new_destructors == 0 { break }
    }
}

export def create_destructor(tpe: &typechecking::Type) {
    if not tpe { return }
    let state = toolchain::types_state
    if typechecking::is_polymorph(tpe) { return }
            
    let function = predeclare_function(tpe, state.module)
    consteval::const_module.result.functions(function.name) = function
    function.forward_declare = false
    state.module.imported.add(tpe.type_name)
    import_structures(tpe, state.module)
    
    state.function_stack.push(function)
    let block = make_block()
    state.current_function.block = block
    let previous_block = state.current_block
    state.current_block = block

    let first_arg = (tpe.parameter_t(0)).tpe
    create_destructor(first_arg, [ kind = ValueKind::LOCAL, tpe = first_arg, name = "__ptr.value" ] !Value, state)

    state.ret(NO_VALUE)
    vector::insert(block.insn, 0, state.current_function.allocas)

    state.function_stack.pop()
    state.current_block = previous_block
}

def create_destructor(tpe: &typechecking::Type, value: Value, state: &State) {
    if typechecking::is_polymorph(tpe) { return }
    assert tpe.kind == typechecking::TypeKind::POINTER

    if tpe.tpe and tpe.tpe.kind == typechecking::TypeKind::TUNION {
        let stpe = tpe.tpe
        let tpeptrptr = state.gep(pointer(pointer(builtins::Type_)), stpe, value, [make_int_value(0), make_int_value(0)])
        let tpeptr = state.load(pointer(builtins::Type_), tpeptrptr)
        let tpev = state.load(builtins::Type_, tpeptr)
        let tpe_id = state.extract_value(builtins::int64_, tpev, [14])
        
        let union_tpe = pointer([ kind = typechecking::TypeKind::WORD, size = stpe.tpe.align ] !&typechecking::Type)
        let val = state.gep(union_tpe, stpe, value, [make_int_value(0), make_int_value(1), make_int_value(0)])
    
        let switch_values = vector::make(SwitchValue)

        let swtch = make_insn(InsnKind::SWITCH)
        (@swtch).value.switch_ = [
            value = tpe_id,
            switch_values = switch_values
        ] !InsnSwitch
        push_insn(swtch, state)

        for var variant in @stpe.variants.keys() {
            if has_copy_constructor(variant) {
                let constructor = typechecking::get_builtin_constructor(variant)
                let if_true = make_label(state)
                push_label(if_true, state)

                let svalue = [
                    label_ = if_true,
                    value = [ kind = ValueKind::INT, i = variant.hash !int64, tpe = builtins::int64_ ] !Value
                ] !SwitchValue
                switch_values.push(svalue)

                var casted_val = state.bitcast(pointer(variant), val)
                insert_destructor(casted_val, null, state)
                state.ret(NO_VALUE)
            }
        }
        var end = state.make_label()
        push_label(end, state)
        swtch.value.switch_.otherwise = end

        return
    }

    var structure_type = tpe.tpe
    var ref: Value, ref_count_ptr: Value
    var null_br: &Insn, br: &Insn

    if typechecking::is_ref(tpe.tpe) and tpe.tpe.tpe and not is_interface(tpe.tpe.tpe) {
        // Decrease ref count
        ref = state.load(tpe.tpe, value)
        ref_count_ptr = state.extract_value(pointer(builtins::int64_), ref, [0])
        let ref_count_value = state.ptr_to_int(ref_count_ptr)
        let null_cond = state.icmp(CompareInt::eq, ref_count_value, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value)
        null_br = make_insn(InsnKind::BR)
        null_br.value.br = [ cond = null_cond ] !InsnBr
        push_insn(null_br, state)

        let if_not_null = make_label(state)
        null_br.value.br.if_false = if_not_null
        push_label(if_not_null, state)
    	
        let ref_count = state.load(builtins::int64_, ref_count_ptr)
        let decr_ref_count = state.sub(builtins::int64_, ref_count, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 1 ] !Value)
        state.store(ref_count_ptr, decr_ref_count)
        let cond = state.icmp(CompareInt::sle, decr_ref_count, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value)
        
        br = make_insn(InsnKind::BR)
        br.value.br = [ cond = cond ] !InsnBr
        push_insn(br, state)

        let if_true = make_label(state)
        br.value.br.if_true = if_true
        push_label(if_true, state)

        structure_type = tpe.tpe.tpe

        // Free arrays
        if is_array(structure_type) and has_destructor(structure_type.tpe) and not is_polymorph(structure_type.tpe) {
            var size = NO_VALUE
            var data = NO_VALUE
            if structure_type.kind == typechecking::TypeKind::ARRAY {
                let array_ptr = state.extract_value(pointer(structure_type), ref, [1])
                let array = state.load(structure_type, array_ptr)
                size = state.extract_value(builtins::size_t_, array, [0])
                data = state.extract_value(pointer(structure_type.tpe), array, [1])
            } else if structure_type.kind == typechecking::TypeKind::STATIC_ARRAY {
                size = [ kind = ValueKind::INT, tpe = builtins::size_t_, i = structure_type.length ] !Value
                data = state.extract_value(pointer(structure_type), ref, [1])
            }

            let counter_ptr = state.alloca(builtins::size_t_)
            state.store(counter_ptr, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 0 ] !Value)
            
            let br_to_start = make_insn(InsnKind::BR_UNC)
            push_insn(br_to_start, state)

            let loop_start = make_label(state)
            push_label(loop_start, state)
            br_to_start.value.br_unc.label_ = loop_start
            
            let counter_value = state.load(builtins::size_t_, counter_ptr)
            let cond = state.icmp(CompareInt::eq, counter_value, size)
            let br = make_insn(InsnKind::BR)
            br.value.br = [ cond = cond ] !InsnBr
            push_insn(br, state)

            let loop_inner = make_label(state)
            push_label(loop_inner, state)
            br.value.br.if_false = loop_inner

            let ptpe = pointer(structure_type.tpe)
            var array_val = NO_VALUE
            if structure_type.kind == typechecking::TypeKind::ARRAY {
                array_val = state.gep(ptpe, structure_type.tpe, data, [counter_value])
            } else {
                array_val = state.gep(ptpe, structure_type, data, [make_int_value(0), counter_value])
            }

            let name = debug::type_to_str(ptpe, full_name = true)
            let destructor = typechecking::get_builtin_destructor(structure_type.tpe)

            if destructor {
                state.call(destructor.tpe.type_name, null, [array_val])
            }

            let counter_inc = state.add(builtins::size_t_, counter_value, [ kind = ValueKind::INT, tpe = builtins::size_t_, i = 1 ] !Value)
            state.store(counter_ptr, counter_inc)

            push_insn(br_to_start, state)

            let loop_end = make_label(state)
            push_label(loop_end, state)
            br.value.br.if_true = loop_end
        }
    }

    var to_end = make_insn(InsnKind::BR_UNC)
    var null_br2: &Insn = null
    if typechecking::is_ref(tpe.tpe) and (not tpe.tpe.tpe or typechecking::is_interface(tpe.tpe.tpe)) {
        let ref = state.load(tpe.tpe, value)

        // Extract type
        let ref_count = state.extract_value(pointer(builtins::int64_), ref, [0])
        let ref_count_value = state.ptr_to_int(ref_count)
        let cond = state.icmp(CompareInt::eq, ref_count_value, [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value)
        null_br2 = make_insn(InsnKind::BR)
        null_br2.value.br = [ cond = cond ] !InsnBr
        push_insn(null_br2, state)

        let if_false = state.make_label()
        push_label(if_false, state)
        null_br2.value.br.if_false = if_false
        
        let fp = unbox((builtins::Type_).field_types(15).tpe)

        let ref_tpe = state.extract_value(pointer(builtins::Type_), ref, [2])
        let ref_tpe_deref = state.load(builtins::Type_, ref_tpe)
        let dtor = state.extract_value(fp, ref_tpe_deref, [15])

        // Call destructor
        state.call(dtor, null, [value], parser::InlineSpecifier::NONE)

    } else if structure_type and structure_type.module {
        // There can only be one destructor for this type
        var destructor = typechecking::get_user_defined_destructor(structure_type)
        if destructor {
            predeclare_function(destructor.tpe, state.module)
            state.module.imported.add(destructor.tpe.type_name)

            if typechecking::is_ref(tpe.tpe) {
                let ref = state.load(tpe.tpe, value)
                value = state.extract_value(pointer(structure_type), ref, [1])
            }
            state.call(destructor.tpe.type_name, null, [value])
        }
    }
    push_insn(to_end, state)

    let end_label = state.make_label()
    to_end.value.br_unc.label_ = end_label
    push_label(end_label, state)

    if null_br2 {
        null_br2.value.br.if_true = end_label
    }

    if structure_type and 
        structure_type.kind == typechecking::TypeKind::STRUCT or 
        structure_type.kind == typechecking::TypeKind::CLOSURE {
            
        var obj: Value
        if typechecking::is_ref(value.tpe.tpe) {
            let ref = state.load(tpe.tpe, value)
            obj = state.extract_value(pointer(structure_type), ref, [1])
        } else {
            obj = value
        }
        
        for var i in 0..structure_type.fields.size {
            typechecking::lookup_struct_member(structure_type.fields(i))
        }

        if structure_type.field_types { // TODO This should never be null
            for var i in 0..structure_type.field_types.length {
                let field = structure_type.field_types(i)
                if typechecking::is_polymorph(field.tpe) { continue }
                let ptpe = pointer(field.tpe)
                let name = debug::type_to_str(ptpe, full_name = true)
                let destructor = typechecking::get_builtin_destructor(field.tpe)

                if destructor {
                    let field_value = state.gep(ptpe, structure_type, obj, [make_int_value(0), make_int_value(i)])
                    state.call(destructor.tpe.type_name, null, [field_value])
                }
            }
        }
    }

    if typechecking::is_ref(tpe.tpe) and tpe.tpe.tpe and not is_interface(tpe.tpe.tpe) {
        if builtins::builtins.fields.contains("DEBUG_REF_CYCLES") and not consteval::is_static {
            let fun = toolchain::find_module("std").scope.get(parser::make_identifier("remove_root")).tpe
            predeclare_function(fun, state.module)
            state.module.imported.add(fun.type_name)
            import_structure(builtins::Ref_, state.module)
            state.call(fun.type_name, null, [convert_ref_to_ref(builtins::Ref_, ref, null, state)])
        }

        let ref_count_i8_ptr = state.bitcast(pointer(builtins::int8_), ref_count_ptr)
        state.call("free", null, [ref_count_i8_ptr])

        value = state.extract_value(pointer(tpe.tpe.tpe), ref, [1])

        if tpe.tpe.tpe.kind == typechecking::TypeKind::ARRAY {
            let array = state.load(tpe.tpe.tpe, value)
            let array_ptr = state.extract_value(pointer(tpe.tpe.tpe.tpe), array, [1])
            let array_ptr_i8 = state.bitcast(pointer(builtins::int8_), array_ptr)
            state.call("free", null, [array_ptr_i8])
        }

        let obj_i8_ptr = state.bitcast(pointer(builtins::int8_), value)
        state.call("free", null, [obj_i8_ptr])

        let to_end = make_insn(InsnKind::BR_UNC)
        push_insn(to_end, state)

        let end_label = make_label(state)
        to_end.value.br_unc.label_ = end_label
        br.value.br.if_false = end_label
        null_br.value.br.if_true = end_label
        push_label(end_label, state)
    }
}

def push_tpe_tpe(tpe: &typechecking::Type, global: Value, module: &toolchain::Module, state: &State, cache: &Vector(TypeEntry)) {
    let index = allocate_ref(Value, 2)
    index(0) = make_int_value(0)
    index(1) = make_int_value(4)

    let gep_ret = make_local_value(pointer(pointer(builtins::Type_)), null, state)
    let gep = make_insn(InsnKind::GETELEMENTPTR)
    gep.value.gep = [
        ret = gep_ret,
        tpe = builtins::Type_,
        value = global,
        index = index
    ] !InsnGetElementPtr
    push_insn(gep, state)

    var value: Value
    if tpe.tpe {
        let v = create_type(tpe.tpe, module, cache)
        if not v { return }
        value = @v
    } else {
        value = [ kind = ValueKind::NULL, tpe = pointer(builtins::Type_) ] !Value
    }

    let store = make_insn(InsnKind::STORE)
    store.value.store = [
        loc = gep_ret,
        value = value
    ] !InsnStore
    push_insn(store, state)
}

def push_struct_members(tpe: &typechecking::Type, global: Value, module: &toolchain::Module, state: &State, cache: &Vector(TypeEntry)) {
    if not tpe { return }
    if tpe.fields.size == 0 { return }

    // TODO cache these
    let field_type = scope::get_type(toolchain::runtime_.scope, make_identifier("Field"))

    let fields_sarray = make_static_array(field_type, tpe.fields.size)
    let fields = make_global_value(fields_sarray, "fields", null, state)
    for var i in 0..tpe.fields.size {
        let field = tpe.fields(i)
        if not state.consteval {
            typechecking::lookup_struct_member(field)
        }
        let fname = field.name if field.name else to_string(i).to_str()

        let name_values = allocate_ref(Value, 2)
        name_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = fname.length() + 1 ] !Value
        name_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) ] !Value

        let field_values = allocate_ref(Value, 3)
        let type_member = tpe.field_types(field.index)
        field_values(0) = [ kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values ] !Value
        field_values(1) = [ kind = ValueKind::INT, tpe = builtins::uint64_, i = type_member.offset !int64 ] !Value
        field_values(2) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::Type_) ] !Value

        let value = [ kind = ValueKind::STRUCT, tpe = field_type, values = field_values ] !Value
        let name = charp(fname, state)

        let index1 = allocate_ref(int, 2)
        index1(0) = 0
        index1(1) = 1
        let insert_name_ret = make_local_value(field_type, null, state)
        let insert_name = make_insn(InsnKind::INSERTVALUE)
        insert_name.value.insert_value = [
            ret = insert_name_ret,
            value = value,
            element = name,
            index = index1
        ] !InsnInsertValue
        push_insn(insert_name, state)
        
        let tpe2 = create_type(field.tpe, module, cache)
        if not tpe2 { continue }

        let index2 = allocate_ref(int, 1)
        index2(0) = 2
        let insert_type_ret = make_local_value(field_type, null, state)
        let insert_type = make_insn(InsnKind::INSERTVALUE)
        insert_type.value.insert_value = [
            ret = insert_type_ret,
            value = insert_name_ret,
            element = @tpe2,
            index = index2
        ] !InsnInsertValue
        push_insn(insert_type, state)

        let index3 = allocate_ref(Value, 2)
        index3(0) = make_int_value(0)
        index3(1) = make_int_value(i)
        let gep_ret = make_local_value(pointer(field_type), null, state)
        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = [
            ret = gep_ret,
            tpe = fields_sarray,
            value = fields,
            index = index3
        ] !InsnGetElementPtr
        push_insn(gep, state)

        let store = make_insn(InsnKind::STORE)
        store.value.store = [
            loc = gep_ret,
            value = insert_type_ret
        ] !InsnStore
        push_insn(store, state)
    }

    let index1 = allocate_ref(Value, 2)
    index1(0) = make_int_value(0)
    index1(1) = make_int_value(0)
    let gep1_ret = make_local_value(pointer(field_type), null, state)
    let gep1 = make_insn(InsnKind::GETELEMENTPTR)
    gep1.value.gep = [
        ret = gep1_ret,
        tpe = fields_sarray,
        value = fields,
        index = index1
    ] !InsnGetElementPtr
    push_insn(gep1, state)

    let index2 = allocate_ref(Value, 3)
    index2(0) = make_int_value(0)
    index2(1) = make_int_value(7)
    index2(2) = make_int_value(1)
    let gep2_ret = make_local_value(pointer(pointer(field_type)), null, state)
    let gep2 = make_insn(InsnKind::GETELEMENTPTR)
    gep2.value.gep = [
        ret = gep2_ret,
        tpe = builtins::Type_,
        value = global,
        index = index2
    ] !InsnGetElementPtr
    push_insn(gep2, state)

    let store = make_insn(InsnKind::STORE)
    store.value.store = [
        loc = gep2_ret,
        value = gep1_ret
    ] !InsnStore
    push_insn(store, state)
}

def push_enum_values(tpe: &typechecking::Type, global: Value, module: &toolchain::Module, state: &State) {
    let enum_type = scope::get_type(toolchain::runtime_.scope, make_identifier("EnumValue"))

    let values_sarray = make_static_array(enum_type, map::size(tpe.scope.fields))
    let values = make_global_value(values_sarray, "values", null, state)
    
    let keys = map::keys(tpe.scope.fields)
    for var i in 0..keys.size {
        let key = keys(i)
        let svalue = tpe.scope.fields(key)
        
        let name_values = allocate_ref(Value, 2)
        name_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = key.length() + 1 ] !Value
        name_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) ] !Value

        let eval_values = allocate_ref(Value, 2)
        eval_values(0) = [ kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values ] !Value
        eval_values(1) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = svalue.value.i !int64 ] !Value

        let value = [ kind = ValueKind::STRUCT, tpe = enum_type, values = eval_values ] !Value
        let name = charp(key, state)

        let index1 = allocate_ref(int, 2)
        index1(0) = 0
        index1(1) = 1
        let insert_name_ret = make_local_value(enum_type, null, state)
        let insert_name = make_insn(InsnKind::INSERTVALUE)
        insert_name.value.insert_value = [
            ret = insert_name_ret,
            value = value,
            element = name,
            index = index1
        ] !InsnInsertValue
        push_insn(insert_name, state)
        
        let index3 = allocate_ref(Value, 2)
        index3(0) = make_int_value(0)
        index3(1) = make_int_value(i)
        let gep_ret = make_local_value(pointer(enum_type), null, state)
        let gep = make_insn(InsnKind::GETELEMENTPTR)
        gep.value.gep = [
            ret = gep_ret,
            tpe = values_sarray,
            value = values,
            index = index3
        ] !InsnGetElementPtr
        push_insn(gep, state)

        let store = make_insn(InsnKind::STORE)
        store.value.store = [
            loc = gep_ret,
            value = insert_name_ret
        ] !InsnStore
        push_insn(store, state)
    }

    let index1 = allocate_ref(Value, 2)
    index1(0) = make_int_value(0)
    index1(1) = make_int_value(0)
    let gep1_ret = make_local_value(pointer(enum_type), null, state)
    let gep1 = make_insn(InsnKind::GETELEMENTPTR)
    gep1.value.gep = [
        ret = gep1_ret,
        tpe = values_sarray,
        value = values,
        index = index1
    ] !InsnGetElementPtr
    push_insn(gep1, state)

    let index2 = allocate_ref(Value, 3)
    index2(0) = make_int_value(0)
    index2(1) = make_int_value(10)
    index2(2) = make_int_value(1)
    let gep2_ret = make_local_value(pointer(pointer(enum_type)), null, state)
    let gep2 = make_insn(InsnKind::GETELEMENTPTR)
    gep2.value.gep = [
        ret = gep2_ret,
        tpe = builtins::Type_,
        value = global,
        index = index2
    ] !InsnGetElementPtr
    push_insn(gep2, state)

    let store = make_insn(InsnKind::STORE)
    store.value.store = [
        loc = gep2_ret,
        value = gep1_ret
    ] !InsnStore
    push_insn(store, state)
}

def push_variants(tpe: &typechecking::Type, global: Value, module: &toolchain::Module, state: &State, cache: &Vector(TypeEntry)) {
    let values_sarray = make_static_array(pointer(builtins::Type_), tpe.variants.size)
    let values = make_global_value(values_sarray, "values", null, state)

    var i = 0
    for var variant in @tpe.variants.keys() {
        let val = create_type(variant, module, cache)
        let slot = state.gep(pointer(pointer(builtins::Type_)), values_sarray, values, [make_int_value(0), make_int_value(i)])
        state.store(slot, @val)

        i += 1
    }

    let gep_ret = state.gep(pointer(pointer(builtins::Type_)), values_sarray, values, [make_int_value(0), make_int_value(0)])
    let gep2_ret = state.gep(pointer(pointer(pointer(builtins::Type_))), builtins::Type_, global, [make_int_value(0), make_int_value(8), make_int_value(1)])
    state.store(gep2_ret, gep_ret)
}

def push_type_member(
    exported: bool, 
    f_name: Str, 
    pars: &Vector(typechecking::NamedParameter), 
    rets: &Vector(&typechecking::Type), 
    module: &toolchain::Module, 
    state: &State,
    cache: &Vector(TypeEntry)
) -> Value {
    
    let name_values = allocate_ref(Value, 2)
    name_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = f_name.length() + 1 ] !Value
    name_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) ] !Value

    let module_values = allocate_ref(Value, 2)
    module_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = module.module.length() + 1 ] !Value
    module_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) ] !Value

    let parameter_t_values = allocate_ref(Value, 2)
    parameter_t_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(pars) ] !Value
    parameter_t_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(pointer(builtins::Type_)) ] !Value

    let return_t_values = allocate_ref(Value, 2)
    return_t_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(rets) ] !Value
    return_t_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(pointer(builtins::Type_)) ] !Value

    let member_values = allocate_ref(Value, 5)
    member_values(0) = [ kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values ] !Value
    member_values(1) = [ kind = ValueKind::BOOL, tpe = builtins::bool_, i = exported !int64 ] !Value
    member_values(2) = [ kind = ValueKind::STRUCT, tpe = builtins::string_, values = module_values ] !Value
    member_values(3) = [ kind = ValueKind::STRUCT, tpe = array(pointer(builtins::Type_)), values = parameter_t_values ] !Value
    member_values(4) = [ kind = ValueKind::STRUCT, tpe = array(pointer(builtins::Type_)), values = return_t_values ] !Value

    var member = [ kind = ValueKind::STRUCT, tpe = builtins::Function_, values = member_values ] !Value

    let name_v = charp(f_name, state)
    let module_v = charp(module.module, state)

    var parameter_t_ret = NO_VALUE
    if vector::length(pars) > 0 {
        let parameter_t_s_array = make_static_array(pointer(builtins::Type_), vector::length(pars))
        let parameter_t = make_global_value(parameter_t_s_array, "parameter_t", null, state)
        parameter_t_ret = state.gep(pointer(pointer(builtins::Type_)), parameter_t_s_array, parameter_t, [make_int_value(0), make_int_value(0)])

        for var i in 0..vector::length(pars) {
            let np = pars(i)
            let gep_ret = state.gep(pointer(pointer(builtins::Type_)), parameter_t_s_array, parameter_t, [make_int_value(0), make_int_value(i)])
            var tpe = np.tpe
            if np.varargs {
                if tpe {
                    tpe = array(tpe.tpe)
                } else {
                    tpe = array(null)
                }
            }
            let tpe2 = create_type(tpe, module, cache)
            state.store(gep_ret, @tpe2 if tpe2 else NO_VALUE)
        }
    }
    
    var return_t_ret = NO_VALUE
    if vector::length(rets) > 0 {
        let return_t_s_array = make_static_array(pointer(builtins::Type_), vector::length(rets))
        let return_t = make_global_value(return_t_s_array, "return_t", null, state)
        return_t_ret = state.gep(pointer(pointer(builtins::Type_)), return_t_s_array, return_t, [make_int_value(0), make_int_value(0)])

        for var i in 0..vector::length(rets) {
            let tpe = rets(i)
            let gep_ret = state.gep(pointer(pointer(builtins::Type_)), return_t_s_array, return_t, [make_int_value(0), make_int_value(i)])
            let tpe2 = create_type(tpe, module, cache)
            if tpe2 {
                state.store(gep_ret, @tpe2)
            }
        }
    }

    member = state.insert_value(builtins::Function_, member, name_v, [0, 1])
    member = state.insert_value(builtins::Function_, member, module_v, [2, 1])
    if vector::length(pars) > 0 { 
        member = state.insert_value(builtins::Function_, member, parameter_t_ret, [3, 1])
    }
    if vector::length(rets) > 0 {
        member = state.insert_value(builtins::Function_, member, return_t_ret, [4, 1])
    }

    return member
}

def push_type_members(tpe: &typechecking::Type, value: &Value, global: Value, module: &toolchain::Module, state: &State, cache: &Vector(TypeEntry)) {
    let generic = typechecking::get_generic(tpe)
    if generic and generic.tc_incomplete { return }
    if tpe.kind == typechecking::TypeKind::TYPE_DEF { return }

    let member_functions = vector::make(type &typechecking::TypeEntryMember)
    for var member in typechecking::iterate_member_functions(tpe) { // TODO to_array doesn't seem to work
        // These just clutter the metadata as everything can be used to initialize these
        if member.function.parameter_t(0).tpe.kind == typechecking::TypeKind::TYPE { continue }
        member_functions.push(member)
    }
    if vector::length(member_functions) == 0 { return }

    let members_sarray = make_static_array(builtins::Function_, 0)
    let members = make_global_value(members_sarray, "type_members", null, state)

    var j = 0
    for var i in 0..vector::length(member_functions) {
        let member_function = member_functions(i)
        let function = member_function.function

        var is_incomplete = false
        for var i in 0..vector::length(function.parameter_t) {
            let np = function.parameter_t(i)
            let generic = typechecking::get_generic(np.tpe)
            if generic and generic.tc_incomplete or (np.tpe and np.tpe.kind == typechecking::TypeKind::TYPE_DEF) {
                is_incomplete = true
                break 
            }
        }
        if is_incomplete { continue }

        let member = push_type_member(
            member_function.exported, 
            function.type_name, 
            function.parameter_t, function.return_t, 
            module, state, cache
        )

        let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [make_int_value(0), make_int_value(j)])
        state.store(gep_ret, member)
        j += 1
    }
    
    value.values(13).values(0).i = j
    @members_sarray = @make_static_array(builtins::Function_, j)

    if j > 0 {
        let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [make_int_value(0), make_int_value(0)])
        let gep2_ret = state.gep(pointer(pointer(builtins::Function_)), builtins::Type_, global, [make_int_value(0), make_int_value(13), make_int_value(1)])
        state.store(gep2_ret, gep_ret)
    }
}

def push_structural_members(tpe: &typechecking::Type, global: Value, module: &toolchain::Module, state: &State, cache: &Vector(TypeEntry)) {
    
    if vector::length(tpe.members) == 0 { return }

    let members_sarray = make_static_array(builtins::Function_, vector::length(tpe.members))
    let members = make_global_value(members_sarray, "structural_members", null, state)

    for var i in 0..vector::length(tpe.members) {
        let smember = tpe.members(i)

        // TODO exported same as type?
        let member = push_type_member(false, smember.name, smember.parameter_t, smember.return_t, module, state, cache)
        let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [make_int_value(0), make_int_value(i)])
        state.store(gep_ret, member)
    }

    let gep_ret = state.gep(pointer(builtins::Function_), members_sarray, members, [make_int_value(0), make_int_value(0)])
    let gep2_ret = state.gep(pointer(pointer(builtins::Function_)), builtins::Type_, global, [make_int_value(0), make_int_value(12), make_int_value(1)])
    state.store(gep2_ret, gep_ret)
}

def do_create_type(tpe: &typechecking::Type, svalue: &scope::Value, module: &toolchain::Module, cache: &Vector(TypeEntry)) -> &Value {
    if toolchain::no_stdlib { return NO_VALUE }
    
    if tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.weak
    }
    if tpe.kind == typechecking::TypeKind::INTERFACE_IMPL {
        tpe = tpe.tpe
    }

    let generic = typechecking::get_generic(tpe)
    if generic and generic.tc_incomplete { return null }
    if tpe.kind == typechecking::TypeKind::TYPE_DEF { return null }

    let state = toolchain::types_state
    let global = [ kind = ValueKind::GLOBAL, tpe = pointer(builtins::Type_), name = svalue.assembly_name(state) ] !Value

    if not builtins::Field_ { return null }
    let field_type = builtins::Field_
    let enum_type = builtins::EnumValue_

    let value = [] !&Value

    let global2 = [
        private = false,
        name = svalue.assembly_name(state),
        tpe = svalue.tpe,
        value = value,
        line = -1
    ] !&Global

    toolchain::types.result.globals(global2.name) = global2
    toolchain::types.imported.add(global2.name)

    let name_str = debug::type_to_str(tpe, true)

    let name_values = allocate_ref(Value, 2)
    name_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = name_str.length() + 1 ] !Value
    name_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) ] !Value

    let module_values = allocate_ref(Value, 2)
    module_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = module.module.length() + 1 ] !Value
    module_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::int8_) ] !Value

    let type_names = allocate_ref(Value, 2)
    type_names(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = 0 ] !Value
    type_names(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::Function_) ] !Value

    value.values = allocate_ref(Value, 17)
    value.values(1) = [ kind = ValueKind::STRUCT, tpe = builtins::string_, values = name_values ] !Value
    value.values(2) = [ kind = ValueKind::INT, tpe = builtins::bool_, i = tpe.unsig !int64 ] !Value
    value.values(3) = [ kind = ValueKind::UNDEF, tpe = builtins::size_t_ ] !Value
    value.values(4) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::Type_) ] !Value
    value.values(5) = [ kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.size ] !Value
    value.values(6) = [ kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.align ] !Value
    value.values(7) = [ kind = ValueKind::UNDEF, tpe = array(field_type) ] !Value
    value.values(8) = [ kind = ValueKind::UNDEF, tpe = array(pointer(builtins::Type_)) ] !Value
    value.values(9) = [ kind = ValueKind::UNDEF, tpe = array(pointer(builtins::Type_)) ] !Value
    value.values(10) = [ kind = ValueKind::UNDEF, tpe = array(enum_type) ] !Value
    value.values(11) = [ kind = ValueKind::STRUCT, tpe = builtins::string_, values = module_values ] !Value
    value.values(12) = [ kind = ValueKind::UNDEF, tpe = array(builtins::Function_) ] !Value
    value.values(13) = [ kind = ValueKind::STRUCT, tpe = array(builtins::Function_), values = type_names ] !Value
    value.values(14) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = md5::high(md5::md5(name_str)) ] !Value
    value.values(15) = [ kind = ValueKind::UNDEF, tpe = unbox((builtins::Type_).field_types(15).tpe) ] !Value
    value.values(16) = [ kind = ValueKind::UNDEF, tpe = unbox((builtins::Type_).field_types(16).tpe) ] !Value

    if is_ref(tpe) and typechecking::has_destructor(tpe) {
        let fp = unbox((builtins::Type_).field_types(15).tpe)
        // Add destructor reference
        let dtor = typechecking::get_builtin_destructor(tpe, lookup = false)
        let addr = state.gep(pointer(fp), builtins::Type_, global, [make_int_value(0), make_int_value(15)])
        state.store(addr, [ kind = ValueKind::GLOBAL, tpe = pointer(dtor.tpe), name = dtor.tpe.type_name ] !Value)
    }

    if is_ref(tpe) and typechecking::has_copy_constructor(tpe) {
        let fp = unbox((builtins::Type_).field_types(16).tpe)
        // Add constructor reference
        let ctor = typechecking::get_constructor(tpe, lookup = false)
        let addr = state.gep(pointer(fp), builtins::Type_, global, [make_int_value(0), make_int_value(16)])
        state.store(addr, [ kind = ValueKind::GLOBAL, tpe = pointer(ctor.tpe), name = ctor.tpe.type_name ] !Value)
    }

    let index = allocate_ref(Value, 3)
    index(0) = make_int_value(0)
    index(1) = make_int_value(1)
    index(2) = make_int_value(1)

    let gep_ret = make_local_value(pointer(pointer(builtins::char_)), null, state)
    let gep1 = make_insn(InsnKind::GETELEMENTPTR)
    gep1.value.gep = [
        ret = gep_ret,
        tpe = builtins::Type_,
        value = global,
        index = index
    ] !InsnGetElementPtr
    push_insn(gep1, state)

    let name = charp(name_str, state)
    let store1 = make_insn(InsnKind::STORE)
    store1.value.store = [
        loc = gep_ret,
        value = name
    ] !InsnStore
    push_insn(store1, state)
    
    let index2 = allocate_ref(Value, 3)
    index2(0) = make_int_value(0)
    index2(1) = make_int_value(11)
    index2(2) = make_int_value(1)

    let gep2_ret = make_local_value(pointer(pointer(builtins::char_)), null, state)
    let gep2 = make_insn(InsnKind::GETELEMENTPTR)
    gep2.value.gep = [
        ret = gep2_ret,
        tpe = builtins::Type_,
        value = global,
        index = index2
    ] !InsnGetElementPtr
    push_insn(gep2, state)

    let module_name = charp(module.module, state)
    let store2 = make_insn(InsnKind::STORE)
    store2.value.store = [
        loc = gep2_ret,
        value = module_name
    ] !InsnStore
    push_insn(store2, state)

    switch tpe.kind !int {
        case typechecking::TypeKind::STRUCT, typechecking::TypeKind::CLOSURE, typechecking::TypeKind::UNION
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 3 if tpe.kind == typechecking::TypeKind::STRUCT else 4 ] !Value
            let field_values = allocate_ref(Value, 2)
            field_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = tpe.fields.size ] !Value
            field_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(field_type) ] !Value
            value.values(7) = [ kind = ValueKind::STRUCT, tpe = array(field_type), values = field_values ] !Value
            push_struct_members(tpe, global, module, state, cache)
        case typechecking::TypeKind::BOOL
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 0 ] !Value
        case typechecking::TypeKind::WORD
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 1 ] !Value
        case typechecking::TypeKind::CHAR
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 11 ] !Value
        case typechecking::TypeKind::FLOAT
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 2 ] !Value
        case typechecking::TypeKind::ARRAY
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 5 ] !Value
            create_type(tpe.tpe, module, cache)
            push_tpe_tpe(tpe, global, module, state, cache)
        case typechecking::TypeKind::STATIC_ARRAY
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 6 ] !Value
            value.values(3) = [ kind = ValueKind::INT, tpe = builtins::size_t_, i = tpe.length] !Value
            create_type(tpe.tpe, module, cache)
            push_tpe_tpe(tpe, global, module, state, cache)
        case typechecking::TypeKind::POINTER
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 7 ] !Value
            create_type(tpe.tpe, module, cache)
            push_tpe_tpe(tpe, global, module, state, cache)
        case typechecking::TypeKind::REFERENCE
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 8 ] !Value
            create_type(tpe.tpe, module, cache)
            push_tpe_tpe(tpe, global, module, state, cache)
        case typechecking::TypeKind::WEAK_REF
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 14 ] !Value
            create_type(tpe.tpe, module, cache)
            push_tpe_tpe(tpe, global, module, state, cache)
        case typechecking::TypeKind::FUNCTION
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 9 ] !Value
            //TODO Functions
            for var i in 0..vector::length(tpe.parameter_t) {
                let np = tpe.parameter_t(i)
                create_type(np.tpe, module, cache)
            }
            for var i in 0..vector::length(tpe.return_t) {
                create_type(tpe.return_t(i), module, cache)
            }
        case typechecking::TypeKind::TUPLE
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 17 ] !Value
            //TODO Tuples
            for var i in 0..vector::length(tpe.return_t) {
                create_type(tpe.return_t(i), module, cache)
            }
        case typechecking::TypeKind::ENUM
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 10 ] !Value
            let enum_values = allocate_ref(Value, 2)
            enum_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = map::size(tpe.scope.fields) ] !Value
            enum_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(enum_type) ] !Value
            value.values(10) = [ kind = ValueKind::STRUCT, tpe = array(enum_type), values = enum_values ] !Value
            create_type(tpe.tpe, module, cache)
            push_tpe_tpe(tpe, global, module, state, cache)
            push_enum_values(tpe, global, module, state)
        case typechecking::TypeKind::STUB
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 13 ] !Value
        case typechecking::TypeKind::STRUCTURAL
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 12 ] !Value
            let stype_names = allocate_ref(Value, 2)
            stype_names(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = vector::length(tpe.members) ] !Value
            stype_names(1) = [ kind = ValueKind::UNDEF, tpe = pointer(builtins::Function_) ] !Value
            value.values(12) = [ kind = ValueKind::STRUCT, tpe = array(builtins::Function_), values = stype_names ] !Value
            push_structural_members(tpe, global, module, state, cache)
        case typechecking::TypeKind::GENERIC, typechecking::TypeKind::TYPE_CONSTRUCTOR
        case typechecking::TypeKind::TYPE
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 15 ] !Value
        case typechecking::TypeKind::TUNION
            value.values(0) = [ kind = ValueKind::INT, tpe = builtins::int_, i = 16 ] !Value
            
            let array_values = allocate_ref(Value, 2)
            array_values(0) = [ kind = ValueKind::INT, tpe = builtins::int64_, i = tpe.variants.size ] !Value
            array_values(1) = [ kind = ValueKind::UNDEF, tpe = pointer(pointer(builtins::Type_)) ] !Value

            value.values(8) = [ kind = ValueKind::STRUCT, tpe = array(pointer(builtins::Type_)), values = array_values ] !Value

            push_variants(tpe, global, module, state, cache)
        case typechecking::TypeKind::TO_INFER
            // This should only happen in an error case
        case
            error(tpe.kind, "\n")
            assert(false)
    }

    push_type_members(tpe, value, global, module, state, cache)

    value.kind = ValueKind::STRUCT
    value.tpe = builtins::Type_
    return value
}

// TODO Types have modules now, check if these functions need a separate module anymore
// Map of ToResolve
let types_to_resolve = map::make(ToResolve)
type ToResolve = struct {
    module: weak_ref(toolchain::Module)
    tpe: &typechecking::Type
}

// This is needed because some of the types might be stubs when they are first referenced
// Resolve these later
export def resolve_types {
    let keys = map::keys(types_to_resolve)
    for var i in 0..keys.size {
        let to_resolve = types_to_resolve(keys(i))
        let tpe = to_resolve.tpe
        if tpe.kind == typechecking::TypeKind::STUB { continue }

        let ident = make_identifier(debug::type_to_str(tpe, true))
        ident.loc.module = "type"
        
        create_type(tpe, to_resolve.module)
    }
}

type TypeEntry = struct {
    tpe: &typechecking::Type
    value: &scope::Value
    module: weak_ref(toolchain::Module)
}

export def create_type(tpe: &typechecking::Type, module: &toolchain::Module, cache: &Vector(TypeEntry)) -> &Value {
    if not tpe { return null }
    if tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.weak
    }
    if tpe.tc_incomplete { return null }
    let generic = typechecking::get_generic(tpe)
    if generic and generic.tc_incomplete { return null }
    if tpe.kind == typechecking::TypeKind::TYPE_DEF { return null }

    let name = debug::type_to_str(tpe, full_name = true)
    if tpe.kind == typechecking::TypeKind::STUB {
        if name {
            let to_resolve = [ module = module, tpe = tpe ] !ToResolve
            types_to_resolve(name) = to_resolve
        }
        return null
    }

    import_structure(builtins::Type_, toolchain::types)

    let ident = make_identifier(name)
    ident.loc.module = "type"

    var svalue = scope::get(toolchain::types.scope, ident, false, false)
    if not svalue {
        svalue = scope::create_variable(
            toolchain::types.scope, ident, parser::ShareMarker::NONE, 
            parser::VarDecl::CONST, builtins::Type_, 
            false, false, false, null, scope::Phase::DEFINED, null, null)

        cache.push([
           tpe = tpe, value = svalue, module = module
        ] !TypeEntry)
        /*svalue = scope::create_variable(
            toolchain::types.scope, 
            ident, parser::ShareMarker::NONE, parser::VarDecl::CONST, 
            builtins::Type_, do_create_type(tpe, svalue, module))*/
        svalue.identifier = ident
    }

    let state = toolchain::types_state
    if not state.consteval and 
        not map::contains(module.result.globals, svalue.assembly_name(state)) {
            
        let global = [
            external = true,
            name = svalue.assembly_name(state),
            tpe = builtins::Type_,
            line = -1,
            identifier = ident
        ] !&Global
        module.result.globals(global.name) = global
        module.imported.add(global.name)
    }

    let value = [
        kind = ValueKind::GLOBAL,
        tpe = typechecking::pointer(builtins::Type_), 
        name = svalue.assembly_name(state)
    ] !&Value

    // value.value_tpe = tpe

    return value
}

def change_value_to_type(tpe: &typechecking::Type, state: &State) -> &scope::Value {
    let type_tpe = copy(builtins::Type_)
    type_tpe._tpe = tpe 
    import_structures(builtins::Type_, state.module)

    add_type_meta(tpe, state)
    
    let value_tpe = create_type(tpe, state.module)
    if not value_tpe { return null }

    value_tpe.value_tpe = tpe
    let value = [
        tpe = typechecking::pointer(type_tpe),
        value = value_tpe
    ] !&scope::Value

    return value
}


export def make_result -> &Result {
    return [
        functions = map::make(type &Function),
        structures = map::make(type &typechecking::Type),
        globals = map::make(type &Global),
        metadata = map::make(type &Value)
    ] !&Result
}

export def make_state(module: &toolchain::Module) -> &State {
    let state = [
        module = module,
        loops = vector::make(LoopState),
        ditypes = map::make(type &typechecking::Type, type &Value),
        discope = vector::make(type &Value),
        current_block = make_block(),
        globals = map::make(type *),
        function_stack = vector::make(type &Function),
        mem = arena::make()
    ] !&State

    return state
}

export def predeclare_functions(module: &toolchain::Module) {
    let sc = module.scope
    if sc.imports {
        for var i in 0..vector::length(sc.imports) {
            let imprt = sc.imports(i)
            let m_scope = imprt.module.scope
            let keys = map::keys((@m_scope).fields)
            for var i in 0..keys.size {
                var value = m_scope.fields(keys(i))
                while value {
                    if value.share !int & parser::ShareMarker::EXPORT !int {
                        if typechecking::is_function(value.tpe) {
                            if not typechecking::is_polymorph(value.tpe) {
                                var fun: &Function
                                if value.node {
                                    fun = value.node.value.def_.function
                                } else {
                                    fun = predeclare_function(value.tpe, imprt.module)
                                    fun.imported = value.imported
                                }
                                insert_function(module, fun)
                            }
                        } else if not typechecking::is_type(value.tpe) {
                            let name = value._assembly_name
                            let global = [
                                name = name,
                                tpe = value.tpe,
                                external = true,
                                line = -1,
                                dllimport = value.dllimport,
                                dllexport = value.dllexport
                            ] !&Global
                            module.result.globals(name) = global
                        }
                    }
                    value = value.next
                }
            }
        }
    }
}

def generate_vtable_function(function: &Function, tpe: &typechecking::Type, state: &State) {
    let first_param = (tpe.parameter_t(0)).tpe
    let intf = typechecking::get_interface(first_param)

    function.block = make_block()
    function.forward_declare = false
    let previous_block = state.current_block
    state.current_block = function.block

    var ret_tpe: &typechecking::Type = null
    if vector::length(tpe.return_t) > 1 {
        ret_tpe = make_return_type(tpe)
    } else if vector::length(tpe.return_t) == 1 {
        ret_tpe = vector::peek(tpe.return_t)
    }

    // Extract type
    let ref_tpe = state.extract_value(
        typechecking::pointer(builtins::Type_), 
        [ kind = ValueKind::LOCAL, tpe = first_param, name = "__ref.value"] !Value,
        [2]
    )
    let ref_tpe_deref = state.load(builtins::Type_, ref_tpe)
    let tpe_value = state.extract_value(
        typechecking::pointer(builtins::Type_),
        ref_tpe_deref,
        [4]
    )
    let tpe_deref = state.load(builtins::Type_, tpe_value)
    let tpe_id = state.extract_value(builtins::int64_, tpe_deref, [14])

    let switch_values = vector::make(SwitchValue)
    let swtch = make_insn(InsnKind::SWITCH)
    swtch.value.switch_ = [
        value = tpe_id,
        switch_values = switch_values
    ] !InsnSwitch
    push_insn(swtch, state)

    let hashes = set::make(size_t)
    let keys = map::keys(typechecking::types_map)
    for var i in 0..keys.size {
        let type_entry = typechecking::types_map(keys(i))
        if is_ref(type_entry.tpe) and typechecking::implements(type_entry.tpe, intf, state.module) {
            let hash = md5::high(md5::md5(debug::type_to_str(type_entry.tpe.tpe, full_name = true)))
            if hashes.contains(hash) { continue }
            hashes.add(hash)

            let generic = typechecking::get_generic(type_entry.tpe)
            if generic and generic.tc_incomplete { continue }
            if not type_entry.tpe.tpe { continue }

            state.module.imported.add(type_entry.tpe.tpe.type_name)

            let parameter_t = vector::copy(tpe.parameter_t)
            parameter_t(0) = [ _tpe = type_entry.tpe ] !typechecking::NamedParameter
            
            var score = std::MAX_INT32 !int
            var fun: &typechecking::Type = null
            var module: &toolchain::Module = null
            for var member in typechecking::iterate_member_functions(type_entry.tpe) {
                if member.function.name != tpe.name { continue }
                let s = typechecking::overload_score(member.function, parameter_t, state.module, true)
                if s >= 0 and s < score { 
                    fun = member.function
                    module = member.module
                    score = s
                }
            }

            var kind = 0
            if not fun {
                if function.unmangled.starts_with("__set_") and function.unmangled.ends_with("__") {
                    kind = 1
                } else if function.args.length == 1 {
                    kind = 2
                } else {
                    continue
                }
            } else {
                predeclare_function(fun, state.module)
                state.module.imported.add(fun.type_name)

                if consteval::is_static {
                    let fun = scope::get_function(module.scope, parser::make_identifier(tpe.name), parameter_t, false, false, false)
                    let val = consteval::compile_function(fun, state.scope)
                    import_structures(val.tpe, state.module)
                }
            }

            if kind != 0 and type_entry.tpe.tpe.kind != typechecking::TypeKind::STRUCT { continue }

            if not consteval::is_static {
                import_structure(type_entry.tpe.tpe, state.module)
            }

            let if_true = make_label(state)
            push_label(if_true, state)
            
            let svalue = [
                label_ = if_true,
                value = [ kind = ValueKind::INT, i = hash, tpe = builtins::int64_ ] !Value
            ] !SwitchValue
            switch_values.push(svalue)

            
            let target_type = fun.parameter_t(0).tpe if fun else type_entry.tpe
            let reference = convert_ref_to_ref(target_type, [ kind = ValueKind::LOCAL, tpe = first_param, name = "__ref.value"] !Value, null, state)
            
            if kind == 0 {
                let args = allocate_ref(Value, vector::length(tpe.parameter_t))
                args(0) = reference
                for var i in 1..vector::length(tpe.parameter_t) {
                    let np = tpe.parameter_t(i)
                    args(i) = [ kind = ValueKind::LOCAL, tpe = np.tpe, name = np.name + ".value" ] !Value
                }
                let r = state.call(fun.type_name, ret_tpe, args)
                state.ret(r)
            } else if kind == 1 {
                // Setter 
                var deref = state.extract_value(pointer(type_entry.tpe.tpe), reference, [1])
                var value = state.load(type_entry.tpe.tpe, deref)
                let name = function.unmangled.slice(6, function.unmangled.length() - 2)
                var findex: size_t = 0
                var ftpe: &typechecking::Type
                for var field in @type_entry.tpe.tpe.fields {
                    if field.name == name {
                        findex = field.index
                        ftpe = field.tpe
                    }
                }

                let np = tpe.parameter_t(1)
                let arg = [ kind = ValueKind::LOCAL, tpe = np.tpe, name = np.name + ".value" ] !Value
                value = state.insert_value(type_entry.tpe.tpe, value, arg, [findex !int])
                state.store(deref, value)
                state.ret(NO_VALUE)
            } else {
                // Getter
                var deref = state.extract_value(pointer(type_entry.tpe.tpe), reference, [1])
                var value = state.load(type_entry.tpe.tpe, deref)
                let name = function.unmangled
                var findex: size_t = 0
                var ftpe: &typechecking::Type
                for var field in @type_entry.tpe.tpe.fields {
                    if field.name == name {
                        findex = field.index
                        ftpe = field.tpe
                    }
                }

                value = state.extract_value(ftpe, value, [findex !int])
                state.ret(value)
            }
        }
    }

    let end_label = make_label(state)
    push_label(end_label, state)
    swtch.value.switch_.otherwise = end_label

    state.module.imported.add("abort")
    state.call("abort", null, [] ![Value])

    state.module.imported.add(function.name)
    push_insn(make_insn(InsnKind::UNREACHABLE), state)
    state.current_block = previous_block
}

def check_for_dependency(svalue: &scope::Value, node: &parser::Node) {
    if node.kind == parser::NodeKind::STRUCT_T or node.kind == parser::NodeKind::UNION_T {
        for var i in 0..node.value.body.length {
            let iddecl = node.value.body(i)
            if iddecl.kind == parser::NodeKind::ID_DECL_STRUCT {
                let tpe = node.value.id_decl_struct.tpe
                check_for_dependency(svalue, tpe)
            } else {
                check_for_dependency(svalue, iddecl)
            }
        }
    } else {
        // TODO This could also refer to functions and other complex types
        scope::create_dependency_on_type(svalue, node)
    }
}

def verify_struct(value: &scope::Value, node: &parser::Node) {
    for var i in 0..node.value.body.length {
        let member = node.value.body(i)
        if member.kind == parser::NodeKind::STRUCT_T or
            member.kind == parser::NodeKind::UNION_T {
            verify_struct(value, member)
        } else {
            let tpe = member.value.id_decl_struct.tpe
            scope::create_dependency_on_type(value, tpe)
        }
    }
}

export def verify_function(node: &parser::Node) {
    if not node or not node.tpe { return }
    let params = node.tpe.parameter_t
    for var i in 0..params.length {
        let param = params(i)
        let n2 = param.type_node
        if not n2 { continue }
        if param.kw == parser::VarDecl::TYPE { continue }
    
        let current_function = errors::current_function
        let current_signature = errors::current_signature
        errors::current_function = node.tpe.type_name
        errors::current_signature = node.signature_hash

        check_for_dependency(node.svalue, n2)

        errors::current_function = current_function
        errors::current_signature = current_signature
    }
}

export def compile(module: &toolchain::Module) {
    compile(module.compiler_state, module.module == "main")
}

export def compile(state: &State, is_main: bool, no_cleanup: bool = false) {
    toolchain::progress_update(state.module, toolchain::ProgressUpdate::START) 

    let node = state.module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    let finalizer_ident = parser::make_identifier("__finalizer__")
    let finalizer = typechecking::make_function_type_n(
        finalizer_ident, 
        vector::make(typechecking::NamedParameter), 
        vector::make(type &typechecking::Type), state.module
    )
    state.module.result.finalizer = finalizer

    let finalizer_start_block = make_block()
    state.finalizer = predeclare_function(finalizer, state.module)
    state.finalizer.forward_declare = false
    state.finalizer.block = finalizer_start_block
    state.finalizer.dllexport = true

    if builtins::builtins.fields.contains("DEBUG_REF_CYCLES") {
        state.file_name_value = create_global_string(state.module.module, state)
    }

    import_structures(builtins::Type_, state.module)

    let body = vector::make(type &parser::Node)

    if not toolchain::is_preload(state.module) {
        // compile standard library
        let cstd_ident = parser::make_identifier("cstd")
        let cstd = toolchain::compile_module(cstd_ident, state.module)
        toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE) 

        insert_module_main(cstd, cstd_ident, node.scope, body, state)

        if not toolchain::no_stdlib {
            let std_ident = parser::make_identifier("std")
            let runtime_ident = parser::make_identifier("runtime")
            let optional_ident = parser::make_identifier("optional")

            let std = toolchain::compile_module(std_ident, state.module)
            toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)

            let runtime = toolchain::compile_module(runtime_ident, state.module) 
            toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)

            let optional = toolchain::compile_module(optional_ident, state.module)
            toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE) 

            insert_module_main(std, std_ident, node.scope, body, state)
            insert_module_main(runtime, runtime_ident, node.scope, body, state)
            insert_module_main(optional, optional_ident, node.scope, body, state)
        }
    }

    if is_main {
        // Import types
        let type_indent = parser::make_identifier("type")
        insert_module_main(toolchain::types , type_indent, node.scope, body, state)

        // Import runtime
        let runtime_ident = parser::make_identifier("runtime")
        insert_module_main(toolchain::runtime_ , runtime_ident, node.scope, body, state)

        /*// Import preload
        let preload_ident = parser::make_identifier("preload")
        let preload = toolchain::compile_module(preload_ident) 
        insert_module_main(preload, preload_ident, node.scope, body, state)*/
    }

    var globals: &Value = null
    // Create compilation unit and file
    if toolchain::debug_sym {
        var dirname = dirname(state.module.filename)
        if length(dirname) == 0 { dirname = "." }
        let abspath = absolute_path(dirname)
        let file = basename(state.module.filename)

        let dvalues1 = allocate_ref(DebugParam, 2)
        dvalues1(0) = [
            name = "filename", value = [ kind = DebugValueKind::STRING, s = file ] !DebugValue
        ] !DebugParam
        dvalues1(1) = [
            name = "directory", value = [ kind = DebugValueKind::STRING, s = abspath ] !DebugValue
        ] !DebugParam

        let difile = [
            kind = ValueKind::DEBUG_INFO,
            metadata = true,
            name = "DIFile",
            debug_values = dvalues1
        ] !&Value
        state.difile = push_meta(difile, state)
        state.discope.push(state.difile)

        globals = [] !Value // TODO What is this supposed to do?
        let dvalues2 = allocate_ref(DebugParam, 6)
        dvalues2(0) = [
            name = "language", value = [ kind = DebugValueKind::CONST, name = "DW_LANG_C99" ] !DebugValue
        ] !DebugParam
        dvalues2(1) = [
            name = "file", value = meta_to_debug_value(state.difile)
        ] !DebugParam
        dvalues2(2) = [
            name = "producer", value = [ kind = DebugValueKind::STRING, s = constants::version ] !DebugValue
        ] !DebugParam
        dvalues2(3) = [
            name = "isOptimized", value = [ kind = DebugValueKind::BOOL, i = 0 ] !DebugValue
        ] !DebugParam
        dvalues2(4) = [
            name = "emissionKind", value = [ kind = DebugValueKind::CONST, name = "FullDebug" ] !DebugValue
        ] !DebugParam
        dvalues2(5) = [
            name = "globals", value = meta_to_debug_value(push_meta(globals, state))
        ] !DebugParam

        let diunit = [
            kind = ValueKind::DEBUG_INFO,
            metadata = true,
            distinct = true,
            name = "DICompileUnit",
            debug_values = dvalues2
        ] !&Value
        state.diunit = push_meta(diunit, state)

        let values = allocate_ref(Value, 1)
        values(0) = @state.diunit
        let dbgcu = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values
        ] !&Value
        state.module.result.metadata("llvm.dbg.cu") = dbgcu

        let values2 = allocate_ref(Value, 3)
        #if defined WIN32 {
            values2(0) = [ kind = ValueKind::INT, i = 2, tpe = builtins::int_ ] !Value
            values2(1) = [ kind = ValueKind::STRING, metadata = true, s = "CodeView" ] !Value
            values2(2) = [ kind = ValueKind::INT, i = 1, tpe = builtins::int_ ] !Value
        } else {
            values2(0) = [ kind = ValueKind::INT, i = 7, tpe = builtins::int_ ] !Value
            values2(1) = [ kind = ValueKind::STRING, metadata = true, s = "Dwarf Version" ] !Value
            values2(2) = [ kind = ValueKind::INT, i = 4, tpe = builtins::int_ ] !Value
        }
        let dwarfv = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values2
        ] !&Value
        let dwarfvp = push_meta(dwarfv, state)

        let values3 = allocate_ref(Value, 3)
        values3(0) = [ kind = ValueKind::INT, i = 2, tpe = builtins::int_ ] !Value
        values3(1) = [ kind = ValueKind::STRING, metadata = true, s = "Debug Info Version" ] !Value
        values3(2) = [ kind = ValueKind::INT, i = 3, tpe = builtins::int_ ] !Value
        let div = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values3
        ] !&Value
        let divp = push_meta(div, state)

        let values4 = allocate_ref(Value, 3)
        values4(0) = [ kind = ValueKind::INT, i = 1, tpe = builtins::int_ ] !Value
        values4(1) = [ kind = ValueKind::STRING, metadata = true, s = "wchar_size" ] !Value
        #if defined WIN32 {
            values4(2) = [ kind = ValueKind::INT, i = 2, tpe = builtins::int_ ] !Value
        } else {
            values4(2) = [ kind = ValueKind::INT, i = 4, tpe = builtins::int_ ] !Value
        }

        let wchars = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values4
        ] !&Value
        let wcharsp = push_meta(wchars, state)
        
        let values5 = allocate_ref(Value, 3)
        values5(0) = @dwarfvp
        values5(1) = @divp
        values5(2) = @wcharsp
        let flags = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values5
        ] !&Value
        state.module.result.metadata("llvm.module.flags") = flags

        let values6 = allocate_ref(Value, 1)
        values6(0) = [ kind = ValueKind::STRING, metadata = true, s = constants::version ] !Value
        let identv = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values6
        ] !&Value
        let identp = push_meta(identv, state)

        let values7 = allocate_ref(Value, 1)
        values7(0) = @identp
        let ident = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values7
        ] !&Value
        state.module.result.metadata("llvm.ident") = ident
    }
    
    // Forward declare functions from other files
    // TODO This doesn't work for functions that return multiple parameters
    predeclare_functions(state.module)
    create_dyn_dispatch(state.module.dyn_dispatch, state)

    let ident = parser::make_identifier("__main__")
    ident.loc.module = state.module.module
    ident.loc.filename = state.module.filename
    ident.loc.line = 0
    ident.loc.column = 0

    let main_tpe = scope::get(state.module.scope, ident).tpe
    let main_function = predeclare_function(main_tpe, state.module)
    main_function.dllexport = true

    for var i in 0..vector::length(node.body) {
        let n = node.body(i)
        if n.kind == parser::NodeKind::DEF and not typechecking::is_polymorph(n.tpe) {
            let function = n.value.def_.function
            if function {
                predeclare_function(function, overwrite = true)
            }
        } else if n.kind == parser::NodeKind::TYPE_DECL {
            let left = n.value.type_decl.left
            for var i in 0..vector::length(left) {
                let n2 = vector::get(left, i) !*parser::Node
                let tpe = n2.tpe
                if typechecking::is_struct(tpe) {
                    for var i in 0..tpe.fields.size {
                        typechecking::lookup_struct_member(tpe.fields(i))
                    }
                }
            }
        }
    }

    state.scope = state.module.scope
    state.current_block = state.module.code
    state.function_stack.push(main_function)
    
    for var i in 0..vector::length(node.body) {
        let n = node.body(i)
        switch (@n).kind !int {
            case parser::NodeKind::DEF
                if n.value.def_.body and not typechecking::is_polymorph(n.tpe) {
                    if not n.value.def_.is_generic_instance { verify_function(n) }
                    create_function(
                        n, n.tpe, n.value.def_.body, n.inner_scope, null, state
                    )
                }
            case parser::NodeKind::TYPE_DECL
                walk_TypeDecl(n, state)
            case parser::NodeKind::VAR_DECL
                walk_top_VarDecl(n, body, state)
            case parser::NodeKind::IMPORT
                walk_top_Import(n, body, state)
            case
                body.push(n)
        }
    }

    create_function(ident, main_tpe, body, node.scope, state.module.code, state, true)

    if toolchain::debug_sym {
        let keys = map::keys(state.module.result.globals)
        let values = vector::make(Value)
        for var i in 0..keys.size {
            let global = state.module.result.globals(keys(i))
            if not global.is_var_decl { continue }

            let debug_values = allocate_ref(DebugParam, 6)
            debug_values(0) = [
                name = "name", value = [ kind = DebugValueKind::STRING, s = (@global).name ] !DebugValue
            ] !DebugParam
            debug_values(1) = [
                name = "scope", value = meta_to_debug_value(state.diunit)
            ] !DebugParam
            debug_values(2) = [
                name = "file", value = meta_to_debug_value(state.difile)
            ] !DebugParam
            debug_values(3) = [
                name = "line", value = [ kind = DebugValueKind::INT, i = (@global).line + 1 ] !DebugValue
            ] !DebugParam
            debug_values(4) = [
                name = "type", value = meta_to_debug_value(di_type((@global).tpe, state))
            ] !DebugParam
            debug_values(5) = [
                name = "isDefinition", value = [ kind = DebugValueKind::BOOL, i = (not (@global).external) !int ] !DebugValue
            ] !DebugParam

            let diglobal = [
                kind = ValueKind::DEBUG_INFO,
                name = "DIGlobalVariable",
                debug_values = debug_values,
                distinct = true
            ] !&Value
            let diglobalp = push_meta(diglobal, state)

            let debug_values2 = allocate_ref(DebugParam, 2)
            debug_values2(0) = [
                name = "var", value = meta_to_debug_value(diglobalp)
            ] !DebugParam
            debug_values2(1) = [
                name = "expr", value = [ kind = DebugValueKind::DIEXP ] !DebugValue
            ] !DebugParam

            let diglobal_expr = [
                kind = ValueKind::DEBUG_INFO,
                name = "DIGlobalVariableExpression",
                debug_values = debug_values2
            ] !&Value
            let diglobal_exprp = push_meta(diglobal_expr, state)

            values.push(@diglobal_exprp)
            (@global).debug = diglobal_exprp
        }
        @globals = [
            kind = ValueKind::STRUCT,
            metadata = true,
            values = values.to_array()
        ] !Value
    }

    state.function_stack.pop()

    let old_block = state.current_block
    state.function_stack.push(state.finalizer)
    state.current_block = state.finalizer.block

    // Insert destructors for global values
    let keys = map::reverse_keys(node.scope.fields)
    for var i in 0..keys.size {            
        let value = node.scope.fields(keys(i))
        if value.modifier == parser::VarDecl::TYPE or 
            value.modifier == parser::VarDecl::CONST {
            continue
        }

        // Create destructor
        insert_destructor([ kind = ValueKind::GLOBAL, tpe = pointer(value.tpe), name = value.assembly_name(state) ] !Value, null, state)
    }

    if builtins::builtins.fields.contains("DEBUG_REF_CYCLES") and state.module.module == "main" {
        let fun = toolchain::find_module("std").scope.get(parser::make_identifier("find_cycles")).tpe
        predeclare_function(fun, state.module)
        state.module.imported.add(fun.type_name)
        state.call(fun.type_name, null, [] ![Value])
    }

    state.ret(NO_VALUE)
    state.current_block = old_block
    state.finalizer.block = finalizer_start_block
    vector::insert(finalizer_start_block.insn, 0, state.current_function.allocas)

    if no_cleanup {
        // In the repl we clear out the finalizer
        state.finalizer.block = make_block()
    }

    insert_function(state.module, state.finalizer)
    state.module.imported.add(state.finalizer.name)
    state.function_stack.pop()

    toolchain::progress_update(state.module, toolchain::ProgressUpdate::END)
}

export def compile(node: &parser::Node, state: &State) {
    let ident = parser::make_identifier("__main__")
    ident.loc.module = state.module.module
    ident.loc.filename = state.module.filename
    ident.loc.line = 0
    ident.loc.column = 0

    state.module.code = make_block()

    let main_tpe = scope::get(state.module.scope, ident).tpe
    let main_function = predeclare_function(main_tpe, state.module)

    let body = vector::make(type &parser::Node)

    for var i in 0..vector::length(node.body) {
        let n = node.body(i)
        switch (@n).kind !int {
            case parser::NodeKind::DEF
                if n.tpe and not typechecking::is_polymorph(n.tpe) {
                    verify_function(n)
                }
            case parser::NodeKind::TYPE_DECL, 
                parser::NodeKind::VAR_DECL
            case parser::NodeKind::IMPORT
                walk_top_Import(n, body, state)
            case
                body.push(n)
        }
    }

    create_function(ident, main_tpe, body, node.scope, state.module.code, state, true)
}
