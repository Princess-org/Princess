// TODO Many of these function will error twice with misleading errors
// Every function needs to check for possible null types and null nodes
// and abort in those cases

import map
import vector
import parser
import buffer
import util
import scope
import builtins
import debug
import toolchain
import compiler
import consteval
import errors
import runtime
import eval

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    TUPLE
    POINTER
    REFERENCE
    WEAK_REF
    ARRAY
    STATIC_ARRAY
    RANGE
    RANGE_INC
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
    // Placeholder for arguments with polymorphic type parameter in function definition
    TYPE_DEF
    // Null
    NULL
    UNDEF
    CHAR
    STRUCTURAL
    // This is a type with arguments
    TYPE_CONSTRUCTOR
    // This is used as a function parameter that is generic
    GENERIC
    // This is used to express types that may by resolved to multiple types
    // Right now this is only used for looking up functions in generic interfaces
    // but it could be turned into actual union types
    VARIANT
    VOID
}

export type TypeMember = struct {
    tpe: *Type
    offset: size_t
}

export type StructMember = struct {
    // Source line
    line: int
    node: *parser::Node
    name: string
    tpe: *Type
    // index into the field_types vector
    index: size_t

    is_bitfield: bool
    bit_size: size_t
    bit_offset: size_t
}

export type StructuralTypeMember = struct {
    name: string
    // Vector of NamedParameter
    parameter_t: *vector::Vector
    // Vector of Type
    return_t: *vector::Vector
}

export type Type = struct {
    kind: TypeKind
    // Source line
    line: int
    module: *toolchain::Module
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: string
    // Unique name of the type
    type_name: string
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // Static array
    length: size_t
    kw: parser::VarDecl
    // Type both used for array/pointer and enum
    // This is also used for type arguments to specify the actual type
    tpe: *Type
    packed: bool
    // Fields for struct, array of StructMember
    fields: [StructMember]
    // Vector of TypeMember
    field_types: *vector::Vector
    // Function and Tuple
    // TODO This really doesn't belong on here, it's an attribute of a value
    dllimport: bool
    // Vector of Type
    return_t: *vector::Vector
    // Vector of NamedParameter
    parameter_t: *vector::Vector
    // Enum scope
    scope: *scope::Scope
    // For functions
    imported: bool
    // Structural types
    // Vector of StructuralTypeMember
    members: *vector::Vector
    share: parser::ShareMarker
    // Type constructors save a template of a type
    node: *parser::Node
    // Cache of specialized type constructor
    cache: *map::Map
    // Type constructor instances have a type and arguments
    tc_tpe: *Type
    // Vector of Type, also used by GENERIC
    tc_args: *vector::Vector
    // True if some parameters weren't set yet
    tc_incomplete: bool
    // null means any, Vector of Type
    variants: *vector::Vector
    has_destructor: int8
    has_copy_constructor: int8
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: string
    tpe: *Type
    varargs: bool
    node: *parser::Node
    value: *compiler::Value
}

export type Function = struct {
    is_global: bool
    tpe: *Type
    locals: *map::Map
    has_defer: bool
}

export type State = struct {
    module: *toolchain::Module
    counter: int
    scope: *scope::Scope
    // Vector of Type
    function_stack: *vector::Vector
    // Used by consteval
    is_static: bool
    in_defer: bool
}

export def current_function(state: *State) -> *Function {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return vector::get((@state).function_stack, length - 1) !*Function
    }
}

export def push_function(state: *State, function: *Function) {
    vector::push((@state).function_stack, function)
}

export def pop_function(state: *State) -> *Function {
    return vector::pop((@state).function_stack) !*Function
}

export def is_function(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_function_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER and 
        is_function((@tpe).tpe)
}

export def is_integer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::BOOL or 
        tpe.kind == TypeKind::ENUM or
        tpe.kind == TypeKind::CHAR
}

export def is_arithmetic(tpe: *Type) -> bool {
    if not tpe { return false }
    return is_integer(tpe) or 
        (@tpe).kind == TypeKind::FLOAT
}

export def is_float(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FLOAT
}

// TODO Also allow arrays and strings
export def is_boolean(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::REFERENCE or
        (@tpe).kind == TypeKind::WEAK_REF or
        tpe.kind == TypeKind::CHAR
}

export def is_pointer(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER
    // TODO What about references?
}

export def is_ref(tpe: *Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::REFERENCE
}

export def is_weak_ref(tpe: *Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::WEAK_REF
}

export def is_ref_or_weak(tpe: *Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::WEAK_REF or
        tpe.kind == TypeKind::REFERENCE
}

export def is_box(tpe: *Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::POINTER or
        tpe.kind == TypeKind::REFERENCE or
        tpe.kind == TypeKind::WEAK_REF or
        tpe.kind == TypeKind::STATIC_ARRAY or
        tpe.kind == TypeKind::ARRAY
}

export def is_struct(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::STRUCT or
        (@tpe).kind == TypeKind::UNION
}

export def is_enum(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ENUM
}

export def is_type(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::TYPE
}

export def is_array(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY
}

export def is_range(tpe: *Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::RANGE or
        (@tpe).kind == TypeKind::RANGE_INC
}

export def is_stub(tpe: *Type) -> bool {
    if not tpe { return true }
    return tpe.kind == TypeKind::STUB
}

export def is_interface(tpe: *Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::STRUCTURAL
}

export def get_interface(tpe: *Type) -> *Type {
    if not tpe { return null }
    if is_array(tpe) or is_ref(tpe) or is_pointer(tpe) {
        return get_interface(tpe.tpe)
    }
    if tpe.kind == TypeKind::STRUCTURAL {
        return tpe
    }
    return null
}

export def append_module(name: string, module: string) -> string {
    var buf = buffer::make_buffer()
    if length(module) > 0 {
        buffer::append_str(*buf, module)
        buffer::append_str(*buf, "::")
    }
    buffer::append_str(*buf, name)
    return buffer::to_string(*buf)
}

export def make_type_raw(kind: TypeKind) -> *Type {
    let tpe = allocate(Type)
    @tpe = {
        type_name = "",
        name = "",
        line = -1,
        kind = kind
    }
    return tpe
}

export def make_type(kind: TypeKind, node: *parser::Node) -> *Type {
    assert(node.kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = make_type_raw(kind)
    (@t).line = node.loc.line
    (@t).type_name = append_module(name, node.loc.module)
    (@t).name = name

    return t
}

export def make_function_type() -> *Type {
    let tpe = make_type_raw(TypeKind::FUNCTION)
    (@tpe).size = size_of type () -> ()
    (@tpe).align = align_of type () -> ()
    (@tpe).imported = false
    return tpe
}

export def make_function_type_n(
    name: *parser::Node, 
    parameter_t: *vector::Vector, 
    return_t: *vector::Vector, 
    module: *toolchain::Module = null,
    extern: bool = false, 
    imported: bool = false, 
    dllimport: bool = false
) -> *Type {

    let tpe = make_function_type()
    tpe.parameter_t = parameter_t
    tpe.return_t = return_t
    tpe.name = parser::identifier_to_str(name, false)
    if extern {
        tpe.type_name = tpe.name
    } else {
        let name = append_module(tpe.name, module.module) if module else tpe.name
        tpe.type_name = mangle_function_name(name, parameter_t)
    }
    tpe.line = name.loc.line
    tpe.imported = imported
    tpe.dllimport = dllimport
    tpe.module = module
    return tpe
}

export def pointer(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::POINTER)
    (@t).tpe = tpe
    (@t).kw = kw
    (@t).size = (size_of type *)
    (@t).align = (align_of type *)
    return t
}

// TODO Use default arguments for this, right now its bugged (it doesn't define the type)
export def pointer(tpe: *Type) -> *Type {
    return pointer(tpe, parser::VarDecl::VAR)
}

export def reference(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::REFERENCE)
    t.tpe = tpe
    t.kw = kw
    // TODO replace with correct size_of once this is implemented
    t.size = (size_of runtime::Ref)
    t.align = (align_of runtime::Ref)
    return t
}

export def reference(tpe: *Type) -> *Type {
    return reference(tpe, parser::VarDecl::VAR)
}

export def weak_reference(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::WEAK_REF)
    t.tpe = tpe
    t.kw = kw
    t.size = (size_of runtime::Ref)
    t.align = (align_of runtime::Ref)
    return t
}

export def weak_reference(tpe: *Type) -> *Type {
    return weak_reference(tpe, parser::VarDecl::VAR)
}

export def array(tpe: *Type, kw: parser::VarDecl) -> *Type {
    var t = make_type_raw(TypeKind::ARRAY)
    (@t).tpe = tpe
    // TODO This is really bad, sure string is an array but we can do better than this
    (@t).size = (size_of string)
    (@t).align = (align_of string)
    (@t).kw = kw
    return t
}

export def array(tpe: *Type) -> *Type {
    return array(tpe, parser::VarDecl::VAR)
}

export def make_static_array(array_tpe: *Type, size: size_t, kw: parser::VarDecl) -> *Type {
    let tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@tpe).tpe = array_tpe
    (@tpe).length = size
    (@tpe).size = (@tpe).length * (@array_tpe).size
    (@tpe).align = (@array_tpe).align
    (@tpe).kw = kw
    return tpe
}

export def make_static_array(array_tpe: *Type, size: size_t) -> *Type {
    return make_static_array(array_tpe, size, parser::VarDecl::VAR)
}

def make_unique_name(name: string, state: *State) -> string {
    let buf = buffer::make_buffer()
    buffer::append_str(*buf, name)
    buffer::append_char(*buf, '.')
    let s = util::int_to_str((@state).counter)
    buffer::append_str(*buf, s)

    (@state).counter += 1
    return buffer::to_string(*buf)
}

// Map of type names to identify which ones
// implement structural types
// Map of TypeEntry
export let types_map = map::make()

// The repl needs to invalidate the cache
export def clear_type_cache {
    let keys = map::keys(types_map)
    for var i in 0..keys.size {
        let key = keys[i]
        let type_entry = map::get(types_map, key) !*TypeEntry
        map::clear(type_entry.cached)
    }
}

def do_get_member_functions(name: string, vec: *vector::Vector) {
    let type_entry = map::get(types_map, name) !*TypeEntry
    if not type_entry { return }
    if type_entry.functions {
        vector::insert(vec, 0, type_entry.functions)
    }
}

export def get_member_functions(tpe: *Type) -> *vector::Vector {
    if not tpe { return vector::make() }

    tpe = copy(tpe)
    var tpe2 = get_generic(tpe)
    if tpe2 {
        let vec = vector::make()
        let name = debug::type_to_str(tpe, full_name = true)
        do_get_member_functions(name, vec)

        let tc_args = vector::copy(tpe2.tc_args)
        let len = vector::length(tpe2.tc_args)

        // TODO The complexity of this increases rapidly
        for var i in 0..len {
            tpe2.tc_args = vector::copy(tc_args)
            for var j in i..len {
                let type_def = make_type_raw(TypeKind::TYPE_DEF)
                vector::set(tpe2.tc_args, i, type_def)
                tpe2.tc_incomplete = true
                let name = debug::type_to_str(tpe2, full_name = true)
                do_get_member_functions(name, vec)
            }
        }
        return vec
    } else {
        let vec = vector::make()
        let name = debug::type_to_str(tpe, full_name = true)
        do_get_member_functions(name, vec)
        return vec
    }
}

export let CONTAINS     = 1 !*
export let NOT_CONTAINS = 2 !*

export type TypeEntry = struct {
    tpe: *Type
    // Vector of TypeEntryMember
    functions: *vector::Vector
    cached: *map::Map    
}

export type TypeEntryMember = struct {
    function: *Type
    exported: bool
    module: *toolchain::Module
}

export def create_type_entry(tpe: *Type) -> *TypeEntry {
    let name = debug::type_to_str(tpe, full_name = true)
    var type_entry = map::get(types_map, name) !*TypeEntry
    if not type_entry {
        type_entry = allocate(TypeEntry)
        @type_entry = {
            tpe = tpe,
            functions = vector::make(),
            cached = map::make()
        } !TypeEntry
        map::put(types_map, name, type_entry)
    }
    return type_entry
}

export def create_type_entry(tpe: *Type, exported: bool, entry: *Type, module: *toolchain::Module, overwrite: bool = false) -> bool {
    let type_entry = create_type_entry(tpe)

    let member_function = allocate(TypeEntryMember)
    @member_function = {
        function = shallow_copy(entry),
        exported = exported,
        module = module
    } !TypeEntryMember

    // TODO Use a set for this
    for var i in 0..vector::length(type_entry.functions) {
        let fun = vector::get(type_entry.functions, i) !*TypeEntryMember
        if fun.function.type_name == entry.type_name {
            if overwrite { vector::set(type_entry.functions, i, member_function) }
            return false 
        }
    }

    vector::push(type_entry.functions, member_function)
    return true
}

export def copy_parameter_t(parameter_t: *vector::Vector) -> *vector::Vector {
    let new = vector::make()
    for var i in 0..vector::length(parameter_t) {
        let np = vector::get(parameter_t, i) ! *NamedParameter
        let np2 = allocate(NamedParameter)
        @np2 = @np
        np2.tpe = copy(np.tpe)
        vector::push(new, np2)
    }
    return new
}

export def copy_return_t(return_t: *vector::Vector) -> *vector::Vector {
    let new = vector::make()
    for var i in 0..vector::length(return_t) {
        vector::push(new, copy(vector::get(return_t, i) !*Type))
    }
    return new
}

// TODO Not a deep copy
export def copy(a: *Type) -> *Type {
    if not a { return null }
    var t = allocate(Type)
    @t = @a

    if a.tc_args {
        t.tc_args = vector::make()
        for var i in 0..vector::length(a.tc_args) {
            let arg = vector::get(a.tc_args, i) !*Type
            vector::push(t.tc_args, copy(arg))
        }
    }

    if a.kind == TypeKind::FUNCTION {
        t.return_t = copy_return_t(a.return_t)
        t.parameter_t = copy_parameter_t(a.parameter_t)
    } else if is_box(a) or
        a.kind == TypeKind::TYPE_DEF or
        a.kind == TypeKind::TYPE {
        t.tpe = copy(a.tpe)
    }

    return t
}

export def shallow_copy(tpe: *Type) -> *Type {
    var ret = allocate(Type)
    @ret = @tpe
    if tpe.kind == TypeKind::FUNCTION {
        ret.return_t = vector::copy(tpe.return_t)
        ret.parameter_t = vector::make()
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter
            let np2 = allocate(NamedParameter)
            @np2 = @np
            vector::push(ret.parameter_t, np2)
        }
    }
    return ret
}

export def equals(a: *Type, b: *Type) -> bool {
    if a == b {
        return true
    }
    if not a or not b { return false }

    if a.tc_args and b.tc_args and a.tc_tpe and b.tc_tpe and equals(a.tc_tpe, b.tc_tpe) {
        for var i in 0..vector::length(a.tc_args) {
            let x = vector::get(a.tc_args, i) !*Type
            let y = vector::get(b.tc_args, i) !*Type
            if not equals(x, y) { return false }
        }
        return true
    }

    if a.kind == TypeKind::STUB or b.kind == TypeKind::STUB {
        return a.type_name == b.type_name
    }
    if a.kind == TypeKind::VARIANT or b.kind == TypeKind::VARIANT and a.kind != b.kind {
        if b.kind == TypeKind::VARIANT {
            let c = a; a = b; b = c;
        }
        if not a.variants { return true }
        for var i in 0..vector::length(a.variants) {
            if equals(vector::get(a.variants, i) !*Type, b) { return true }
        }
        return false
    }

    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind
    if kind == TypeKind::BOOL or kind == TypeKind::TYPE or kind == TypeKind::CHAR { return true }
    if kind == TypeKind::WORD {
        return (@a).size == (@b).size and (@a).unsig == (@b).unsig
    }
    if kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION or
        kind == TypeKind::STUB or
        kind == TypeKind::STRUCTURAL or
        kind == TypeKind::TYPE_CONSTRUCTOR {
        
        return (@a).type_name == (@b).type_name
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::REFERENCE or
        kind == TypeKind::WEAK_REF {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION {
        if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) or
            vector::length((@a).return_t) != vector::length((@b).return_t) {
            return false        
        }
        for var i in 0..vector::length((@a).parameter_t) {
            let param_a = vector::get((@a).parameter_t, i) !*NamedParameter
            let param_b = vector::get((@b).parameter_t, i) !*NamedParameter
            if not equals((@param_a).tpe, (@param_b).tpe) {
                return false
            }
        }
        for var i in 0..vector::length((@a).return_t) {
            if not equals(vector::get((@a).return_t, i) !*Type, vector::get((@b).return_t, i) !*Type) {
                return false
            }
        }
        return true
    }
    if kind == TypeKind::TYPE_DEF {
        return equals(a.tpe, b.tpe)
    }
    if kind == TypeKind::GENERIC {
        if equals(a.tpe, b.tpe) {
            if vector::length(a.tc_args) != vector::length(b.tc_args) { return false }
            for var i in 0..vector::length(a.tc_args) {
                let arg_a = vector::get(a.tc_args, i) !*Type
                let arg_b = vector::get(b.tc_args, i) !*Type
                if not equals(arg_a, arg_b) { return false }
            }
            return true
        }
        return false
    }

    assert(false)
}

def has_function(entry: *TypeEntry, mb: *StructuralTypeMember, module: *toolchain::Module) -> bool {
    for var i in 0..vector::length(entry.functions) {
        let member = vector::get(entry.functions, i) !*TypeEntryMember
        let function = member.function
        if function.name != mb.name { continue }
        if module != member.module and not member.exported { continue }

        if vector::length(function.parameter_t) != vector::length(mb.parameter_t) + 1 { continue }
        var mismatch = false
        for var k in 0..vector::length(mb.parameter_t) {
            let npa = vector::get(function.parameter_t, k + 1) !*NamedParameter
            let npb = vector::get(mb.parameter_t, k) !*NamedParameter
            if not equals(npa.tpe, npb.tpe) {
                mismatch = true
                break
            }
        }
        if mismatch { continue }

        if vector::length(function.return_t) != vector::length(mb.return_t) { continue }
        for var k in 0..vector::length(mb.return_t) {
            let ta = vector::get(function.return_t, k) !*Type
            let tb = vector::get(mb.return_t, k) !*Type
            if not equals(ta, tb) {
                mismatch = true
                break
            }
        }
        if mismatch { continue }
        return true
    }
    return false
}

// Returns true if a implements b
// b needs to be a structural type
export def implements(a: *Type, b: *Type, module: *toolchain::Module) -> bool {
    assert b.kind == TypeKind::STRUCTURAL

    var type_entry = create_type_entry(a)
    let nameb = debug::type_to_str(b, full_name = true)
    let cached = map::get(type_entry.cached, nameb)
    if cached {
        return cached == CONTAINS
    }

    if a.kind == TypeKind::STRUCTURAL {
        for var i in 0..vector::length(b.members) {
            let mb = vector::get(b.members, i) !*StructuralTypeMember

            var found = false
            for var j in 0..vector::length(a.members) {
                let ma = vector::get(a.members, j) !*StructuralTypeMember
                if ma.name != mb.name { continue }
                if vector::length(ma.parameter_t) != vector::length(mb.parameter_t) { continue }

                var mismatch = false
                for var k in 0..vector::length(ma.parameter_t) {
                    let npa = vector::get(ma.parameter_t, k) !*NamedParameter
                    let npb = vector::get(mb.parameter_t, k) !*NamedParameter
                    if not equals(npa.tpe, npb.tpe) {
                        mismatch = true
                        break
                    }
                }
                if mismatch { continue }

                if vector::length(ma.return_t) != vector::length(mb.return_t) { continue }
                
                for var k in 0..vector::length(ma.return_t) {
                    let ta = vector::get(ma.return_t, k) !*Type
                    let tb = vector::get(mb.return_t, k) !*Type
                    if not equals(ta, tb) {
                        mismatch = true
                        break
                    }
                }
                if mismatch { continue }
            
                found = true
            }
            if not found {
                found = has_function(type_entry, mb, module)
            }
            if not found { 
                map::put(type_entry.cached, nameb, NOT_CONTAINS)
                return false 
            }
        }
        map::put(type_entry.cached, nameb, CONTAINS)
        return true
    } else {
        for var i in 0..vector::length(b.members) {
            let mb = vector::get(b.members, i) !*StructuralTypeMember
            if not has_function(type_entry, mb, module) { 
                map::put(type_entry.cached, nameb, NOT_CONTAINS)
                return false 
            }
        }
        map::put(type_entry.cached, nameb, CONTAINS)
        return true
    }
}

// Returns true if b is assignable to a
export def is_assignable(a: *Type, b: *Type, module: *toolchain::Module) -> bool {
    return convert_type_score(a, b, module) >= 0
}

// TODO This needs caching
def infer_interface_types(a: *Type, b: *Type, module: *toolchain::Module) -> *Type {
    assert a.kind == TypeKind::GENERIC
    // TODO We might want to pass a state instead
    let node = a.tpe.node
    if not node or node.kind != parser::NodeKind::STRUCTURAL_T {
        return null
    }

    let state = make_state(module)

    let variants = map::make()
    state.scope = scope::enter_scope(state.scope)
    for var i in 0..vector::length(a.tpe.parameter_t) {
        let par = vector::get(a.tpe.parameter_t, i) !*NamedParameter
        let variant_tpe = make_type_raw(TypeKind::VARIANT)
        variant_tpe.name = par.name
        map::put(variants, variant_tpe.name, variant_tpe)
        scope::create_type(state.scope, parser::make_identifier([par.name]), parser::ShareMarker::NONE, variant_tpe)
    }

    var found_all = true
    for var i in 0..vector::length(node.value.body) {
        let member = vector::get(node.value.body, i) !*parser::Node
        let function = make_function_type()
        function.parameter_t = vector::make()
        function.return_t = vector::make()
        function.type_name = function.name = parser::identifier_to_str(member.value.structural_member.name)

        let first_arg = allocate(NamedParameter)
        @first_arg = { name = "", tpe = b }
        vector::push(function.parameter_t, first_arg)

        for var j in 0..vector::length(member.value.structural_member.params) {
            let param = vector::get(member.value.structural_member.params, j) !*parser::Node
            let np = allocate(NamedParameter)
            @np = {
                name = parser::identifier_to_str(param.value.param.name),
                tpe = type_lookup(param.value.param.tpe, *state)
            }
            vector::push(function.parameter_t, np)
        }
        for var j in 0..vector::length(member.value.structural_member.returns) {
            let ret = vector::get(member.value.structural_member.returns, j) !*parser::Node
            let tpe = type_lookup(ret, *state)
            vector::push(function.return_t, tpe)
        }

        let functions, result = scope::find_functions(state.scope, member.value.structural_member.name, function)
        if vector::length(functions) == 0 {
            return null
        }
        let keys = map::keys(result)
        for var i in 0..keys.size {
            let key = keys[i]
            let variant_tpe = map::get(variants, key) !*Type
            let variants2 = map::get(result, key) !*vector::Vector
            if variant_tpe.variants {
                let new_variants = vector::make()
                for var i in 0..vector::length(variant_tpe.variants) {
                    let a = vector::get(variant_tpe.variants, i) !*Type
                    var contains_both = false
                    for var j in 0..vector::length(variants2) {
                        let b = vector::get(variants2, j) !*Type
                        if equals(a, b) {
                            contains_both = true
                            break
                        }
                    }
                    if contains_both {
                        vector::push(new_variants, a)
                    }
                }
                if vector::length(new_variants) == 0 {
                    return null
                } else {
                    variant_tpe.variants = new_variants
                }
            } else {
                variant_tpe.variants = variants2
            }
        }
    }

    if found_all {
        let keys = map::keys(variants) 
        for var i in 0..keys.size {
            let key = keys[i]
            let variant = map::get(variants, key) !*Type
            if not variant.variants or vector::length(variant.variants) > 1  {
                return null
            }
        }
    }

    let tpe = copy(b)
    tpe.tc_args = vector::make()
    let keys = map::keys(variants)
    for var i in 0..keys.size {
        let key = keys[i]
        let variant = map::get(variants, key) !*Type
        vector::push(tpe.tc_args, vector::get(variant.variants, 0))
    }

    return tpe
}

// TODO This isn't very reliable. Especially when returning bigger numbers than 1, integer conversions can interfere with to reference
// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
def convert_type_score(a: *Type, b: *Type, module: *toolchain::Module, is_type: bool = false) -> int {
    if not a or not b { return 0 }
    if equals(a, b) {
        return 0
    }
    if a.kind == TypeKind::UNDEF or b.kind == TypeKind::UNDEF { return 0 }

    if (a.kind == TypeKind::REFERENCE or a.kind == TypeKind::WEAK_REF) and 
        (b.kind == TypeKind::REFERENCE or b.kind == TypeKind::WEAK_REF) and 
        (equals(a.tpe, b.tpe) or not a.tpe) {

        return 0 if a.kind == b.kind else 1
    }
    
    let intfp = get_interface(a)
    if intfp {
        if implements(b, intfp, module) { return 1 }
        if a.kind == TypeKind::REFERENCE and implements(reference(b), intfp, module) { return 1 }
        if a.kind == TypeKind::REFERENCE and b.kind == TypeKind::REFERENCE and implements(b.tpe, intfp, module) { return 1 }
        return -1
    }

    // We need to check if they are actually compatible elsewhere
    if a.kind == TypeKind::TYPE_DEF {
        return convert_type_score(a.tpe, b, module, true)
    }
    if a.kind == TypeKind::TYPE and equals(b, pointer(builtins::Type_)) { 
        return 1 
    }
    if (a.kind == TypeKind::POINTER or a.kind == TypeKind::REFERENCE or a.kind == TypeKind::WEAK_REF) and (@b).kind == TypeKind::NULL {
        return 0
    }
    if a.kind == TypeKind::REFERENCE and (is_assignable(a.tpe, b, module) or a.tpe == null or equals(b, builtins::Ref_)) {
        return 5
    }
    if equals(a, builtins::Ref_) and b.kind == TypeKind::REFERENCE {
        return 5
    }
    if ((@a).kind == TypeKind::WORD or a.kind == TypeKind::CHAR) and 
        ((@b).kind == TypeKind::WORD or b.kind == TypeKind::CHAR) and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 1
    }
    if (@a).kind == TypeKind::FLOAT and
        ((@b).kind == TypeKind::WORD or b.kind == TypeKind::CHAR) {
        return 10
    }
    if ((@a).kind == TypeKind::POINTER and (@b).kind == TypeKind::POINTER or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 1
    }
    if a.kind == TypeKind::POINTER and b.kind == TypeKind::POINTER or
        a.kind == TypeKind::REFERENCE and b.kind == TypeKind::REFERENCE or
        a.kind == TypeKind::WEAK_REF and b.kind == TypeKind::WEAK_REF or
        a.kind == TypeKind::ARRAY and b.kind == TypeKind::ARRAY or
        a.kind == TypeKind::STATIC_ARRAY and b.kind == TypeKind::STATIC_ARRAY {

        if a.tpe and a.tpe.kind == TypeKind::GENERIC {
            return convert_type_score(a.tpe, b.tpe, module, is_type)
        }
    } 

    if a.kind == TypeKind::STATIC_ARRAY and b.kind == TypeKind::STATIC_ARRAY {
        if equals(a.tpe, b.tpe) and 
            (a.length == b.length or a.length !uint64 == util::MAX_UINT64) {
            return 0
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY and equals((@a).tpe, (@b).tpe) {
            return 1
        }
        if (@a).tpe == null and ((@b).kind == TypeKind::ARRAY or (@b).kind == TypeKind::STATIC_ARRAY) {
            return 1
        }
    }
    if a.kind == TypeKind::GENERIC {
        if a.kind != b.kind {
            if b.tc_args and equals(a.tpe, b.tc_tpe) {
                if vector::length(a.tc_args) != vector::length(b.tc_args) { return -1 }
                for var i in 0..vector::length(a.tc_args) {
                    let arg_a = vector::get(a.tc_args, i) !*Type
                    let arg_b = vector::get(b.tc_args, i) !*Type
                    if arg_a.kind == TypeKind::TYPE_DEF { continue }
                    if not equals(arg_a, arg_b) { return -1 }
                }
                return 1
            } else {
                return 1 if infer_interface_types(a, b, module) != null else -1
            }
        } else {
            return 0 if equals(a.tpe, b.tpe) else -1
        }
    }

    if is_type { 
        if a.kind == TypeKind::ARRAY {
            if (b.kind == TypeKind::ARRAY or b.kind == TypeKind::STATIC_ARRAY) {
                return convert_type_score(a.tpe, b.tpe, module, true)
            }
            return -1
        }
        if a.kind == TypeKind::POINTER or a.kind == TypeKind::REFERENCE or a.kind == TypeKind::WEAK_REF or a.kind == TypeKind::STATIC_ARRAY {
            if a.kind == b.kind {
                return convert_type_score(a.tpe, b.tpe, module, true)
            }
            if convert_type_score(a.tpe, b, module, true) >= 0 {
                return 10
            }
            return -1
        }
        return 5
    }
    return -1
}

export def get_type_constructor(tpe: *Type) -> *Type {
    if not tpe { return null }
    if tpe.tc_tpe { return tpe.tc_tpe }
    if tpe.kind == TypeKind::GENERIC {
        return tpe.tpe
    }
    if is_box(tpe) {
        return get_type_constructor(tpe.tpe)
    }
    return null
}

export def get_generic(tpe: *Type) -> *Type {
    if not tpe { return null }
    if tpe.tc_args { return tpe }
    if is_box(tpe) {
        return get_generic(tpe.tpe)
    }
    return null
}

export def is_polymorph(tpe: *Type, is_ref: bool = false) -> bool {
    if not tpe { return false }
    else if tpe.kind == TypeKind::STRUCTURAL {
        return not is_ref 
    } else if tpe.tc_args {
        return tpe.tc_incomplete
    } else if tpe.kind == TypeKind::TYPE_DEF {
        return true
    } else if tpe.kind == TypeKind::GENERIC {
        return tpe.tc_incomplete
    } else if tpe.kind == TypeKind::TYPE {
        return tpe.tpe == null
    } else if tpe.kind == TypeKind::POINTER or
        tpe.kind == TypeKind::STATIC_ARRAY or tpe.kind == TypeKind::ARRAY {
        return is_polymorph(tpe.tpe)
    } else if tpe.kind == TypeKind::REFERENCE {
        return is_polymorph(tpe.tpe, true)
    } else if tpe.kind == TypeKind::FUNCTION or tpe.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter
            if is_polymorph(np.tpe) {
                return true
            }
        }
    }
    return false
}

export def has_destructor(tpe: *Type) -> bool {
    if not tpe { return false }
    if tpe.has_destructor != 0 {
        return tpe.has_destructor == 1
    }
    if is_ref(tpe) {
        let generic = get_generic(tpe)
        if not generic { return true }
        return not generic.tc_incomplete
    }
    if tpe.kind == TypeKind::STATIC_ARRAY { return has_destructor(tpe.tpe) }
    if tpe.module {
        let args = vector::make()
        let first_arg = allocate(NamedParameter)
        @first_arg = {
            name = "",
            tpe = pointer(tpe)
        } !NamedParameter
        vector::push(args, first_arg)
        let destructor = scope::get_function(tpe.module.scope, parser::make_identifier(["destruct"]), args)
        if destructor { 
            tpe.has_destructor = 1
            return true 
        }
    }
    if tpe.kind == TypeKind::STRUCT {
        for var i in 0..tpe.fields.size {
            let field = tpe.fields[i]
            if has_destructor(field.tpe) {
                tpe.has_destructor = 1
                return true
            }
        }
    }
    tpe.has_destructor = -1
    return false
}

export def has_user_defined_copy_constructor(tpe: *Type) -> bool {
    if not tpe { return false }
    if tpe.has_copy_constructor != 0 {
        return tpe.has_copy_constructor == 1
    }
    if tpe.kind == TypeKind::STATIC_ARRAY { return has_user_defined_copy_constructor(tpe.tpe) }
    if tpe.module {
        let args = vector::make()
        let arg = allocate(NamedParameter)
        @arg = {
            name = "",
            tpe = pointer(tpe)
        } !NamedParameter
        vector::push(args, arg)
        vector::push(args, arg)
        let constructor = scope::get_function(tpe.module.scope, parser::make_identifier(["construct"]), args)
        if constructor {
            tpe.has_copy_constructor = 1
            return true 
        }
    }
    tpe.has_copy_constructor = -1
    return false
}

// TODO also cache this maybe?
export def has_copy_constructor(tpe: *Type) -> bool {
    if not tpe { return false }
    if has_user_defined_copy_constructor(tpe) { return true }
    if tpe.kind == TypeKind::STRUCT {
        for var i in 0..tpe.fields.size {
            let field = tpe.fields[i]
            if has_copy_constructor(field.tpe) { return true }
            else if is_ref(field.tpe) { return true }
        }
    } else if tpe.kind == TypeKind::STATIC_ARRAY {
        while tpe != null and tpe.kind == TypeKind::STATIC_ARRAY {
            tpe = tpe.tpe
        }
        if is_ref(tpe) { return true }
    }
    return false
}

def find_type_defs(module: *toolchain::Module, left: *Type, right: *Type, types: *map::Map, replace: bool = true, is_type: bool = false) {
    if not left or not right { return }

    if left.kind == TypeKind::TYPE_DEF and right.kind != TypeKind::TYPE_DEF {
        find_type_defs(module, left.tpe, right, types, replace, true)
        if replace {
            if left.tpe.kind == TypeKind::ARRAY and right.kind == TypeKind::STATIC_ARRAY {
                // Turn static array into a dynamic array
                @left = @right
                left.kind = TypeKind::ARRAY
            } else if left.tpe.kind == TypeKind::STUB or 
                left.tpe.kind == TypeKind::STRUCT or 
                left.tpe.kind == right.kind {
                
                @left = @right
            }
        }
    } else if is_box(left) {
        find_type_defs(module, left.tpe, right.tpe, types, replace, is_type)
    } else if left.kind == TypeKind::FUNCTION or left.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(left.parameter_t) {
            let l = vector::get(left.parameter_t, i) !*NamedParameter
            let r = vector::get(right.parameter_t, i) !*NamedParameter
            find_type_defs(module, l.tpe, r.tpe, types, replace, is_type)
        }
    } else if left.kind == TypeKind::GENERIC {
        if right.tc_args {
            for var i in 0..vector::length(left.tc_args) {
                let l = vector::get(left.tc_args, i) !*Type
                var r = vector::get(right.tc_args, i) !*Type
                var is_type = false
                if r and r.kind == TypeKind::TYPE_DEF {
                    is_type = true
                    r = r.tpe
                }
                find_type_defs(module, l, r, types, replace, is_type)
            }
            if replace {
                @left = @right
            }
        } else {
            right = infer_interface_types(left, right, module)
            if right {
                for var i in 0..vector::length(left.tc_args) {
                    let l = vector::get(left.tc_args, i) !*Type
                    var r = vector::get(right.tc_args, i) !*Type
                    var is_type = false
                    if r and r.kind == TypeKind::TYPE_DEF {
                        is_type = true
                        r = r.tpe
                    }
                    find_type_defs(module, l, r, types, replace, is_type)
                }
                if replace {
                    @left = @right
                }
            }
        }
    }
    if is_type {
        map::put(types, left.name, right)
    }
}

def replace_parameter(tpe: *Type, types: *map::Map) -> *Type {
    if not tpe { return null }
    if tpe.tc_args {
        for var i in 0..vector::length(tpe.tc_args) {
            let arg = vector::get(tpe.tc_args, i) !*Type
            vector::set(tpe.tc_args, i, replace_parameter(arg, types))
        }
    } else if is_box(tpe) {
        if tpe.tpe {
            tpe.tpe = replace_parameter(tpe.tpe, types)
        }
    } else if tpe.kind == TypeKind::FUNCTION or tpe.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter
            np.tpe = replace_parameter(np.tpe, types)
        }
    } else if tpe.kind != TypeKind::TYPE_DEF and length(tpe.name) > 0 {
        let ntpe = map::get(types, tpe.name) !*Type
        if ntpe { return ntpe }
    }
    return tpe
}

// NOTE: This function mutates param_a and return_t, watch out!
export def replace_type_defs(param_a: *vector::Vector, return_t: *vector::Vector, param_b: *vector::Vector, types_map: *map::Map, module: *toolchain::Module, replace: bool = true) {
    if not types_map {
        types_map = map::make()
    }

    for var i in 0..vector::length(param_a) {
        let left = vector::get(param_a, i) !*NamedParameter
        
        let ltpe = left.tpe
        if not ltpe { continue }

        var right: *NamedParameter = null
        for var j in 0..vector::length(param_b) {
            let r = vector::get(param_b, j) !*NamedParameter
            if length(r.name) > 0 and r.name == left.name {
                right = r
                break
            }
        }
        if not right and i < vector::length(param_b) {
            right = vector::get(param_b, i) !*NamedParameter
        }

        var rtpe: *Type = null
        if right {
            rtpe = right.tpe
        }
        if not right and left.value {
            rtpe = left.value.tpe
        }
        
        if not rtpe { return }
        if convert_type_score(ltpe, rtpe, module) < 0 { return }

        let intf = get_interface(ltpe)
        if intf and replace {
            @ltpe = @rtpe
            continue
        }

        if ltpe.kind == TypeKind::TYPE {
            if length(ltpe.name) > 0 and right and right.value {
                map::put(types_map, ltpe.name, right.value.value_tpe)
                ltpe.tpe = right.value.value_tpe
            }
        } else {
            find_type_defs(module, ltpe, rtpe, types_map, replace)
        }

        for var j in (i + 1)..vector::length(param_a) {
            let np = vector::get(param_a, j) !*NamedParameter
            if np.tpe {
                np.tpe = replace_parameter(np.tpe, types_map)
            }
        }
        for var j in 0..vector::length(return_t) {
            let rtpe = vector::get(return_t, j) !*Type
            vector::set(return_t, j, replace_parameter(rtpe, types_map))
        }
    }
}

export def overload_score(a: *Type, param_b: *vector::Vector, module: *toolchain::Module, positional: bool) -> int {
    return overload_score(a.parameter_t, a.return_t, param_b, module, positional)
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.

export def overload_score(param_a: *vector::Vector, return_t: *vector::Vector, param_b: *vector::Vector, module: *toolchain::Module, positional: bool) -> int {
    param_a = copy_parameter_t(param_a)
    return_t = copy_return_t(return_t)
    
    if vector::length(param_a) > vector::length(param_b) {
        let not_default_param = (vector::get(param_a, vector::length(param_b)) !*NamedParameter).value == null
        if vector::length(param_a) == vector::length(param_b) + 1 {
            if not (@(vector::peek(param_a) !*NamedParameter)).varargs and not_default_param {
                return -1
            }
        } else if not_default_param {
            return -1
        }
    }

    replace_type_defs(param_a, return_t, param_b, null, module, false)

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = vector::get(param_b, i) !*NamedParameter
        var left: *NamedParameter = null
        if length((@right).name) > 0 and not positional {
            for var i in 0..vector::length(param_a) {
                let param = vector::get(param_a, i) !*NamedParameter
                if (@right).name == (@param).name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            if i < vector::length(param_a) {
                left = vector::get(param_a, i) !*NamedParameter
            } else if vector::length(param_a) > 0 {
                left = vector::peek(param_a) !*NamedParameter
                if not (@left).varargs {
                    return -1
                } 
            } else {
                return -1
            }
        }
        var lvalue = left.tpe
        if i == vector::length(param_a) - 1 and 
            left.varargs and left.tpe and
            convert_type_score(array(left.tpe), right.tpe, module) >= 0 {

            lvalue = array(left.tpe)
        }
        var score = -1
        if lvalue and lvalue.kind == TypeKind::TYPE {
            if equals(right.tpe, pointer(builtins::Type_)) {
                if left.value {
                    if equals(left.value.value_tpe, right.tpe.tpe.tpe) {
                        score = 0
                    }
                } else {
                    score = 1
                }
            } else if is_type(right.tpe) and left.value and right.value and equals(left.value.value_tpe, right.value.value_tpe) {
                score = 0
            }
        } else {
            score = convert_type_score(lvalue, right.tpe, module)
        }
        if score < 0 { return -1 }
        sum += score
    }
    return sum
}

export def mangle_function_name(name: string, parameter_t: *vector::Vector) -> string {
    var buf = buffer::make_buffer()
    buffer::append_str(*buf, name)
    buffer::append_str(*buf, "::(")

    let len = vector::length(parameter_t)
    for var i in 0..len {
        let np = vector::get(parameter_t, i) !*NamedParameter
        if np.varargs and not np.tpe {
            buffer::append_str(*buf, "...")
            break
        }
        if np.varargs {
            buffer::append_char(*buf, '[')
        }
        if np.tpe and np.tpe.kind == TypeKind::TYPE {
            // TODO This should be handled by type_to_str
            buffer::append_str(*buf, "type")
            if np.value {
                buffer::append_char(*buf, '<')
                buffer::append_str(*buf, debug::type_to_str(np.value.value_tpe, true))
                buffer::append_char(*buf, '>')
            }
        } else {
            buffer::append_str(*buf, debug::type_to_str(np.tpe, true))
        }
        if np.varargs {
            buffer::append_char(*buf, ']')
        }
        if i < len - 1 {
            buffer::append_str(*buf, ", ")
        }
    }
    buffer::append_char(*buf, ')')

    return buffer::to_string(*buf)
}

// TODO Move this into parser
export def last_ident_to_str(node: *parser::Node) -> string {
    if not node { return "" }
    assert(node.kind == parser::NodeKind::IDENTIFIER)
    if vector::length(node.value.identifier.path) > 1 {
        errors::errorn(node, "Expected plain identifier without path")
    }
    return @(vector::get(node.value.identifier.path, 0) !*string)
}

def flatten_return_type(node: *parser::Node, return_t: *vector::Vector) -> *Type {
    let len = vector::length(return_t) 
    if len > 1 {
        // TODO size and alignment! Same as a struct,
        // also refactor type_lookup and compiler (functions with multiple return types)
        // into a single function for calculating the size and alignmenet of a struct
        let return_tpe = make_type_raw(TypeKind::TUPLE)
        (@return_tpe).line = node.loc.line
        (@return_tpe).return_t = return_t
        return return_tpe
    } else if len == 1 {
        return vector::peek(return_t) !*Type
    }

    return make_type_raw(TypeKind::VOID)
}

def check_is_identifier_assignable(node: *parser::Node, state: *State) -> bool {
    if node.kw != parser::VarDecl::VAR {
        errors::errorn(node, "Assignment to non var")
        return false
    }
    return true
}


export def make_struct_type(fields: [StructMember], current_type: *Type = null) -> *Type {
    let struct_tpe = make_type_raw(TypeKind::STRUCT) if not current_type else current_type
    let field_types = vector::make()

    var j = 0
    var bit_offset = 0
    var offset = 0 !size_t
    var align = 1 !size_t
    var bit_type: *Type = null

    for var i in 0..fields.size {
        let field = *fields[i]
        let tpe = field.tpe
        if not tpe { continue }
        field.index = j
        
        // TODO This is the msvc way of doing bit fields, on Linux the ABI might differ
        if field.is_bitfield {
            field.bit_offset = bit_offset
            if i < fields.size - 1 {
                if not bit_type {
                    bit_type = tpe
                } 
                if field.bit_size > 0 and
                    bit_type.size == tpe.size and 
                    bit_offset + field.bit_size < bit_type.size * 8 {
                    
                    bit_offset += field.bit_size
                    continue
                }
            }
        }

        if field.tpe.kind == TypeKind::TYPE_CONSTRUCTOR {
            errors::errorn(field.node, "Can't use type constructor as field type")
            continue
        }
        if tpe.align > 0 {
            offset = (ceil(offset / tpe.align !double) * tpe.align) !int
            align = util::lcm(align !int, tpe.align !int)
        }

        let type_member = allocate(TypeMember)
        @type_member = {
            tpe = tpe,
            offset = offset
        } !TypeMember

        offset += tpe.size
        vector::push(field_types, type_member)
        
        j += 1
        bit_offset = 0
        bit_type = null
    }

    offset = (ceil(offset / align !double) * align) !int

    struct_tpe.size = offset
    struct_tpe.align = align
    struct_tpe.fields = fields
    struct_tpe.field_types = field_types

    return struct_tpe
}

def lookup_type_constructor(tc: *parser::Node, node: *parser::Node, state: *State) -> *Type {
    if not node { return null }
    let name = tc.value.type_constructor.name
    let tpe = make_type(TypeKind::TYPE_CONSTRUCTOR, name)
    tpe.parameter_t = vector::make()

    let args = tc.value.type_constructor.args
    for var i in 0..vector::length(args) {
        let arg = vector::get(args, i) !*parser::Node
        assert arg.kind == parser::NodeKind::PARAMETER

        let np = allocate(NamedParameter)
        @np = { name = parser::identifier_to_str(arg.value.param.name), tpe = builtins::type_ } !NamedParameter
        vector::push(tpe.parameter_t, np)
    }
    tpe.node = node
    tpe.node.module = state.module
    tpe.module = state.module
    tpe.cache = map::make()
    return tpe
}

// This generates concrete functons when refering to type constructors
export def generate_concrete_functions(type_constructor: *Type, tpe: *Type, state: *State) {
    let functions = get_member_functions(tpe)
    for var j in 0..vector::length(functions) {
        let function = vector::get(functions, j) !*TypeEntryMember
        let ftpe = copy(function.function)

        let pars = vector::make()
        let np = allocate(NamedParameter)
        @np = { name = "", tpe = tpe } !NamedParameter
        vector::push(pars, np)
        
        replace_type_defs(ftpe.parameter_t, ftpe.return_t, pars, null, state.module)
        ftpe.type_name = mangle_function_name(append_module(ftpe.name, ftpe.module.module), ftpe.parameter_t)
        let new_entry = create_type_entry(tpe, function.exported, ftpe, function.module)
        if not is_polymorph(tpe) and not is_polymorph(ftpe) and new_entry {
            let scpe = state.scope
            let module = state.module
            state.scope = ftpe.node.module.scope
            state.module = ftpe.node.module
            if not scope::has_function(state.scope, ftpe) {
                walk_Def_with_type_argument(ftpe.node, pars, state)
            }
            state.scope = scpe
            state.module = module
        }
    }
}

export def type_lookup(node: *parser::Node, state: *State, current_type: *Type = null, lookup_default: bool = false, cache: *map::Map = null) -> *Type {
    var tpe = do_type_lookup(node, state, current_type, lookup_default, cache)
    if tpe == current_type { return current_type }
    
    let type_constructor = get_type_constructor(tpe)
    if tpe and type_constructor and type_constructor.kind != TypeKind::STUB {
        let type_name = debug::type_to_str(tpe, full_name = true)

        if not map::contains(type_constructor.cache, type_name) {
            generate_concrete_functions(type_constructor, tpe, state)
            map::put(type_constructor.cache, type_name, tpe)

            let tpe2 = get_generic(tpe)
            if tpe.kind != TypeKind::GENERIC and tpe2 and not tpe2.tc_incomplete {
                // We need to generate the destructor and copy constructor here
                // TODO This is probably not needed anymore, see compiler::create_destructor
                let args = vector::make()
                let np = allocate(NamedParameter)
                @np = { name = "", tpe = pointer(tpe) }
                vector::push(args, np)
                
                scope::get_function(type_constructor.node.module.scope, parser::make_identifier(["destruct"]), args)

                let args2 = vector::make()
                let np2 = allocate(NamedParameter)
                @np2 = { name = "", tpe = pointer(tpe) }
                vector::push(args2, np2)
                vector::push(args2, np2)

                scope::get_function(type_constructor.node.module.scope, parser::make_identifier(["construct"]), args2)
            }
        }
    }
    if tpe and (tpe.kind == TypeKind::STRUCT or tpe.kind == TypeKind::UNION) {
        if check_is_recursive(tpe) {
            if not tpe.node.is_recursive_type { 
                errors::errorn(tpe.node, "Recursive type declaration!")
            }
            tpe.node.is_recursive_type = true
            tpe = make_type_raw(TypeKind::STUB)
        }
    }

    node.tpe = tpe
    return tpe
}

// TODO current_type is basically a hack, there's really no reason why you should already have a type and then look it up again
export def do_type_lookup(node: *parser::Node, state: *State, current_type: *Type = null, lookup_default: bool = false, cache: *map::Map = null) -> *Type {
    if not node { return null }
    if node.kind == parser::NodeKind::IDENTIFIER {
        let name = parser::identifier_to_str(node)
        if current_type and not lookup_default and current_type.kind != TypeKind::STUB {
            return current_type
        }
        if not lookup_default {
            return scope::get_type(state.scope, node)
        } else {
            let value = scope::get(state.scope, node, false, false)
            var tpe: *Type = null
            if value {
                if value.modifier != parser::VarDecl::TYPE {
                    errors::errorn(node, "`", parser::identifier_to_str(node), "` is not a type")
                    return null
                }
                tpe = value.value.value_tpe
            } else {
                tpe = make_type_raw(TypeKind::STUB)
                tpe.name = @(vector::get(node.value.identifier.path, vector::length(node.value.identifier.path) - 1) !*string)
                tpe.type_name = name
                if vector::length(node.value.identifier.path) == 1 {
                    tpe.type_name = append_module(tpe.type_name, state.module.module)
                }
                tpe = scope::create_type(state.scope, node, parser::ShareMarker::NONE, tpe, scope::Phase::DECLARED, null, null)
                tpe.module = state.module
            }
            return tpe
        }
    } else if node.kind == parser::NodeKind::PTR_T {
        if current_type { current_type = current_type.tpe }
        var tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        tpe = pointer(tpe, node.value.t_parr.kw)
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::REF_T {
        if current_type { current_type = current_type.tpe }
        var tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        tpe = reference(tpe, node.value.t_parr.kw)
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::WEAK_REF_T {
        if current_type { current_type = current_type.tpe }
        var tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        tpe = weak_reference(tpe, node.value.t_parr.kw)
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::STRUCT_T {
        
        let length = vector::length(node.value.body)
        let fields = allocate(StructMember, length)
        for var i in 0..length {
            let field = vector::get(node.value.body, i) !*parser::Node
            if not field { continue }
            let line = (@field).loc.line

            var field_tpe: *Type = null
            var name = ""
            var is_bitfield = false
            var bit_size = 0 !size_t

            var field_type: *Type = null
            if current_type and current_type.kind != TypeKind::STUB { field_type = current_type.fields[i].tpe }

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                let ident = (@field).value.id_decl_struct.ident
                name = last_ident_to_str(ident)
                field_tpe = type_lookup((@field).value.id_decl_struct.tpe, state, field_type, lookup_default, cache)
                if field.value.id_decl_struct.is_bitfield {
                    is_bitfield = true
                    bit_size = field.value.id_decl_struct.bit_size
                }
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                field_tpe = type_lookup(field, state, field_type, lookup_default, cache)
            }
            
            fields[i] = { 
                node = field,
                line = line, 
                name = name, 
                tpe = field_tpe,
                is_bitfield = is_bitfield, 
                bit_size = bit_size
            } !StructMember
        }
        
        let tpe = make_struct_type(fields, current_type)
        tpe.type_name = make_unique_name("<anonymous>", state)
        tpe.name = "<anonymous>"
        tpe.line = node.loc.line
        tpe.module = state.module
        tpe.node = node

        return tpe
    } else if node.kind == parser::NodeKind::UNION_T {
        let tpe = make_type_raw(TypeKind::UNION) if not current_type else current_type
        (@tpe).type_name = make_unique_name("<anonymous>", state)
        (@tpe).name = "<anonymous>"

        let length = vector::length(node.value.body)
        let fields = allocate(StructMember, length)
        let field_types = vector::make()

        var size = 0 !size_t
        var align = 1 !size_t
        var biggest_type: *Type = null
        for var i in 0..length {
            let field = vector::get(node.value.body, i) !*parser::Node
            let line = (@field).loc.line
            
            var field_tpe: *Type = null
            var name = ""
            var is_bitfield = false
            var bit_size = 0 !size_t

            var field_type: *Type = null
            if current_type { field_type = current_type.fields[i].tpe }

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                let ident = (@field).value.id_decl_struct.ident
                name = last_ident_to_str(ident)
                field_tpe = type_lookup((@field).value.id_decl_struct.tpe, state, field_type, lookup_default, cache)
                if field.value.id_decl_struct.is_bitfield {
                    is_bitfield = true
                    bit_size = field.value.id_decl_struct.bit_size
                }
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                field_tpe = type_lookup(field, state, field_type, lookup_default, cache)
            }

            fields[i] = {
                line = line,
                node = field, 
                name = name, 
                tpe = field_tpe,
                is_bitfield = is_bitfield, 
                bit_size = bit_size
            } !StructMember

            if field_tpe and field_tpe.size > size {
                size = field_tpe.size
                biggest_type = field_tpe
            }
            if field_tpe and field_tpe.kind == TypeKind::TYPE_CONSTRUCTOR {
                errors::errorn(field, "Can't use type constructor as field type")
            }
            // TODO Alignment of bit fields on Windows is strange
            align = max(field_tpe.align, align) !size_t
        }

        let type_member = allocate(TypeMember)
        @type_member = { biggest_type, 0 } !TypeMember
        vector::push(field_types, type_member)

        tpe.line = node.loc.line
        tpe.size = size
        tpe.align = align
        tpe.fields = fields
        tpe.field_types = field_types
        tpe.module = state.module
        tpe.node = node

        return tpe
    } else if node.kind == parser::NodeKind::ENUM_T {
        if current_type { current_type = current_type.tpe }
        var enum_tpe = builtins::int_
        if node.value.t_enum.tpe {
            enum_tpe = type_lookup(node.value.t_enum.tpe, state, current_type, lookup_default, cache)
        }
        let tpe = make_type_raw(TypeKind::ENUM)
        (@tpe).line = node.loc.line
        (@tpe).tpe = enum_tpe
        (@tpe).size = (@enum_tpe).size
        (@tpe).align = (@enum_tpe).align
        tpe.module = state.module

        return tpe
    } else if node.kind == parser::NodeKind::ARRAY_T {
        if current_type { current_type = current_type.tpe }
        let array_tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        let tpe = array(array_tpe, node.value.t_parr.kw)
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::ARRAY_STATIC_T {
        if current_type { current_type = current_type.tpe }
        let array_tpe = type_lookup(node.value.t_arrs.tpe, state, current_type, lookup_default, cache)

        var n = util::MAX_UINT64 !int64
        if node.value.t_arrs.n {
            n = 0
            let value = consteval::expr(node.value.t_arrs.n, state)
            if value.tpe.kind != TypeKind::WORD {
                errors::errorn(node.value.t_arrs.n, "Type needs to be a positive integer, got ", debug::type_to_str(value.tpe))
            } else if not value.tpe.unsig and value.i < 0 {
                errors::errorn(node.value.t_arrs.n, "Negative array size not allowed")
            } else {
                n = value.i
            }
        }

        let tpe = make_static_array(array_tpe, n, node.value.t_arrs.kw)
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::FUNCTION_T {
        var tpe = make_function_type()
        (@tpe).line = node.loc.line
        (@tpe).parameter_t = vector::make()
        for var i in 0..vector::length(node.value.t_func.args) {
            var arg_type: *Type = null
            if current_type { 
                arg_type = (vector::get(current_type.parameter_t, i) !*NamedParameter).tpe 
            }

            let arg = vector::get(node.value.t_func.args, i) !*parser::Node
            let np = allocate(NamedParameter)
            (@np).varargs = false
            (@np).name = ""
            (@np).tpe = type_lookup(arg, state, arg_type, lookup_default, cache)
            (@np).node = arg
            vector::push((@tpe).parameter_t, np)
        }
        (@tpe).return_t = vector::make()
        for var i in 0..vector::length(node.value.t_func.ret) {
            var return_type: *Type = null
            if current_type { 
                return_type = vector::get(return_type.return_t, i) !*Type
            }

            let arg = vector::get(node.value.t_func.ret, i) !*parser::Node
            vector::push((@tpe).return_t, type_lookup(arg, state, return_type, lookup_default, cache))
        }
        tpe.module = state.module
        tpe = pointer(tpe)
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::TYPE_T {
        if current_type { return current_type }
        let wrapped = type_lookup(node.value.expr, state, current_type, lookup_default, cache)
        let tpe = make_type_raw(TypeKind::TYPE_DEF)
        if node.value.expr.kind == parser::NodeKind::IDENTIFIER {
            tpe.name = parser::identifier_to_str(node.value.expr)
        }
        tpe.line = node.loc.line
        tpe.tpe = wrapped
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::UNSIGNED_T {
        let signed = copy(type_lookup(node.value.expr, state, current_type, lookup_default, cache)) if not current_type else current_type
        if not is_arithmetic(signed) or signed.unsig {
            errors::errorn(node, "Expected arithmetic type, got ", debug::type_to_str(signed))
            return null
        }
        signed.unsig = true
        signed.module = state.module
        return signed
    } else if node.kind == parser::NodeKind::WORD_T {
        let n = node.value.i / 8
        let tpe = make_type_raw(TypeKind::WORD)
        tpe.size = n
        tpe.align = n
        tpe.module = state.module
        return tpe
    } else if node.kind == parser::NodeKind::TYPE_OF_T {
        if current_type { return current_type }
        walk(node, node.value.expr, state)
        return node.value.expr.tpe
    } else if node.kind == parser::NodeKind::STRUCTURAL_T {
        let tpe = make_type_raw(TypeKind::STRUCTURAL) if not current_type else current_type
        tpe.kind = TypeKind::STRUCTURAL
        tpe.type_name = make_unique_name("<anonymous>", state)
        tpe.name = "<anonymous>"

        let members = vector::make()

        for var i in 0..vector::length(node.value.body) {
            let member = vector::get(node.value.body, i) !*parser::Node
            var current_member: *StructuralTypeMember = null
            if current_type { current_member = vector::get(current_type.members, i) !*StructuralTypeMember}

            let name = parser::identifier_to_str(member.value.structural_member.name)
            let parameter_t = vector::make()
            let return_t = vector::make()

            for var i in 0..vector::length(member.value.structural_member.params) {
                let parameter_node = vector::get(member.value.structural_member.params, i) !*parser::Node
                let parameter = allocate(NamedParameter)
                let current_parameter_type = (vector::get(current_member.parameter_t, i) !*NamedParameter).tpe if current_member else null !*Type
                @parameter = {
                    name = parser::identifier_to_str(parameter_node.value.param.name),
                    tpe = type_lookup(parameter_node.value.param.tpe, state, current_parameter_type, false, cache)
                } !NamedParameter
                vector::push(parameter_t, parameter)
            }

            for var i in 0..vector::length(member.value.structural_member.returns) {
                let return_node = vector::get(member.value.structural_member.returns, i) !*parser::Node
                let current_return_type = vector::get(current_member.return_t, i) !*Type if current_member else null !*Type
                vector::push(return_t, type_lookup(return_node, state, current_return_type, false, cache))
            }

            let structural_type_member = allocate(StructuralTypeMember)
            @structural_type_member = {
                name,
                parameter_t,
                return_t
            }
            vector::push(members, structural_type_member)
        }
        tpe.members = members
        tpe.module = state.module

        return tpe
    } else if node.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
        if current_type and current_type.kind != TypeKind::STUB and not current_type.tc_incomplete and 
            (not current_type.tc_tpe or current_type.tc_tpe.kind != TypeKind::STUB) { 
            return current_type 
        }

        var tpe = current_type
        let name = node.value.type_constructor.name

        var type_constructor = type_lookup(name, state, null, lookup_default, cache)
        if not type_constructor { return current_type }

        if type_constructor.kind != TypeKind::STUB {
            if type_constructor.kind != TypeKind::TYPE_CONSTRUCTOR {
                errors::errorn(node, "Not a type constructor")
                return null
            }
            if vector::length(type_constructor.parameter_t) != vector::length(node.value.type_constructor.args) {
                errors::errorn(node, "Wrong amount of arguments to type constructor, expected ",
                    util::int_to_str(vector::length(type_constructor.parameter_t)),
                    " got ",
                    util::int_to_str(vector::length(node.value.type_constructor.args)))
                return null
            }
        }

        let name_buf = *buffer::make_buffer()
        name_buf.append_str(type_constructor.type_name)
        name_buf.append_char('(')
       
        var tc_args = vector::make()
        var is_incomplete = type_constructor.kind == TypeKind::STUB
        var is_generic = false

        let len = vector::length(node.value.type_constructor.args)
        let scpe = state.scope
        var inner_scope: *scope::Scope = null
        if type_constructor.module { 
            inner_scope = scope::enter_scope(type_constructor.module.scope)
        } else {
            inner_scope = scope::enter_scope(state.scope)
        }
        for var i in 0..len {
            let arg = vector::get(node.value.type_constructor.args, i) !*parser::Node
            var np: *NamedParameter = null
            if type_constructor.kind != TypeKind::STUB {
                np = vector::get(type_constructor.parameter_t, i) !*NamedParameter
            }

            let argtpe = type_lookup(arg, state, null, lookup_default, cache)
            if argtpe {
                if argtpe.kind == TypeKind::TYPE_DEF { is_generic = true }
                else if argtpe.kind == TypeKind::STUB { is_incomplete = true }
                if np {
                    scope::create_type(inner_scope, parser::make_identifier([np.name]), parser::ShareMarker::NONE, argtpe)
                }
            } else { is_incomplete = true }
            vector::push(tc_args, argtpe)
            name_buf.append_str(debug::type_to_str(argtpe, full_name = true))
            if i < len -1 {
                name_buf.append_str(", ")
            }
        }
        name_buf.append_char(')')
        state.scope = inner_scope

        if is_generic {
            if type_constructor.node and type_constructor.node.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
                tpe = type_lookup(type_constructor.node, state, null, lookup_default, cache)
            } else {
                tpe = make_type_raw(TypeKind::GENERIC)
                tpe.tpe = type_constructor
                tpe.tc_args = tc_args
                tpe.tc_incomplete = true
                tpe.module = state.module
            }

            state.scope = scpe
            return tpe
        }
        var type_name = name_buf.to_string()
        if not cache { cache = map::make() }
        var cached_type = map::get(cache, type_name) !*Type
        if cached_type != null {
            state.scope = scpe
            return cached_type
        }
        cached_type = make_type_raw(TypeKind::STUB)
        map::put(cache, type_name, cached_type)

        if type_constructor.node {
            tpe = type_lookup(type_constructor.node, state, null, lookup_default, cache)
            if type_constructor.node.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
                type_name = tpe.type_name
                tc_args = tpe.tc_args
                type_constructor = tpe.tc_tpe
                is_incomplete = tpe.tc_incomplete
            }
        } else {
            tpe = make_type_raw(TypeKind::STUB)
        }
        
        tpe.tc_tpe = type_constructor
        tpe.tc_args = tc_args
        tpe.tc_incomplete = is_incomplete
        tpe.module = state.module 
        // TODO use type_to_string by default
        tpe.type_name = type_name
        tpe.name = debug::type_to_str(tpe)

        state.scope = scpe
        @cached_type = @tpe
        return cached_type
    }

    return null
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
export def common_type(a: *Type, b: *Type) -> *Type {
    if not a or not b { return null }

    //TODO Should cause an error
    //assert(is_arithmetic(a) and is_arithmetic(b))

    if (@a).kind == TypeKind::FLOAT and ((@b).kind == TypeKind::WORD or b.kind == TypeKind::CHAR) {
        return a
    } else if ((@a).kind == TypeKind::WORD or a.kind == TypeKind::CHAR) and (@b).kind == TypeKind::FLOAT {
        return b
    } else if a.kind == TypeKind::BOOL and is_arithmetic(b) {
        return a
    } else if b.kind == TypeKind::BOOL and is_arithmetic(a) {
        return b
    }

    if is_arithmetic(a) and is_arithmetic(b) {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
    return null
}

def walk_ArrayStaticT(node: *parser::Node, state: *State) {
    let n = node.value.t_arrs.n
    let expr = node.value.t_arrs.tpe
    if not n {
        errors::errorn(n, "Type needs to be sized")
        return
    }

    var size = 0 !int64
    let value = consteval::expr(n, state)
    if value.tpe.kind != TypeKind::WORD {
        errors::errorn(n, "Type needs to be a positive integer, got ", debug::type_to_str(value.tpe))
    } else if not value.tpe.unsig and value.i < 0 {
        errors::errorn(n, "Negative array size not allowed")
    } else {
        size = value.i
    }

    let tpe = expr.svalue.value.value_tpe
    let tpe2 = copy(builtins::Type_)
    tpe2.tpe = type_lookup(node, state)
    node.tpe = tpe2
}

def walk_TypeOfT(node: *parser::Node, state: *State) {
    let expr = node.value.expr
    walk(node, expr, state)
    let tpe = copy(builtins::Type_)
    tpe.tpe = expr.tpe
    node.tpe = pointer(tpe)
}

def walk_Null(node: *parser::Node, state: *State) {
    let tpe = make_type_raw(TypeKind::NULL)
    node.tpe = tpe
}

def walk_Undef(node: *parser::Node, state: *State) {
    let tpe = make_type_raw(TypeKind::UNDEF)
    node.tpe = tpe
}

def walk_Integer(node: *parser::Node, state: *State) {
    node.tpe = builtins::int_
}

def walk_Boolean(node: *parser::Node, state: *State) {
    node.tpe = builtins::bool_
}

def walk_Float(node: *parser::Node, state: *State) {
    node.tpe = builtins::double_
}

def walk_String(node: *parser::Node, state: *State) {
    node.tpe = builtins::string_
}

def walk_Char(node: *parser::Node, state: *State) {
    node.tpe = builtins::char_
}

def walk_Range(node: *parser::Node, state: *State) {
    walk(node, node.value.bin_op.left, state)
    walk(node, node.value.bin_op.right, state)

    var kind = TypeKind::RANGE
    if node.kind == parser::NodeKind::RANGE_INC {
        kind = TypeKind::RANGE_INC
    }
    let tpe = make_type_raw(kind)
    (@tpe).line = node.loc.line
    
    node.tpe = tpe
}

export def lookup_identifier_types(node: *parser::Node, state: *State) {
    if node.value.identifier.args {
        node.value.identifier.types = vector::make()
        for var i in 0..vector::length(node.value.identifier.args) {
            let arg = vector::get(node.value.identifier.args, i) !*parser::Node
            let tpe = type_lookup(arg, state, null, true)

            let np = allocate(NamedParameter)
            @np = {
                name = "",
                tpe = tpe
            } !NamedParameter
            vector::push(node.value.identifier.types, np)
        }
    }
}

def walk_Identifier(node: *parser::Node, state: *State) {
    lookup_identifier_types(node, state)

    var value = scope::get(state.scope, node) !*scope::Value
    if not value {
        errors::errorn(node, "Unknown identifier `", parser::identifier_to_str(node), "`")
        return
    }

    if value.tpe and value.tpe.kind == TypeKind::TYPE {
        let tpe = copy(builtins::Type_)
        tpe.tpe = value.value.value_tpe
        node.tpe = pointer(tpe)
    } else {
        node.tpe = value.tpe
    }
    
    node.svalue = value
    node.kw = value.modifier
    
    if is_function(node.tpe) and 
        (@node.parent).kind != parser::NodeKind::FUNC_CALL and
        (@node.parent).kind != parser::NodeKind::PTR {

        let parent = node.parent
        let old_node = parser::copy_node(node)
        (@old_node).tpe = flatten_return_type(old_node, (@node.tpe).return_t)

        @node = {
            kind = parser::NodeKind::FUNC_CALL,
            loc = node.loc
        } !parser::Node
        node.value.func_call = {
            left = old_node,
            args = vector::make(),
            kwargs = vector::make()
        } !parser::NodeFuncCall
        walk(parent, node, state)
    }
}

def implicit_conversion(node: *parser::Node, tpe: *Type, state: *State) {
    if not tpe { return }
    // TODO For integers we need to check the boundaries
    // TODO What about stuff like --10? I mean its kinda useless but for completeness
    if node.kind == parser::NodeKind::NULL and is_pointer(tpe) or
        is_arithmetic(tpe) and (node.kind == parser::NodeKind::INTEGER or
        (node.kind == parser::NodeKind::USUB or node.kind == parser::NodeKind::UADD) and 
        (@node.value.expr).kind == parser::NodeKind::INTEGER) {

        node.tpe = tpe
    } else if is_function_pointer(tpe) and 
        node.kind == parser::NodeKind::PTR and 
        node.value.expr and node.value.expr.kind == parser::NodeKind::IDENTIFIER {
        node.tpe = tpe
    }
}

def infer_struct_type(node: *parser::Node, tpe: *Type) {
    if node.kind != parser::NodeKind::STRUCT_LIT { return }
    if not (is_struct(tpe) or is_ref(tpe) and is_struct(tpe.tpe)) {
        errors::errorn(node, "Incompatible types ", debug::type_to_str(tpe), " is not a structure type")
        return
    }
    if is_ref(tpe) {
        node.tpe = tpe.tpe
    } else {
        node.tpe = tpe
    }
}

def collapse_types(node: *parser::Node, ltypes: *vector::Vector, right: *vector::Vector, state: *State) -> *vector::Vector {
    let rtypes = vector::make()
    var k = 0
    for var i in 0..vector::length(right) {
        let value = vector::get(right, i) !*parser::Node
        if not value { continue }

        var ltpe: *Type = null
        if k < vector::length(ltypes) {
            ltpe = vector::get(ltypes, k) !*Type
            infer_struct_type(value, ltpe)
        }
        
        walk(node, value, state)
        let rtpe = (@value).tpe
        if rtpe and (@rtpe).kind == TypeKind::TUPLE {
            for var j in 0..vector::length((@rtpe).return_t) {
                let t = vector::get((@rtpe).return_t, j) !*Type
                vector::push(rtypes, t)
                k += 1
            }
        } else {
            implicit_conversion(value, ltpe, state)
            vector::push(rtypes, value.tpe)
            k += 1
        }
    }
    return rtypes
}

def walk_Assign(node: *parser::Node, state: *State) {
    let left = node.value.assign.left
    let right = node.value.assign.right

    let ltypes = vector::make()
    for var i in 0..vector::length(left) {
        let l = vector::get(left, i) !*parser::Node
        if l.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(l) == "_" {
            l.is_initializer = true
        } else {
            walk(node, l, state)
        }
        vector::push(ltypes, (@l).tpe)
    }
    let rtypes = collapse_types(node, ltypes, right, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        errors::errorn(node, "Unbalanced assignment")
        return
    }

    for var i in 0..vector::length(left) {
        let l = vector::get(left, i) !*parser::Node
        var ltpe = (@l).tpe
        if not check_is_identifier_assignable(l, state) {
            continue
        }
        var rtpe = vector::get(rtypes, i) !*Type

        if l.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(l) == "_" {
            ltpe = rtpe
            l.tpe = rtpe
            l.svalue = scope::create_underscore(state.scope, rtpe)
        }

        if not ltpe or not rtpe { continue }
        if not is_assignable(ltpe, rtpe, state.module) {
            errors::errorn(l, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
        }
    }
    node.tpe = vector::peek(ltypes) !*Type
}

// This is getting called from consteval for constants
export def walk_VarDecl(node: *parser::Node, state: *State, set_constant: bool = false) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern
    let parent = node.parent

    if kw == parser::VarDecl::CONST and not set_constant {
        for var i in 0..vector::length(left) {
            let id = vector::get(left, i) !*parser::Node
            assert(id.kind == parser::NodeKind::ID_DECL)
            
            let ident = id.value.id_decl.value
            ident.svalue = scope::get(state.scope, ident)
        }
        return 
    }

    let function = current_function(state)
    if not function.is_global {
        if share != parser::ShareMarker::NONE {
            errors::errorn(node, "Can't share non top level variable")
        }
    }
    
    let ltypes = vector::make()
    for var i in 0..vector::length(left) {
        let node = vector::get(left, i) !*parser::Node
        if node.kind == parser::NodeKind::ID_DECL {
            let tpe_node = node.value.id_decl.tpe
            if tpe_node {
                let tpe = type_lookup(tpe_node, state)
                vector::push(ltypes, tpe)
            } else {
                vector::push(ltypes, null)
            }
        } else {
            let n = node.value.expr
            walk(node, n, state)
            vector::push(ltypes, (@n).tpe)
        }
    }

    let rtypes = collapse_types(node, ltypes, right, state)
    	
    var balanced = true
    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(ltypes) != vector::length(rtypes) {
        
        errors::errorn(node, "Unbalanced assignment")
        balanced = false
    }

    for var i in 0..vector::length(left) {
        var ltpe = vector::get(ltypes, i) !*Type

        let node = vector::get(left, i) !*parser::Node
        if node.kind == parser::NodeKind::ID_DECL {
            if not ltpe and i < vector::length(rtypes) {
                ltpe = vector::get(rtypes, i) !*Type
            }
            if balanced and not ltpe and i >= vector::length(rtypes) {
                errors::errorn(node, "Need to specify a type")
            }

            let ident = node.value.id_decl.value
            let is_underscore = scope::last_path_element(ident) == "_"

            var rtpe: *Type = null
            if i < vector::length(rtypes) {
                rtpe = vector::get(rtypes, i) !*Type
                
                if is_underscore {
                    ltpe = rtpe
                } else if not is_assignable(ltpe, rtpe, state.module) {
                    errors::errorn(node, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
                } else if ltpe and ltpe.kind == TypeKind::STATIC_ARRAY and ltpe.length == util::MAX_UINT64 {
                    ltpe.length = rtpe.length
                    ltpe.size = rtpe.size
                }
                if rtpe and rtpe.kind == TypeKind::TYPE_CONSTRUCTOR {
                    errors::errorn(node, "Can't use type constructor as variable type")
                    ltpe = null
                }
            }

            if not rtpe and ltpe and ltpe.kind == TypeKind::STATIC_ARRAY and ltpe.length == util::MAX_UINT64 {
                errors::errorn(node, "Array size indeterminate")
            }

            ident.scope = state.scope
            ident.tpe = ltpe

            if is_underscore {
                ident.svalue = scope::create_underscore(state.scope, ltpe)
            } else {
                ident.svalue = scope::create_variable(state.scope, ident, share, kw, ltpe, extern, null)
            }

            if parent.kind != parser::NodeKind::PROGRAM {
                map::put(function.locals, ident.svalue.assembly_name, ltpe)
            }
        } else {
            let n = node.value.expr
            if not check_is_identifier_assignable(n, state) {
                continue
            }

            if i >= vector::length(rtypes) {
                errors::errorn(node, "Must assign a value")
                continue
            }
            let rtpe = vector::get(rtypes, i) !*Type

            if node.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(node) == "_" {
                ltpe = rtpe
                node.tpe = rtpe
                node.svalue = scope::create_underscore(state.scope, rtpe)
            }

            if not ltpe or not rtpe { continue }
            if not is_assignable(ltpe, rtpe, state.module) {
                errors::errorn(node, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
            }
        }
    }
}

def walk_Not(node: *parser::Node, state: *State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }
    node.tpe = tpe
}

def walk_BNot(node: *parser::Node, state: *State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }

    let args = vector::make()
    let np = allocate(NamedParameter)
    @np = {
        name = "",
        tpe = tpe
    } !NamedParameter
    vector::push(args, np)
    convert_to_call(node, "__invert__", args, state)

    if node.kind != parser::NodeKind::FUNC_CALL and not is_integer(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be integer type")
    }
    node.tpe = tpe
}

def walk_UAdd(node: *parser::Node, state: *State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }

    let args = vector::make()
    let np = allocate(NamedParameter)
    @np = {
        name = "",
        tpe = tpe
    } !NamedParameter
    vector::push(args, np)
    convert_to_call(node, "__pos__", args, state)

    if node.kind != parser::NodeKind::FUNC_CALL and not is_arithmetic(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be arithmetic type")
    }
    node.tpe = tpe
}

def walk_USub(node: *parser::Node, state: *State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }

    let args = vector::make()
    let np = allocate(NamedParameter)
    @np = {
        name = "",
        tpe = tpe
    } !NamedParameter
    vector::push(args, np)
    convert_to_call(node, "__neg__", args, state)

    if node.kind != parser::NodeKind::FUNC_CALL and not is_arithmetic(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be arithmetic type")
    }
    node.tpe = tpe
}

def make_function_call(node: *parser::Node, ident: *parser::Node) -> *parser::Node {
    let args = vector::make()
    vector::push(args, node.value.bin_op.left)
    vector::push(args, node.value.bin_op.right)

    let function = allocate(parser::Node)
    @function = {
        kind = parser::NodeKind::FUNC_CALL,
        loc = node.loc
    } !parser::Node
    function.value.func_call = {
        left = ident,
        args = args,
        kwargs = vector::make()
    } !parser::NodeFuncCall
    function.parent = node.parent

    return function
}

def convert_to_call(node: *parser::Node, name: string, args: *vector::Vector, state: *State) {
    let ident = parser::make_identifier([name])
    let fun = scope::get_function(state.scope, ident, args, true)
    if fun { 
        let parent = node.parent
        @node = @make_function_call(node, ident) 
        walk(parent, node, state)
    }
}

def convert_to_icall(node: *parser::Node, name: string, args: *vector::Vector, state: *State) {
    let ident = parser::make_identifier([name])
    let fun = scope::get_function(state.scope, ident, args, true)
    if fun { 
        let parent = node.parent
        let assign = allocate(parser::Node)
        @assign = {
            kind = parser::NodeKind::ASSIGN,
            loc = node.loc
        }
        let left = vector::make()
        let right = vector::make()
        assign.value.assign = {
            left = left,
            right = right
        } !parser::NodeAssign

        vector::push(right, make_function_call(node, ident))
        vector::push(left, node.value.bin_op.left)
        @node = @assign
        walk(parent, node, state)
    }
}

def create_args(left: *parser::Node, right: *parser::Node) -> *vector::Vector {
    let args = vector::make()
    let np1 = allocate(NamedParameter)
    @np1 = {
        name = "",
        tpe = left.tpe
    } !NamedParameter
    let np2 = allocate(NamedParameter)
    @np2 = {
        name = "",
        tpe = right.tpe
    } !NamedParameter
    vector::push(args, np1)
    vector::push(args, np2)
    return args
}

def walk_ArithmeticOp(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    node.tpe = common_type((@left).tpe, (@right).tpe)

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::ADD:
            convert_to_call(node, "__add__", args, state)
        case parser::NodeKind::SUB:
            convert_to_call(node, "__sub__", args, state)
        case parser::NodeKind::MUL:
            convert_to_call(node, "__mul__", args, state)
        case parser::NodeKind::DIV:
            convert_to_call(node, "__div__", args, state)
        case parser::NodeKind::MOD:
            convert_to_call(node, "__mod__", args, state)
    }

    if not node.tpe {
        // TODO better error message
        errors::errorn(node, "Invalid operation")
    }
}
    

def walk_BitwiseOp(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    node.tpe = common_type((@left).tpe, (@right).tpe)

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::BAND:
            convert_to_call(node, "__and__", args, state)
        case parser::NodeKind::BOR:
            convert_to_call(node, "__or__", args, state)
        case parser::NodeKind::BXOR:
            convert_to_call(node, "__xor__", args, state)
        case parser::NodeKind::SHR:
            convert_to_call(node, "__rshift__", args, state)
        case parser::NodeKind::SHL:
            convert_to_call(node, "__lshift__", args, state)
    }

    if node.kind != parser::NodeKind::FUNC_CALL {
        if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
            errors::errorn(node, "Invalid operands of type ", debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
        }
    }
}

def walk_BooleanOp(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_boolean((@left).tpe) or not is_boolean((@right).tpe) {
        errors::errorn(node, "Invalid operands of type ", debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    node.tpe = builtins::bool_
}

// TODO implicit conversions here too
def walk_AssignEqArithmetic(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::ADD_EQ:
            convert_to_icall(node, "__iadd__", args, state)
        case parser::NodeKind::SUB_EQ:
            convert_to_icall(node, "__isub__", args, state)
        case parser::NodeKind::MUL_EQ:
            convert_to_icall(node, "__imul__", args, state)
        case parser::NodeKind::DIV_EQ:
            convert_to_icall(node, "__idiv__", args, state)
        case parser::NodeKind::MOD_EQ:
            convert_to_icall(node, "__imod__", args, state)
    } 

    if node.kind != parser::NodeKind::ASSIGN {
        if not is_arithmetic((@right).tpe) {
            errors::errorn(right, "Incompatible type, expected arithmetic type, got ", debug::type_to_str((@right).tpe))
        }
        if not is_arithmetic((@left).tpe) {
            errors::errorn(right, "Incompatible type, expected arithmetic type, got ", debug::type_to_str((@left).tpe))
        }
        node.tpe = (@left).tpe
    }
}

def walk_AssignEqBitwise(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::AND_EQ:
            convert_to_icall(node, "__iand__", args, state)
        case parser::NodeKind::OR_EQ:
            convert_to_icall(node, "__ior__", args, state)
        case parser::NodeKind::XOR_EQ:
            convert_to_icall(node, "__ixor__", args, state)
        case parser::NodeKind::SHL_EQ:
            convert_to_icall(node, "__ilshift__", args, state)
        case parser::NodeKind::SHR_EQ:
            convert_to_icall(node, "__irshift__", args, state)
    } 

    if node.kind != parser::NodeKind::ASSIGN {
        if not is_integer((@right).tpe) {
            errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@right).tpe))
        }
        if not is_integer((@left).tpe) {
            errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@left).tpe))
        }

        node.tpe = (@left).tpe
    }
}

def walk_AssignEqPtr(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@right).tpe))
    }
    if not is_pointer((@left).tpe) {
        errors::errorn(right, "Incompatible type, expected pointer type, got ", debug::type_to_str((@left).tpe))
    }

    node.tpe = (@left).tpe
}

def walk_Cast(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }
    
    var rtpe = type_lookup(right, state)
    if not rtpe { return }
    if rtpe.kind == TypeKind::TYPE_CONSTRUCTOR {
        errors::errorn(right, "Can't cast to type constructor")
        return
    }

    if (@left).kind == parser::NodeKind::STRUCT_LIT {
        if (@rtpe).kind != TypeKind::STRUCT and
            (@rtpe).kind != TypeKind::UNION and 
            not (rtpe.kind == TypeKind::REFERENCE and rtpe.tpe and 
                (rtpe.tpe.kind == TypeKind::STRUCT or rtpe.tpe.kind == TypeKind::UNION)) {
            errors::errorn(left, "Invalid cast")
            return
        }
        node.tpe = rtpe
        (@left).tpe = node.tpe
        walk(node, left, state)
        return
    }
    if (@left).kind == parser::NodeKind::ARRAY_LIT {
        if (@rtpe).kind != TypeKind::ARRAY and 
            (@rtpe).kind != TypeKind::STATIC_ARRAY {
            errors::errorn(left, "Invalid cast")
            return
        }
        walk(node, left, state)
        node.tpe = rtpe
        return
    }

    walk(node, left, state)
    var ltpe = left.tpe
    if not ltpe { return }

    if equals(ltpe, rtpe) or (equals(ltpe, builtins::Ref_) and (is_ref(rtpe) or is_weak_ref(rtpe))) {
    } else if equals(rtpe, builtins::Ref_) {
        if not (is_ref(ltpe) or is_weak_ref(ltpe)) {
            errors::errorn(left, "Invalid cast")
            return
        }   
    } else if is_struct(ltpe) or is_struct(rtpe) {
        if ltpe.kind != rtpe.kind and not is_ref(rtpe) { 
            errors::errorn(left, "Invalid cast") 
            return
        }
    } else if is_struct(ltpe) and is_struct(rtpe) {
        if not equals(ltpe, rtpe) { 
            errors::errorn(left, "Invalid cast") 
            return
        }
    }

    node.tpe = rtpe

    var initial_ltpe = copy(left.tpe)
    ltpe = initial_ltpe

    while ltpe and rtpe and ltpe.kind == rtpe.kind and is_box(ltpe) {            
        ltpe = ltpe.tpe
        rtpe = rtpe.tpe
    }

    if ltpe and rtpe and rtpe.tc_args {
        node.tpe = initial_ltpe
        ltpe.tc_args = rtpe.tc_args
        ltpe.tc_tpe = rtpe.tc_tpe
    } 
}

def walk_Import(node: *parser::Node, state: *State) {
    if not current_function(state).is_global {
        errors::errorn(node, "Can only import at top level")
        return
    }

    let imports = node.value.body
    for var i in 0..vector::length(imports) {
        let imprt = vector::get(imports, i) !*parser::Node
        var name = (@imprt).value.import_module.name
        toolchain::typecheck_module(name)
    }
}

// Redefine function parameters to get rid of the stub types
export def lookup_parameters(node: *parser::Node, state: *State) -> *Type {
    let share = node.value.def_.share
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let tpe = node.tpe

    if node.value.def_.has_lookup { return tpe }
    node.value.def_.has_lookup = true

    for var i in 0..vector::length(params) {
        let param = vector::get(params, i) !*parser::Node
        let named = vector::get(tpe.parameter_t, i) !*NamedParameter
        if not named.tpe or named.tpe.kind != TypeKind::TYPE {
            let new_type = type_lookup(param.value.param.tpe, state, named.tpe, false)
            if new_type {
                named.tpe = new_type
            }
        }
    }
    for var i in 0..vector::length(returns) {
        let n = vector::get(returns, i) !*parser::Node
        let current_return_type = vector::get(tpe.return_t, i) !*Type
        let new_type = type_lookup(n, state, current_return_type, false)
        if new_type {
            @current_return_type = @new_type
        }
    }

    tpe.type_name = mangle_function_name(append_module(tpe.name, tpe.module.module), tpe.parameter_t)
    node.tpe = tpe

    return tpe
}

def check_is_valid_function(ident: *parser::Node, par: *vector::Vector, state: *State) {
    let name = parser::identifier_to_str(ident)
    if name == "destruct" {
        if vector::length(par) != 1 {
            errors::errorn(ident, "Destructor takes exactly one parameter of a pointer type")
            return
        }
        let first = (vector::get(par, 0) !*NamedParameter).tpe
        if not first or first.kind != TypeKind::POINTER {
            errors::errorn(ident, "Destructor takes exactly one parameter of a pointer type")
            return
        }
        // TODO This is a useful restriction but its problematic with polymorphic types
        /*if not first.tpe or first.tpe.module != state.module {
            errors::errorn(ident, "Argument type needs to be defined in the same file as the destructor")
            return
        }*/
    } else if name == "construct" {
        if vector::length(par) != 2 {
            errors::errorn(ident, "Copy constructor takes exactly two parameters of the same pointer type")
            return
        }
        let first = (vector::get(par, 0) !*NamedParameter).tpe
        let second = (vector::get(par, 1) !*NamedParameter).tpe
        if first.kind != TypeKind::POINTER or not equals(first, second) {
            errors::errorn(ident, "Copy constructor takes two parameters of the same pointer type")
            return
        }
        /*if not first.tpe or first.tpe.module != state.module {
            errors::errorn(ident, "Argument types need to be defined in the same file as the copy constructor")
            return
        }*/
    }
}

export def walk_Def(node: *parser::Node, state: *State) {
    let share = node.value.def_.share
    let body = node.value.def_.body
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let extern = node.value.def_.extern
    let dllimport = node.value.def_.dllimport
    let outer_scope = node.scope
    let inner_scope = node.inner_scope
    let imported = (share !int & parser::ShareMarker::IMPORT !int) !bool

    if not name or not params or not returns { return }

    // TODO
    /*if not current_function(state).is_global {
        if share != parser::ShareMarker::NONE {
            errors::errorn(node, "Can't share non top level function")
        }
    }*/
    
    if not node.tpe { return }
    let tpe = make_function_type_n(name, node.tpe.parameter_t, node.tpe.return_t, state.module, extern, imported, dllimport)
    tpe.node = node
    check_is_valid_function(name, node.tpe.parameter_t, state)

    var phase = scope::Phase::DECLARED
    if body {
        phase = scope::Phase::COMPILED
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = vector::get(tpe.parameter_t, i) !*NamedParameter 
            var tpe2 = np.tpe
            if tpe2 {
                if tpe2.kind == TypeKind::TYPE { continue }
                if tpe2.kind == TypeKind::TYPE_CONSTRUCTOR {
                    errors::errorn(np.node, "Can't use type constructor as function argument")
                    np.tpe = null
                }
            }
            if np.varargs {
                if np.tpe {
                    scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, array(np.tpe), null)
                }
            } else {
                scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, np.tpe, null)
            }
        }
    }

    //if not current_function(state).is_global {
        // This is so that we don't create overloaded functions
        // inside of a function
        // TODO what about forward declarations?
    //    scope::create_variable(outer_scope, name, share, parser::VarDecl::CONST, tpe, null)
    //} else {
        scope::create_function(outer_scope, name, share, tpe, phase, node, state)
    //}
    
    if body {
        let function = allocate(Function)
        @function = {
            tpe = tpe,
            locals = map::make()
        } !Function

        state.scope = inner_scope
        push_function(state, function)

        let body_copy = vector::copy(body)
        for var i in 0..vector::length(body_copy) {
            // Eval constant expressions
            consteval::walk(node, vector::get(body_copy, i) !*parser::Node, state)
        }
        for var i in 0..vector::length(body) {
            walk(node, vector::get(body, i) !*parser::Node, state)
        }

        pop_function(state)
        state.scope = outer_scope

        node.value.def_.locals = function.locals
        node.value.def_.has_defer = function.has_defer
    }

    node.tpe = tpe
}

def check_is_recursive(tpe: *Type, types: *map::Map = null) -> bool {
    if not tpe { return false }
    if not types { types = map::make() }
    if tpe.kind == TypeKind::STATIC_ARRAY {
        return check_is_recursive(tpe.tpe, types)
    }
    if tpe.kind == TypeKind::STRUCT or tpe.kind == TypeKind::UNION {
        if tpe.name != "<anonymous>" {
            if map::contains(types, tpe.type_name) { return true }
            map::put(types, tpe.type_name, map::sentinel)
        }
        for var i in 0..tpe.fields.size {
            let new_types = map::make()
            let keys = map::keys(types)
            for var j in 0..keys.size {
                map::put(new_types, keys[j], map::get(types, keys[j]))
            }
            if check_is_recursive(tpe.fields[i].tpe, new_types) { return true }
        }
    }
    return false
}

def walk_TypeDecl(node: *parser::Node, state: *State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right

    if vector::length(left) < vector::length(right) {
        errors::errorn(node, "Too many values to assign")
        return
    }

    for var i in 0..vector::length(left) {
        let left = vector::get(left, i) !*parser::Node
        var name = left
        if left.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
            name = left.value.type_constructor.name
        }

        var value: *parser::Node = null
        if i < vector::length(right) {
            value = vector::get(right, i) !*parser::Node
        }
        
        var tpe = make_type(TypeKind::STUB, name)
        if value {
            tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::COMPILED, null, null)
            if not tpe {
                continue
            }
            
            if left.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
                tpe = lookup_type_constructor(left, value, state)
            } else {
                tpe = copy(type_lookup(value, state))
            }

            if not tpe { continue }
            tpe.name = parser::identifier_to_str(name)
            if value.kind != parser::NodeKind::TYPE_CONSTRUCTOR {
                tpe.type_name = append_module(tpe.name, node.loc.module)
            }
            tpe = scope::create_type(state.scope, name, share, tpe, scope::Phase::COMPILED, null, null)
        }
        name.tpe = tpe
        name.tpe.share = share
    }
}

def walk_Return(node: *parser::Node, state: *State) {
    let current_fun = current_function(state)
    let body = node.value.body
    if current_fun.is_global {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errors::errorn(node, "return outside of a function")
        return
    }
    let tpe = current_fun.tpe

    let ltypes = tpe.return_t
    let rtypes = collapse_types(node, ltypes, body, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        // TODO Improve error message
        errors::errorn(node, "Wrong number of arguments to return")
    }

    for var i in 0..vector::length(ltypes) {
        let argtpe = vector::get(ltypes, i) !*Type
        if i >= vector::length(rtypes) { return }

        var rettpe = vector::get(rtypes, i) !*Type
        
        if not argtpe or not rettpe { continue }
        if not is_assignable(argtpe, rettpe, state.module) {
            // TODO This doesn't point to the actual value
            errors::errorn(node, "Wrong type of return argument, got ", debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe))
        }
    }
    node.tpe = tpe
}

def append_arguments(buf: *buffer::Buffer, arguments: *vector::Vector) {
    let len = vector::length(arguments)
    if len > 0 {
        buffer::append_str(buf, "Arguments were of type ")
    } else {
        buffer::append_str(buf, "No arguments.")
    }
    for var i in 0..len {
        let arg = vector::get(arguments, i) !*NamedParameter
        buffer::append_str(buf, debug::type_to_str((@arg).tpe))
        if i < len - 1 {
            buffer::append_str(buf, ", ")
        }
    }
}

export def walk_Call(node: *parser::Node, dry_run: bool, state: *State) -> bool {
    var left = node.value.func_call.left
    if not left { return false }
    if not dry_run {
        if left.kind != parser::NodeKind::IDENTIFIER {
            walk(node, left, state)
        } else {
            let value = scope::get(state.scope, left, true, false, true)
            if value {
                left.svalue = value
                left.tpe = value.tpe
            }
        }
    }
    // We need to do this because member access overwrites the parent node
    left = node.value.func_call.left
    var tpe = (@left).tpe

    var arguments = vector::make()
    for var i in 0..vector::length(node.value.func_call.args) {
        let n = vector::get(node.value.func_call.args, i) !*parser::Node
        walk(node, n, state)
        let np = allocate(NamedParameter)
        @np = {
            name = "",
            tpe = (@n).tpe,
            varargs = false,
            node = n
        } !NamedParameter
        
        if equals(np.tpe, pointer(builtins::Type_)) {
            np.value = allocate(compiler::Value)
            @np.value = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe } !compiler::Value
        }

        vector::push(arguments, np)
    }

    let parameter_map = map::make()
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let n = vector::get(node.value.func_call.kwargs, i) !*parser::Node
        walk(node, (@n).value.named_arg.value, state)
        let name = last_ident_to_str((@n).value.named_arg.name)

        if map::contains(parameter_map, name) {
            // and we cannot have two things with the same name so just error here...
            errors::errorn(n, "Cannot have the same parameter name multiple times in a function call. Parameter name was `", name, "`.")
            break
        } else {
            map::put(parameter_map, name, map::sentinel)
            let np = allocate(NamedParameter)
            @np = {
                name = name,
                tpe = (@(@n).value.named_arg.value).tpe,
                varargs = false,
                node = (@n).value.named_arg.name
            } !NamedParameter

            if equals(np.tpe, builtins::Type_) {
                np.value = allocate(compiler::Value)
                @np.value = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe } !compiler::Value
            }

            vector::push(arguments, np)
        }
    }

    if not is_function_pointer(tpe) {
        let args = vector::copy(arguments)
        let np = allocate(NamedParameter)
        @np = { name = "", tpe = tpe } !NamedParameter
        vector::insert(args, 0, np)

        let ident = parser::make_identifier(["apply"])
        let fun = scope::get_function(state.scope, ident, args, true)
        if fun { 
            @node = @make_function_call(node, ident) 
            walk_Call(node, state)
            return true
        } else {
            if (@left).kind == parser::NodeKind::IDENTIFIER {
                var exists, function = scope::get_function_check(state.scope, left, arguments, false, dry_run)
                left.svalue = function

                if not function and dry_run { return false }

                if left.value.identifier.types {
                    if not function {
                        errors::errorn(left, "Function overload not found")
                        return false
                    }
                    if overload_score(function.tpe, arguments, state.module, false) < 0 {
                        let buf = buffer::make_buffer()
                        buffer::append_str(*buf, "Incorrect arguments to overloaded function. ")
                        append_arguments(*buf, arguments)
                        errors::errorn(left, buffer::to_string(*buf))
                        return false
                    }
                }

                if not function and not exists {
                    for var i in 0..vector::length(arguments) {
                        // Suppress error message if we got invalid parameters
                        let np = vector::get(arguments, i) !*NamedParameter
                        if not np.tpe { return false }
                    }

                    let buf = buffer::make_buffer()
                    buffer::append_str(*buf, "Function `")
                    buffer::append_str(*buf, parser::identifier_to_str(left))
                    buffer::append_str(*buf, "` not found. ")
                    
                    append_arguments(*buf, arguments)
                    errors::errorn(left, buffer::to_string(*buf))
                }
                if not function { return false }

                // Check if all arguments were provided
                for var i in 0..vector::length(function.tpe.parameter_t) {
                    let np = vector::get(function.tpe.parameter_t, i) !*NamedParameter
                    if i < vector::length(node.value.func_call.args) { continue }
                    if not map::contains(parameter_map, np.name) and not np.value and not np.varargs {
                        errors::errorn(node, "Missing argument `", np.name, "` at position ", util::int_to_str(i))
                    }
                }

                tpe = copy(function.tpe)
            } else {
                errors::errorn(left, "Can't call expression")
                return false
            }
        }
    }

    node.function = tpe
    if is_function_pointer(tpe) {
        tpe = (@tpe).tpe
    }
    
    let parameter_t = (@tpe).parameter_t

    // Implicit conversions, this also removes type parameters from the argument list
    for var i in 0..vector::length(node.value.func_call.args) {
        let n = vector::get(node.value.func_call.args, i) !*parser::Node
        var rhstpe: *Type = null
        if i < vector::length(parameter_t) {
            rhstpe = (@(vector::get(parameter_t, i) !*NamedParameter)).tpe
        } else {
            let np = vector::peek(parameter_t) !*NamedParameter
            assert((@np).varargs)
            rhstpe = (@np).tpe
        }

        implicit_conversion(n, rhstpe, state)
    }
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let n = vector::get(node.value.func_call.kwargs, i) !*parser::Node
        let name = last_ident_to_str((@n).value.named_arg.name)
        let arg = (@n).value.named_arg.value

        var rhstpe: *Type = null
        for var j in 0..vector::length(parameter_t) {
            let param = vector::get(parameter_t, j) !*NamedParameter
            if (@param).name == name {
                rhstpe = (@param).tpe
                break
            }
        }

        implicit_conversion(arg, rhstpe, state)
    }

    node.tpe = flatten_return_type(node, tpe.return_t)
    return true
}

def walk_Call(node: *parser::Node, state: *State) {
    walk_Call(node, false, state)
}

def walk_Case(node: *parser::Node, state: *State) {
    for var i in 0..vector::length(node.value.case_.expr) {
        let expr = vector::get(node.value.case_.expr, i) !*parser::Node
        walk(node, expr, state)
        if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) or is_range((@expr).tpe)){
            errors::errorn(expr, "Incompatible type, expected arithmetic type, range or enum, got ", debug::type_to_str((@expr).tpe))
            return
        }

        if expr.kind == parser::NodeKind::RANGE or expr.kind == parser::NodeKind::RANGE_INC {
            let left = expr.value.bin_op.left
            let right = expr.value.bin_op.right
            left.svalue = consteval::make_value(consteval::expr(left, state))
            right.svalue = consteval::make_value(consteval::expr(right, state))
        } else {
            expr.svalue = consteval::make_value(consteval::expr(expr, state))
        }
    }

    for var i in 0..vector::length(node.value.case_.body) {
        let expr = vector::get(node.value.case_.body, i) !*parser::Node
        walk(node, expr, state)
    }
}

def walk_Switch(node: *parser::Node, state: *State) {
    let expr = node.value.switch_.expr
    walk(node, expr, state)
    if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) ){
        errors::errorn(expr, "Incompatible type, expected arithmetic type or enum, got ", debug::type_to_str((@expr).tpe))
        return
    }

    for var i in 0..vector::length(node.value.switch_.body) {
        walk(node, vector::get(node.value.switch_.body, i) !*parser::Node, state)
    }
}

def walk_If(node: *parser::Node, state: *State) {
    let cond = node.value.if_.cond
    walk(node, cond, state)
    let tpe = (@cond).tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }
    
    for var i in 0..vector::length(node.value.if_.body) {
        let n = vector::get(node.value.if_.body, i) !*parser::Node
        walk(node, n, state)
    }

    for var i in 0..vector::length(node.value.if_.else_if) {
        let n = vector::get(node.value.if_.else_if, i) !*parser::Node
        
        let cond = (@n).value.else_if.cond
        walk(node, cond, state)
        let tpe = (@cond).tpe
        
        if not is_boolean(tpe) {
            errors::errorn(n, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
        }

        for var i in 0..vector::length((@n).value.else_if.body) {
            let n2 = vector::get((@n).value.else_if.body, i) !*parser::Node
            walk(node, n2, state)
        }   
    }

    let else_ = node.value.if_.else_
    if else_ {
        for var i in 0..vector::length((@else_).value.body) {
            let n = vector::get((@else_).value.body, i) !*parser::Node
            walk(node, n, state)
        }
    }
}

def walk_IfExpr(node: *parser::Node, state: *State) {
    let cond = node.value.if_expr.cond
    walk(node, cond, state)

    let tpe = cond.tpe
    if not tpe { return }
    if not is_boolean(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }

    let if_true = node.value.if_expr.if_true
    let if_false = node.value.if_expr.if_false
    walk(node, if_true, state)
    walk(node, if_false, state)

    if not equals(if_true.tpe, if_false.tpe) {
        errors::errorn(node, "If expression needs to have a single type")
    }

    node.tpe = if_true.tpe
}

def walk_Loop(node: *parser::Node, state: *State) {
    for var i in 0..vector::length(node.value.body) {
        let n = vector::get(node.value.body, i) !*parser::Node
        walk(node, n, state)
    }
}

def walk_While(node: *parser::Node, state: *State) {
    let expr = node.value.while_loop.expr
    if not expr { return }
    walk(node, expr, state)
    if not is_boolean((@expr).tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str((@expr).tpe), ", must be boolean type")
    }

    for var i in 0..vector::length(node.value.while_loop.body) {
        let n = vector::get(node.value.while_loop.body, i) !*parser::Node
        walk(node, n, state)
    }
}

def walk_For(node: *parser::Node, state: *State) {
    let expr = node.value.for_loop.expr
    walk(node, expr, state)

    let iddecl = node.value.for_loop.iddecl
    var tpe = builtins::int_
    if is_array((@expr).tpe) {
        tpe = (@(@expr).tpe).tpe
    }
    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        (@iddecl).tpe = tpe
        (@iddecl).scope = node.inner_scope
        let ident = (@iddecl).value.for_id_decl.ident
        scope::create_variable(
            node.inner_scope, 
            ident, 
            parser::ShareMarker::NONE, 
            (@iddecl).value.for_id_decl.kw, 
            tpe, null
        )
        let svalue = scope::get(node.inner_scope, ident)
        
        map::put(current_function(state).locals, svalue.assembly_name, tpe)
    } else {
        walk(node, iddecl, state)
        if not equals(tpe, (@iddecl).tpe) {
            errors::errorn(iddecl, "Type didn't match, expected ", debug::type_to_str(tpe), ", got ", debug::type_to_str((@iddecl).tpe))
        }
    }

    for var i in 0..vector::length(node.value.for_loop.body) {
        let n = vector::get(node.value.for_loop.body, i) !*parser::Node
        walk(node, n, state)
    }
}

def walk_Deref(node: *parser::Node, state: *State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }
    if not is_pointer(tpe) and not is_ref_or_weak(tpe) {
        errors::errorn(node, "Needs to be a pointer or reference type, got ", debug::type_to_str(tpe))
        return
    }
    node.tpe = tpe.tpe
    node.kw = tpe.kw
}

def walk_Ptr(node: *parser::Node, state: *State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }
    node.tpe = pointer(tpe, tpe.kw)
}

def walk_MemberAccess_ucs(node: *parser::Node, state: *State) -> bool {
    let right = node.value.bin_op.right
    let left = node.value.bin_op.left
    let parent = node.parent
    let tpe = (@left).tpe

    if (@parent).kind == parser::NodeKind::FUNC_CALL and
        (@parent).value.func_call.left == node {
        let old_parent = @parent
        let old_args = vector::copy((@parent).value.func_call.args)
        parent.value.func_call.left = right
        vector::prepend((@parent).value.func_call.args, left)

        if not walk_Call(parent, true, state) {
            @parent = old_parent
            parent.value.func_call.args = old_args
            return false 
        }
    } else {
        let parameter_t = vector::make()
        let np = allocate(NamedParameter)
        @np = {
            name = "",
            tpe = (@left).tpe
        } !NamedParameter
        vector::push(parameter_t, np)

        let function = scope::get_function(node.scope, right, parameter_t, false)
        if not function { return false }

        let args = vector::make()
        vector::push(args, left)
        @node = {
            kind = parser::NodeKind::FUNC_CALL,
            loc = node.loc,
            parent = parent
        } !parser::Node
        node.value.func_call = {
            left = right,
            args = args,
            kwargs = vector::make()
        } !parser::NodeFuncCall
        
        walk(parent, node, state)
    }
    return true
}

def resolve_member(fields: [StructMember], name: string) -> *Type {
    for var i in 0..fields.size {
        let member = fields[i]
        if length(member.name) > 0 {
            if member.name == name {
                return member.tpe
            }
        } else {
            let member = resolve_member((@member.tpe).fields, name)
            if member { return member }
        }
    }
    return null
}

def walk_MemberAccess(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    walk(node, left, state)
    let tpe = (@left).tpe

    if is_pointer(tpe) or is_ref_or_weak(tpe) {
        let old_left = parser::copy_node(left)
        let new_left = {
            kind = parser::NodeKind::DEREF,
            loc = (@left).loc,
            tpe = tpe.tpe
        } !parser::Node
        new_left.value.expr = old_left
        @left = new_left
        if walk_MemberAccess_aggregate(node, false, state) { return }
        
        @left = @old_left
        if walk_MemberAccess_ucs(node, state) { return }

        @left = new_left
        if not walk_MemberAccess_ucs(node, state) {
            errors::errorn(node, "Unknown field `", last_ident_to_str(right), "`")
        }
        return
    }

    walk_MemberAccess_aggregate(node, true, state)
}

def walk_MemberAccess_aggregate(node: *parser::Node, ucs: bool, state: *State) -> bool {
    let right = node.value.bin_op.right
    let left = node.value.bin_op.left
    let tpe = left.tpe
    if not tpe { return false }

    if (@tpe).kind == TypeKind::STRUCT or (@tpe).kind == TypeKind::UNION {
        let name = last_ident_to_str(right)

        let rtpe = resolve_member((@tpe).fields, name)
        if not rtpe {
            if ucs {
                if walk_MemberAccess_ucs(node, state) { return true }
                errors::errorn(node, "Unknown field `", name, "`")
            }
            return false
        }
        node.tpe = rtpe
    } else if (@tpe).kind == TypeKind::ARRAY or (@tpe).kind == TypeKind::STATIC_ARRAY {
        let name = last_ident_to_str(right)
        if name == "size" {
            node.tpe = builtins::size_t_
        } else if name == "value" {
            node.tpe = pointer((@tpe).tpe)
        } else {
            if ucs {
                if walk_MemberAccess_ucs(node, state) { return true }
                errors::errorn(node, "Expected size or value")
            }
            return false
        }
    // TODO Enums might have ordinal and some other information
    } else {
        if ucs {
            if walk_MemberAccess_ucs(node, state) { return true }
            errors::errorn(node, "Expected aggregate type, got ", debug::type_to_str(tpe), )
        }
        return false
    }
    return true
}

def walk_ArraySubscript(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right

    walk(node, left, state)
    walk(node, right, state)

    if not left or not right { return }
    let tpe = (@left).tpe
    if not tpe { return }

    if node.parent.kind == parser::NodeKind::ASSIGN {
        let index = vector::index_of(node.parent.value.assign.left, node)
        if index == -1 {
            let args = create_args(left, right)
            convert_to_call(node, "get_item", args, state)
        } else if index < vector::length(node.parent.value.assign.right) {
            // TODO This is done twice
            let value = vector::get(node.parent.value.assign.right, index) !*parser::Node
            walk(node.parent, value, state)

            let args = vector::make()
            let np1 = allocate(NamedParameter)
            @np1 = { name = "", tpe = left.tpe }
            let np2 = allocate(NamedParameter)
            @np2 = { name = "", tpe = right.tpe }
            let np3 = allocate(NamedParameter)
            @np3 = { name = "", tpe = value.tpe }
            vector::push(args, np1)
            vector::push(args, np2)
            vector::push(args, np3)

            let set_item = scope::get_function(state.scope, parser::make_identifier(["set_item"]), args)
            if set_item {
                return
            } 
        }
    } else {
        let args = create_args(left, right)
        convert_to_call(node, "get_item", args, state)
    }
    
    
    if node.kind != parser::NodeKind::FUNC_CALL {
        if is_pointer(tpe) or (@tpe).kind == TypeKind::ARRAY or
            (@tpe).kind == TypeKind::STATIC_ARRAY {
            node.kw = tpe.kw
            node.tpe = tpe.tpe
        } else if is_ref(tpe) and tpe.tpe and is_array(tpe.tpe) {
            node.kw = tpe.kw
            node.tpe = tpe.tpe.tpe
        } else {
            errors::errorn(left, "Expected array or pointer type, got ", debug::type_to_str(tpe))
        }
        if not is_arithmetic((@right).tpe) {
            errors::errorn(right, "Expected arithmetic type, got ", debug::type_to_str((@right).tpe))
        }
    }
}

def walk_StructLit(node: *parser::Node, state: *State) {
    let prev_tpe = node.tpe
    var tpe = prev_tpe

    // This instructs compile to skip the struct literal completely
    node.tpe = null

    if is_ref(tpe) {
        tpe = tpe.tpe
    }

    if not tpe {
        errors::errorn(node, "Need to specify a type for struct literal")
        return
    }

    for var i in 0..vector::length(node.value.struct_lit.args) {
        let n = vector::get(node.value.struct_lit.args, i) !*parser::Node
        if i > (@tpe).fields.size {
            errors::errorn(n, "Too many arguments to struct literal")
            return
        }

        var ntpe = (@tpe).fields[i].tpe
        if is_struct(ntpe) {
            n.tpe = ntpe
        }

        walk(node, n, state)
        implicit_conversion(n, ntpe, state)

        if not ntpe or not (@n).tpe { continue }
        if not is_assignable(ntpe, (@n).tpe, state.module) {
            errors::errorn(n, "Incompatible types ", debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe))
            return
        }
    }
    for var i in 0..vector::length(node.value.struct_lit.kwargs) {
        let kwarg = vector::get(node.value.struct_lit.kwargs, i) !*parser::Node
        let n = (@kwarg).value.named_arg.value
        walk(node, n, state)
        let name = last_ident_to_str((@kwarg).value.named_arg.name)

        var found = false
        for var j in 0..(@tpe).fields.size {
            let field = (@tpe).fields[j]
            if field.name == name {
                found = true

                var ntpe = field.tpe
                implicit_conversion(n, ntpe, state)

                if not ntpe or not (@n).tpe { continue }
                if not is_assignable(ntpe, (@n).tpe, state.module) {
                    errors::errorn(n, "Incompatible types ", debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), )
                    return
                }
                break
            }
        }
        if not found {
            errors::errorn(n, "Unknown field `", name, "`")
            return
        }
    }

    node.tpe = prev_tpe
}

// TODO We might want to allow assignments like
// let array: [double] = [1, 2, 3, 4] // And convert to double here
def walk_ArrayLit(node: *parser::Node, state: *State) {
    var tpe: *Type = null
    let len = vector::length(node.value.body)
    for var i in 0..len {
        let n = vector::get(node.value.body, i) !*parser::Node
        walk(node, n, state)
        let t = (@n).tpe
        if not tpe { tpe = t }
        else {
            if not equals(tpe, t) {
                errors::errorn(n, "Incompatible types, all array elements need to have the same type. Array type ", 
                    debug::type_to_str(tpe), ", got ", debug::type_to_str(t))
                // It might be confusing to get multiple errors here
                break
            }
        }
    }
    if not tpe {
        tpe = builtins::char_
    }
    
    let ret_tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@ret_tpe).line = node.loc.line
    (@ret_tpe).length = len
    (@ret_tpe).tpe = tpe
    (@ret_tpe).size = len * (@tpe).size
    (@ret_tpe).align = (@tpe).align

    node.tpe = ret_tpe
}

def walk_SizeOf(node: *parser::Node, state: *State) {
    let expr = node.value.expr
    if not expr { return }
    expr.tpe = type_lookup(expr, state)
    node.tpe = builtins::size_t_
}

def walk_AlignOf(node: *parser::Node, state: *State) {
    let expr = node.value.expr
    if not expr { return }
    expr.tpe = type_lookup(expr, state)
    node.tpe = builtins::size_t_
}

// TODO the operator overloading breaks a > b > c chains
// Do the conversion inside of the parser
def walk_ComparisionOp(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)

    let args = create_args(left, right)

    switch node.kind {
        case parser::NodeKind::EQ:
            convert_to_call(node, "__eq__", args, state)
        case parser::NodeKind::NEQ:
            convert_to_call(node, "__ne__", args, state)
        case parser::NodeKind::GT:
            convert_to_call(node, "__gt__", args, state)
        case parser::NodeKind::LT:
            convert_to_call(node, "__lt__", args, state)
        case parser::NodeKind::GEQ:
            convert_to_call(node, "__ge__", args, state)
        case parser::NodeKind::LEQ:
            convert_to_call(node, "__le__", args, state)
    }

    if node.kind != parser::NodeKind::FUNC_CALL {
        if builtins::Type_ and equals(left.tpe, pointer(builtins::Type_)) {
            let equals = scope::get(toolchain::runtime.scope, parser::make_identifier(["equals"]))
            consteval::compile_function(equals.node, equals.state)
        }

        // TODO We can compare almost everything
        node.tpe = builtins::bool_
    }
}

def walk_PAdd(node: *parser::Node, state: *State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)
    if not is_pointer((@left).tpe) {
        errors::errorn(left, "Must be pointer type, got ", debug::type_to_str((@left).tpe))
    }
    if not is_arithmetic((@right).tpe) {
        errors::errorn(left, "Must be arithmetic type, got ", debug::type_to_str((@right).tpe))
    }
    // TODO should probably not set this to a garbage value
    node.tpe = (@left).tpe
}

def walk_PSub(node: *parser::Node, state: *State) {
    walk_PAdd(node, state)
}

def walk_Defer(node: *parser::Node, state: *State) {
    let function = current_function(state)
    function.has_defer = true

    if state.in_defer { 
        errors::errorn(node, "Can't nest defers!")
    }

    state.in_defer = true
    for var i in 0..vector::length(node.value.body) {
        let n = vector::get(node.value.body, i) !*parser::Node
        walk(node, n, state)
    }
    state.in_defer = false
}

def walk_Assert(node: *parser::Node, state: *State) {
    let cond = node.value.assert_.cond
    let msg = node.value.assert_.message
    walk(node, cond, state)
    walk(node, msg, state)

    if cond and not is_boolean(cond.tpe) {
        errors::errorn(cond, "Incompatible type ", debug::type_to_str(cond.tpe), ", must be boolean type")
    }
    if msg and not equals(msg.tpe, builtins::string_) {
        errors::errorn(msg, "Incompatible type ", debug::type_to_str(msg.tpe), ", must be string type")
    }

    // Compile stderr function
    let std_module = map::get(toolchain::modules, "std") !*toolchain::Module
    scope::get(std_module.scope, parser::make_identifier(["stderr"]))
}

export def walk(parent: *parser::Node, node: *parser::Node, state: *State) {
    if not node { return }
    node.parent = parent

    let scpe = state.scope
    if node.scope {
        state.scope = node.scope
    }

    switch node.kind !int {
        case parser::NodeKind::NULL:
            walk_Null(node, state)
        case parser::NodeKind::UNDEF:
            walk_Undef(node, state)
        case parser::NodeKind::INTEGER:
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN:
            walk_Boolean(node, state)
        case parser::NodeKind::STRING:
            walk_String(node, state)
        case parser::NodeKind::CHAR:
            walk_Char(node, state)
        case parser::NodeKind::FLOAT:
            walk_Float(node, state)
        case parser::NodeKind::RANGE..=parser::NodeKind::RANGE_INC:
            walk_Range(node, state)
        case parser::NodeKind::IDENTIFIER:
            walk_Identifier(node, state)
        case parser::NodeKind::SIZE_OF:
            walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF:
            walk_AlignOf(node, state)
        case parser::NodeKind::LOOP:
            walk_Loop(node, state)
        case parser::NodeKind::WHILE:
            walk_While(node, state)
        case parser::NodeKind::FOR:
            walk_For(node, state)
        case parser::NodeKind::IF_EXPR:
            walk_IfExpr(node, state)
        case parser::NodeKind::IF:
            walk_If(node, state)
        case parser::NodeKind::SWITCH:
            walk_Switch(node, state)
        case parser::NodeKind::CASE:
            walk_Case(node, state)
        case parser::NodeKind::DEF:
            walk_Def(node, state)
        case parser::NodeKind::IMPORT:
            walk_Import(node, state)
        case parser::NodeKind::CAST:
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN:
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL:
            walk_VarDecl(node, state)
        case parser::NodeKind::UADD:
            walk_UAdd(node, state)
        case parser::NodeKind::USUB:
            walk_USub(node, state)
        case parser::NodeKind::BNOT:
            walk_BNot(node, state)
        case parser::NodeKind::NOT:
            walk_Not(node, state)
        case parser::NodeKind::ADD..=parser::NodeKind::MOD:
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..=parser::NodeKind::SHR:
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..=parser::NodeKind::OR:
            walk_BooleanOp(node, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ:
            walk_ComparisionOp(node, state)
        case parser::NodeKind::ADD_EQ..=parser::NodeKind::MOD_EQ:
            walk_AssignEqArithmetic(node, state)
        case parser::NodeKind::AND_EQ..=parser::NodeKind::SHR_EQ:
            walk_AssignEqBitwise(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::PSUB_EQ:
            walk_AssignEqPtr(node, state)
        case parser::NodeKind::PADD:
            walk_PAdd(node, state)
        case parser::NodeKind::PSUB:
            walk_PSub(node, state)
        case parser::NodeKind::DEREF:
            walk_Deref(node, state)
        case parser::NodeKind::PTR:
            walk_Ptr(node, state)
        case parser::NodeKind::TYPE_DECL:
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN:
            walk_Return(node, state)
        case parser::NodeKind::FUNC_CALL:
            walk_Call(node, state)
        case parser::NodeKind::BREAK..=parser::NodeKind::CONTINUE:
            null // NOOP
        case parser::NodeKind::MEMBER_ACCESS:
            walk_MemberAccess(node, state)
        case parser::NodeKind::ARRAY_SUBSCRIPT:
            walk_ArraySubscript(node, state)
        case parser::NodeKind::STRUCT_LIT:
            walk_StructLit(node, state)
        case parser::NodeKind::ARRAY_LIT:
            walk_ArrayLit(node, state)
        case parser::NodeKind::DEFER:
            walk_Defer(node, state)
        case parser::NodeKind::ASSERT:
            walk_Assert(node, state)
        case parser::NodeKind::PTR_T, parser::NodeKind::REF_T, 
            parser::NodeKind::ARRAY_T, parser::NodeKind::TYPE_CONSTRUCTOR:
            let tpe = copy(builtins::Type_)
            tpe.tpe = type_lookup(node, state)
            node.tpe = pointer(tpe)
        case parser::NodeKind::ARRAY_STATIC_T:
            walk_ArrayStaticT(node, state)
        // TODO Function types
        case parser::NodeKind::TYPE_OF_T:
            walk_TypeOfT(node, state)
        case:
            error(node.kind, "\n")
            assert
    }

    state.scope = scpe
}

export def make_state(module: *toolchain::Module) -> State {
    return {
        module = module,
        scope = module.scope,
        function_stack = vector::make()
    } !State
}

export def walk_Def_with_type_argument(node: *parser::Node, parameter_t: *vector::Vector, state: *State) {
    let old_node = node
    node = parser::deep_copy_node(node)
    node.inner_scope = scope::enter_function_scope(node.scope)

    let share = node.value.def_.share
    var tpe = node.tpe
    var body = node.value.def_.body

    for var i in 0..vector::length(parameter_t) {
        let np = vector::get(parameter_t, i) !*NamedParameter
        var left: *NamedParameter = null
        if length(np.name) > 0 {
            for var j in 0..vector::length(tpe.parameter_t) {
                let l = vector::get(tpe.parameter_t, j) !*NamedParameter
                if l.name == np.name {
                    left = l
                }
            }
        } else {
            left = vector::get(tpe.parameter_t, i) !*NamedParameter
        }

        if left and equals(left.tpe, builtins::type_) {
            left.value = allocate(compiler::Value)
            @left.value = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe } !compiler::Value
        }
    }

    let types_map = map::make()
    replace_type_defs(tpe.parameter_t, tpe.return_t, parameter_t, types_map, state.module)
    tpe.type_name = mangle_function_name(append_module(tpe.name, tpe.module.module), tpe.parameter_t)

    let keys = map::keys(types_map)
    for var i in 0..keys.size {
        let key = keys[i]
        let tpe2 = map::get(types_map, key) !*Type
        scope::create_type(node.inner_scope, parser::make_identifier([key]), parser::ShareMarker::NONE, tpe2)
    }

    state.scope = node.inner_scope
    node.value.def_.has_lookup = false
    node.tpe = tpe = lookup_parameters(node, state)

    if vector::length(tpe.parameter_t) > 0 {
        let first_param = vector::get(tpe.parameter_t, 0) !*NamedParameter
        create_type_entry(first_param.tpe, (share !int & parser::ShareMarker::EXPORT !int) != 0, tpe, state.module, true)
    }

    state.scope = node.scope
    walk_Def(node, state)

    // This makes sure that the function is walked by the compiler
    vector::push(state.module.node.body, node)
}

export def typecheck(module: *toolchain::Module) {
    let state = make_state(module)
    typecheck(*state)
}

export var time_spent: int64 = 0

export def typecheck(state: *State) {
    let start = util::millis()
    debug::trace("Typechecking ", state.module.module)

    let node = state.module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    node.scope = state.scope

    let string_array_tpe = array(builtins::string_)
    let args_ident = parser::make_identifier(["args"])

    // repl tries to define this multiple times 
    // so we need to skip the declaration if it alreay exists
    if not scope::get(node.scope, args_ident) {
        scope::create_variable(
            node.scope, 
            args_ident, 
            parser::ShareMarker::NONE, 
            parser::VarDecl::VAR, 
            string_array_tpe, null
        )
    }
    let value = scope::get(node.scope, args_ident)
    (@value).global = false
    
    if not toolchain::is_preload(state.module) {
        // compile standard library
        toolchain::typecheck_module(parser::make_identifier(["cstd"]))
        toolchain::typecheck_module(parser::make_identifier(["std"]))
        toolchain::typecheck_module(parser::make_identifier(["preload"]))
    }

    let function = allocate(Function)
    @function = {
        is_global = true,
        locals = map::make()
    } !Function

    push_function(state, function)
    for var i in 0..vector::length(node.body) {
        let n = vector::get(node.body, i) !*parser::Node
        switch n.kind !int {
            case parser::NodeKind::TYPE_DECL, parser::NodeKind::DEF, parser::NodeKind::VAR_DECL:
            case: walk(node, n, state)
        }
    }
    pop_function(state)

    node.value.program = {
        has_defer = function.has_defer,
        locals = function.locals
    } !parser::NodeProgram

    let keys = map::keys(node.scope.fields)
    for var i in 0..keys.size {
        var value = map::get(node.scope.fields, keys[i]) !*scope::Value
        while value {
            if value.phase == scope::Phase::DEFINED {
                scope::typecheck(value)
            }
            value = value.next
        }
    }

    let end = util::millis()
    time_spent += end - start
}

