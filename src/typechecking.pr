// TODO Many of these function will error twice with misleading errors
// Every function needs to check for possible null types and null nodes
// and abort in those cases

import map
import set
import vector
import parser
import util
import scope
import builtins
import debug
import toolchain
import compiler
import consteval
import errors
import runtime
import eval
import md5
import optional

export type TypeKind = enum {
    TYPE
    WORD
    FLOAT
    BOOL
    STRUCT
    UNION
    ENUM
    FUNCTION
    CLOSURE
    TUPLE
    POINTER
    BYREF // ref parameter
    REFERENCE
    WEAK_REF
    ARRAY
    STATIC_ARRAY
    RANGE
    RANGE_INC
    // Used for enums
    NAMESPACE
    // Auto cast, this type will convert to anything
    // AUTO_CAST // TODO Actually implement this
    // Forward declaration
    STUB
    // Placeholder for arguments with polymorphic type parameter in function definition
    TYPE_DEF
    // Null
    NULL
    UNDEF
    CHAR
    STRUCTURAL
    // This is a type with arguments
    TYPE_CONSTRUCTOR
    // This is used as a function parameter that is generic
    GENERIC
    // This is used to express types that may by resolved to multiple types
    VARIANT
    // Tagged union types, very similar to VARIANT but the equality relation is different
    // This is actually called variant in runtime
    TUNION
    // References to structs are using a wk reference, ie. Type::wk instead of Type::_tpe
    // This is because references to structs can cause cycles
    // TODO I think we don't really need this because we can just use wk directly
    BOX
    VOID
    TO_INFER // Placeholder type for inference
}

export type TypeMember = struct {
    tpe: &Type
    offset: size_t
}

export type StructMember = struct {
    // Source line
    line: int
    node: weak &parser::Node
    name: Str
    tpe: &Type
    // index into the field_types vector
    index: size_t

    is_bitfield: bool
    bit_size: size_t
    bit_offset: size_t

    is_embed: bool
    is_const: bool
    value: &compiler::Value
}

export type StructuralTypeMember = struct {
    name: Str
    // Vector of NamedParameter
    parameter_t: &Vector(NamedParameter)
    // Vector of Type
    return_t: &Vector(&Type)
}

export type TypeRef = struct {
    module: weak &toolchain::Module
    name: Str
}

export def == (a: TypeRef, b: TypeRef) -> bool {
    return a.module == b.module and a.name == b.name
}
export def != (a: TypeRef, b: TypeRef) -> bool {
    return not (a == b)
}
export def hash(v: TypeRef) -> uint64 {
    return combine_hashes(hash(v.module), hash(v.name))
}

// TODO Really, types should not be copied. There should only be one instance for every given type.
// This would make comparing them so much easier but changing that at this point might be too much work.
// It would also make the whole TypeMeta thing useless in the process.
export type Type = struct {
    kind: TypeKind
    // Source line
    line: int
    module: weak &toolchain::Module
    // Module that this type was defined in
    _defmodule: weak &toolchain::Module
    context: weak &toolchain::Module
    state: &State
    // Name of the type as used by the source code
    // Might be the name of a typedef
    name: Str
    // Unique name of the type
    type_name: Str
    // Size in bytes
    size: size_t
    align: size_t
    unsig: bool
    // Static array
    length: size_t
    kw: parser::VarDecl
    // Type both used for array/pointer and enum
    // This is also used for type arguments to specify the actual type
    // And tagged unions carry the underlying union type
    _tpe: &Type
    wk: weak &Type
    packed: bool
    // Fields for struct, array of StructMember
    fields: &[StructMember]
    // Constants
    const_fields: &[StructMember]
    // Vector of TypeMember
    field_types: &Vector(TypeMember)
    // Function and Tuple
    return_t: &Vector(&Type)
    // Vector of NamedParameter
    parameter_t: &Vector(NamedParameter)
    // Enum scope
    scope: weak &scope::Scope
    // Structural types
    // Vector of StructuralTypeMember
    members: &Vector(StructuralTypeMember)
    share: parser::ShareMarker // TODO Types should not have a share, this needs to be on the value instead (and only there)
    node: weak &parser::Node
    // Type constructors save a template of a type
    tc_node: weak &parser::Node
    // Cache of specialized type constructor
    cache: &Map(TypeRef, &Type)
    // Type constructor instances have a type and arguments
    tc_tpe: weak &Type
    // Vector of Type, also used by GENERIC
    tc_args: &Vector(&Type)
    // True if some parameters weren't set yet
    tc_incomplete: bool
    // null means any for variant
    // This is used by variant, tagged union and interface impl
    variants: &Set(&Type)
    _hash: uint64
    svalue: weak &scope::Value

    // This is used by deserialization to check if a type is in the
    // type cache, so that structs can keep a wk reference to the type
    is_in_type_cache: bool
    // Set on type arguments
    is_type_argument: bool
    
    // Interface implementation
    intf: &Type
    // This gets set if it might also be a type argument, in that case we also consider the overload with a type
    // As an example, consider [int], this might be an array of types or an array type
    may_be_type: &Type
    // True if this is an anonymous struct or a lambda
    is_anon: bool
}

export def hash(tpe: &Type) -> uint64 {
    if tpe._hash { return tpe._hash }
    let name = debug::type_to_str(tpe, full_name = true)
    tpe._hash = md5::high(md5::md5(name))
    return tpe._hash
}
export def == (this: &Type, other: &Type) -> bool {
    return equals(this, other)
}
export def != (this: &Type, other: &Type) -> bool {
    return not equals(this, other)
}

def sort_by_typename(types: &Vector(&Type)) {
    let n = types.length
    let names = allocate_ref(Str, n)
    for var i in 0..types.length {
        names(i) = debug::type_to_str(types(i), full_name = true)
    }

    // bubble sort because icba // TODO Implement sorting for vectors and arrays
    for var i in 0..n {
        for var j in 0..(n - 1) {
            if names(j) > names(j + 1) {
                let t = names(j); names(j) = names(j + 1); names(j + 1) = t
                let u = types(j); types(j) = types(j + 1); types(j + 1) = u
            }
        }
    }
}

let meta = map::make(type &Type, type &TypeMeta)

export type TypeMeta = struct {
    has_constructor: int
    has_user_defined_constructor: int
    constructor: &scope::Value

    has_destructor: int
    has_builtin_destructor: int
    destructor: &scope::Value
    builtin_destructor: &scope::Value
}

export def get_meta(tpe: &Type) -> &TypeMeta {
    if not tpe { return null }
    let m = meta.get(tpe)
    if m.exists { return m.get() }
    let new_meta = [] !&TypeMeta
    meta(tpe) = new_meta
    return new_meta
}

// Returns true if there's any destructor present
export def has_destructor(tpe: &Type) -> bool {
    if not tpe { return false }
    let tm = get_meta(tpe)
    if tm.has_destructor != 0 {
        return tm.has_destructor == 1
    }
    var res = false
    if is_ref(tpe) {
        let generic = get_generic(tpe)
        if not generic { res = true }
        else { res = not generic.tc_incomplete }
    } else if tpe.kind == TypeKind::STATIC_ARRAY { 
        res = has_destructor(tpe.tpe) 
    } else if tpe.module and get_user_defined_destructor(tpe) != null {
        res = true
    } else if tpe.kind == TypeKind::STRUCT {
        for var i in 0..tpe.fields.size {
            let field = tpe.fields(i)
            if has_destructor(field.tpe) {
                res = true
                break
            }
        }
    } else if tpe.kind == TypeKind::CLOSURE {
        res = true
    } else if tpe.kind == TypeKind::TUNION {
        for var v in @tpe.variants.keys() {
            if has_destructor(v) {
                res = true
                break
            }
        }
    }

    if not consteval::is_static and tpe.kind != TypeKind::STUB {
        if res {
            tm.has_destructor = 1
        } else {
            tm.has_destructor = -1
        }
    }
    return res
}

export def get_builtin_destructor(tpe: &Type, lookup: bool = true) -> &scope::Value {
    if not tpe { return null }
    if is_polymorph(tpe) { return null }

    let tm = get_meta(tpe)
    if tm.has_builtin_destructor == -1 or tm.has_builtin_destructor == 1 and tm.builtin_destructor {
        return tm.builtin_destructor
    }

    var destructor = tm.builtin_destructor
    let args = vector::make(NamedParameter)
    args.push([ _tpe = pointer(tpe) ] !NamedParameter)
    if not tm.builtin_destructor {
        destructor = scope::generate_function(builtins::builtins, parser::make_identifier("__destruct__"), args, true)
        tm.builtin_destructor = destructor
        if lookup and consteval::is_static and destructor {
            compiler::create_destructor(destructor.tpe)
        }
    }
    if not consteval::is_static {
        if destructor {
            tm.has_builtin_destructor = 1
        } else {
            tm.has_builtin_destructor = -1
        }
    }
    return destructor
}

export def get_user_defined_destructor(tpe: &Type) -> &scope::Value {
    let tm = get_meta(tpe)
    if tm.has_destructor != 0 {
        if tm.destructor { return tm.destructor }
    }
    if tpe.module {
        let args = vector::make(NamedParameter)
        args.push([
            _tpe = pointer(tpe)
        ] !NamedParameter)
        var destructor = scope::get_function(tpe.module.scope, parser::make_identifier("destruct"), args, false, true, not consteval::is_static)
        if destructor {
            if consteval::is_static {
                destructor = consteval::compile_function(destructor, tpe.module.scope, args)
            } else {
                tm.has_destructor = 1
            }
            tm.destructor = destructor
            return destructor 
        }
    }
    return null
}

export def get_constructor(tpe: &Type, lookup: bool = true) -> &scope::Value {
    has_copy_constructor(tpe, lookup)
    let tm = get_meta(tpe)
    return tm.constructor
}

export def has_user_defined_copy_constructor(tpe: &Type) -> bool {
    if not tpe { return false }
    if tpe.kind != TypeKind::STRUCT and
        tpe.kind != TypeKind::UNION {
        return false        
    }

    let tm = get_meta(tpe)
    if tm.has_user_defined_constructor != 0 {
        return tm.has_user_defined_constructor == 1
    }

    var res = false
    if tpe.kind == TypeKind::STATIC_ARRAY { res = has_user_defined_copy_constructor(tpe.tpe) }
    else if tpe.module {
        let args = vector::make(NamedParameter)
        args.push([ _tpe = pointer(tpe)] !NamedParameter)
        args.push([ _tpe = pointer(tpe)] !NamedParameter)

        var module = tpe.module
        if tpe.tc_tpe { module = tpe.tc_tpe.module }
        var constructor = scope::get_function(module.scope, parser::make_identifier("construct"), args, false, not consteval::is_static)
        if constructor {
            if consteval::is_static {
                constructor = consteval::compile_function(constructor, module.scope, args)
            }
            tm.constructor = constructor
            res = true 
        }
    }
    if not consteval::is_static {
        if res { tm.has_user_defined_constructor = 1 }
        else { tm.has_user_defined_constructor = -1 }
    }
    return res
}

export def get_builtin_constructor(tpe: &Type) -> &scope::Value {
    if not tpe { return null }
    if is_polymorph(tpe) { return null }

    let tm = get_meta(tpe)
    if tm.has_constructor == -1 or tm.has_constructor == 1 and tm.constructor {
        return tm.constructor
    }

    let args = vector::make(NamedParameter)
    vector::push(args, [ _tpe = pointer(tpe) ] !NamedParameter)
    vector::push(args, [ _tpe = pointer(tpe) ] !NamedParameter)
    tm.constructor = scope::generate_function(builtins::builtins, parser::make_identifier("__construct__"), args, dry_run = true)
    if consteval::is_static and tm.constructor {
        compiler::create_constructor(tm.constructor.tpe)
    }
    if not consteval::is_static {
        if tm.constructor {
            tm.has_constructor = 1
        } else {
            tm.has_constructor = -1
        }
    }
    return tm.constructor
}

// Returns true if there's any copy constructor
// TODO Write a separate function for checking without generating
export def has_copy_constructor(tpe: &Type, lookup: bool = true) -> bool {
    if not tpe { return false }
    if tpe.kind != TypeKind::STRUCT and 
        tpe.kind != TypeKind::UNION and
        tpe.kind != TypeKind::STATIC_ARRAY and 
        tpe.kind != TypeKind::CLOSURE and
        tpe.kind != TypeKind::TUNION { 
        return false 
    }

    let tm = get_meta(tpe)
    if tm.has_constructor != 0 {
        if tm.has_constructor == 1 and tm.constructor {
            return true
        } else if tm.has_constructor == -1 {
            return false
        }
    } 

    var res = false
    if has_user_defined_copy_constructor(tpe) { res = true }
    else if tpe.kind == TypeKind::STRUCT {
        for var i in 0..tpe.fields.size {
            let field = tpe.fields(i)
            if has_copy_constructor(field.tpe) or is_ref(field.tpe) {  
                res = true
                break
            }
        }
    } else if tpe.kind == TypeKind::CLOSURE {
        res = true
    } else if tpe.kind == TypeKind::STATIC_ARRAY {
        while tpe != null and tpe.kind == TypeKind::STATIC_ARRAY {
            tpe = tpe.tpe
        }
        if has_copy_constructor(tpe) or is_ref(tpe) { 
            res = true
        }
    } else if tpe.kind == TypeKind::TUNION {
        for var variant in @tpe.variants.keys() {
            if has_copy_constructor(variant) or is_ref(variant) {  
                res = true
                break
            }
        }
    }

    if not tm.constructor and lookup {
        let args = vector::make(NamedParameter)
        vector::push(args, [ _tpe = pointer(tpe) ] !NamedParameter)
        vector::push(args, [ _tpe = pointer(tpe) ] !NamedParameter)
        tm.constructor = scope::generate_function(builtins::builtins, parser::make_identifier("__construct__"), args, dry_run = true)
        if consteval::is_static and tm.constructor {
            compiler::create_constructor(tm.constructor.tpe)
        }
    }

    if not consteval::is_static {
        if res {
            tm.has_constructor = 1
        } else {
            tm.has_constructor = -1
        }
    }

    return res
}

export def defmodule(tpe: &Type) -> weak &toolchain::Module {
    if not tpe { return null }
    if tpe._defmodule { return tpe._defmodule }
    return tpe.module
}

export def tpe(tpe: &Type) -> &Type {
    if not tpe { return null }
    if tpe._tpe and tpe._tpe.kind == TypeKind::BOX {
        return tpe._tpe.wk
    }
    return tpe._tpe
}

export def get_module(tpe: &Type) -> &toolchain::Module {
    if not tpe { return null }
    if is_box(tpe) { return get_module(tpe.tpe) }
    return tpe.module
}

export def box(tpe: &Type) -> &Type {
    if not tpe { return null }
    let box = make_type_raw(TypeKind::BOX)
    box.wk = tpe
    return box
}

export type NamedParameter = struct {
    // Might be empty for positional parameters
    name: Str
    _tpe: &Type
    varargs: bool
    node: weak &parser::Node
    value: &compiler::Value
    kw: parser::VarDecl
    type_node: weak &parser::Node
}

export def tpe(np: NamedParameter) -> &Type {
    if not np._tpe { return null }
    if np._tpe.kind == TypeKind::BOX {
        return np._tpe.wk
    }
    return np._tpe
}

export type State = struct {
    module: weak &toolchain::Module
    scope: weak &scope::Scope
    // Vector of Type
    function_stack: &Vector(&compiler::Function)
    in_defer: bool
    // If this is set to true, consteval doesn't perform the walk_top
    shallow_walk: bool
    current_variable: &scope::Value
    // TODO This should be a parameter but its currently too hard to fix
    block_implicit_conv: bool
    current_lambda: &Type
    context: &scope::Scope
}

export def get_context(state: &State) -> &toolchain::Module {
    if state.context { return state.context.module }
    return state.module
}

// This needs to be global state
var lambda_counter = 0
var counter = 0

def current_value(state: &State) -> &scope::Value {
    if state.current_variable {
        return state.current_variable
    }
    
    let len = vector::length(state.function_stack)
    for var i in 0..len {
        let j = state.function_stack.length - i - 1
        let fun = state.function_stack(j)
        if j > 0 {
            let parent = state.function_stack(j - 1)
            if parent.is_global {
                return fun.value
            }
        }
        if fun.is_global { 
            return fun.value
        }
    }
    return null
}

export def current_function(state: &State) -> &compiler::Function {
    let length = vector::length((@state).function_stack)
    if length == 0 {
        return null
    } else {
        return (@state).function_stack(length - 1)
    }
}

export def push_function(state: &State, function: &compiler::Function) {
    (@state).function_stack.push(function)
}

export def pop_function(state: &State) -> &compiler::Function {
    return vector::pop((@state).function_stack)
}

export def is_function(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FUNCTION
}

export def is_function_pointer(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER and 
        is_function((@tpe).tpe)
}

export def is_integer(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::WORD or 
        (@tpe).kind == TypeKind::BOOL or 
        tpe.kind == TypeKind::ENUM or
        tpe.kind == TypeKind::CHAR
}

export def is_arithmetic(tpe: &Type) -> bool {
    if not tpe { return false }
    return is_integer(tpe) or 
        (@tpe).kind == TypeKind::FLOAT
}

export def is_float(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::FLOAT
}

// TODO Also allow arrays and strings
export def is_boolean(tpe: &Type, module: &Module) -> bool {
    if not tpe { return false }
    if (@tpe).kind == TypeKind::BOOL or
        (@tpe).kind == TypeKind::WORD or
        (@tpe).kind == TypeKind::FLOAT or
        (@tpe).kind == TypeKind::POINTER or
        (@tpe).kind == TypeKind::BYREF or
        (@tpe).kind == TypeKind::REFERENCE or
        (@tpe).kind == TypeKind::WEAK_REF or
        tpe.kind == TypeKind::CHAR or
        tpe.kind == TypeKind::CLOSURE {
        return true
    }
    return is_assignable(builtins::bool_, tpe, module)
}

export def is_pointer(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::POINTER or 
        tpe.kind == TypeKind::BYREF
}

export def is_ref(tpe: &Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::REFERENCE
}


export def is_weak_ref(tpe: &Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::WEAK_REF
}

export def is_ref_or_weak(tpe: &Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::WEAK_REF or
        tpe.kind == TypeKind::REFERENCE
}

export def is_box(tpe: &Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::POINTER or
        tpe.kind == TypeKind::BYREF or
        tpe.kind == TypeKind::REFERENCE or
        tpe.kind == TypeKind::WEAK_REF or
        tpe.kind == TypeKind::STATIC_ARRAY or
        tpe.kind == TypeKind::ARRAY
}

export def unbox(tpe: &Type) -> &Type {
    if not tpe { return null }
    if tpe.kind == TypeKind::BOX {
        return tpe.wk
    }
    return tpe
}

export def is_struct(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::STRUCT or
        (@tpe).kind == TypeKind::UNION
}

export def is_enum(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ENUM
}

export def is_type(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::TYPE
}

export def is_array(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::ARRAY or
        (@tpe).kind == TypeKind::STATIC_ARRAY
}

export def is_range(tpe: &Type) -> bool {
    if not tpe { return false }
    return (@tpe).kind == TypeKind::RANGE or
        (@tpe).kind == TypeKind::RANGE_INC
}

export def is_stub(tpe: &Type) -> bool {
    if not tpe { return true }
    return tpe.kind == TypeKind::STUB
}

// TODO Actually go inside of function types, etc
def is_stub_rec(tpe: &Type) -> bool {
    if not tpe { return false }
    if is_box(tpe) {
        return is_stub_rec(tpe.tpe)
    }
    return tpe.kind == TypeKind::STUB
}

export def is_interface(tpe: &Type) -> bool {
    if not tpe { return false }
    return tpe.kind == TypeKind::STRUCTURAL
}

export def get_interface(tpe: &Type) -> &Type {
    if not tpe { return null }
    if is_array(tpe) or is_ref(tpe) or is_pointer(tpe) {
        return get_interface(tpe.tpe)
    }
    if tpe.kind == TypeKind::STRUCTURAL {
        return tpe
    }
    return null
}

export def append_module(name: Str, module: Str) -> Str {
    var res: StringBuffer = ""
    if module {
        res += module + "::"
    }
    res += name
    return res
}

export def make_type_type(tpe: &Type) -> &Type {
    return [
        line = -1,
        kind = TypeKind::TYPE,
        _tpe = tpe
    ] !Type
}

export def make_type_raw(kind: TypeKind) -> &Type {
    return [
        line = -1,
        kind = kind
    ] !Type
}

export def make_type(kind: TypeKind, node: &parser::Node) -> &Type {
    assert(node.kind == parser::NodeKind::IDENTIFIER)
    let name = parser::identifier_to_str(node)
    var t = make_type_raw(kind)
    t.line = node.loc.line
    t.type_name = append_module(name, node.loc.module)
    t.name = name

    return t
}

export def make_function_type() -> &Type {
    let tpe = make_type_raw(TypeKind::FUNCTION)
    tpe.size = size_of type def [] -> []
    tpe.align = align_of type def [] -> []
    return tpe
}

export def make_closure_type() -> &Type, &Type {
    let fun = make_function_type()
    fun.parameter_t = vector::make(NamedParameter)
    fun.parameter_t.push([ name = "__data", _tpe = reference(null) ] !NamedParameter)
    fun.return_t = vector::make(type &Type)

    let types = allocate_ref(StructMember, 2)
    types(0) = [ tpe = pointer(fun), name = "function" ] !StructMember
    types(1) = [ tpe = reference(null), name = "data"] !StructMember
    let tpe = make_struct_type(types)
    tpe.kind = TypeKind::CLOSURE
    return tpe, fun
}

export def make_function_type_n(
    name: &parser::Node, 
    parameter_t: &Vector(NamedParameter), 
    return_t: &Vector(&Type), 
    module: &toolchain::Module = null,
    extern: bool = false,
    test: bool = false,
    context: &toolchain::Module = null
) -> &Type {

    let tpe = make_function_type()
    tpe.parameter_t = parameter_t
    tpe.return_t = return_t
    tpe.name = parser::identifier_to_str(name, false)
    if extern {
        tpe.type_name = tpe.name
    } else {
        let name = append_module(tpe.name, module.module) if module else tpe.name
        tpe.type_name = mangle_function_name(name, parameter_t, test, context)
    }
    tpe.line = name.loc.line
    tpe.module = module
    tpe.context = context
    return tpe
}

export def pointer(tpe: &Type, kw: parser::VarDecl) -> &Type {
    var t = make_type_raw(TypeKind::POINTER)
    t._tpe = tpe
    t.kw = kw
    t.size = (size_of type *)
    t.align = (align_of type *)
    return t
}

// TODO Use default arguments for this, right now its bugged (it doesn't define the type)
export def pointer(tpe: &Type) -> &Type {
    return pointer(tpe, parser::VarDecl::VAR)
}

export def byref(tpe: &Type) -> &Type {
    var t = make_type_raw(TypeKind::BYREF)
    t._tpe = tpe
    t.size = (size_of *)
    t.align = (align_of *)
    return t
}

export def reference(tpe: &Type, kw: parser::VarDecl) -> &Type {
    var t = make_type_raw(TypeKind::REFERENCE)
    t._tpe = tpe
    t.kw = kw
    // TODO replace with correct size_of once this is implemented
    t.size = (size_of runtime::Ref)
    t.align = (align_of runtime::Ref)
    return t
}

export def reference(tpe: &Type) -> &Type {
    return reference(tpe, parser::VarDecl::VAR)
}

export def weak_reference(tpe: &Type, kw: parser::VarDecl) -> &Type {
    var t = make_type_raw(TypeKind::WEAK_REF)
    t._tpe = tpe
    t.kw = kw
    t.size = (size_of runtime::Ref)
    t.align = (align_of runtime::Ref)
    return t
}

export def weak_reference(tpe: &Type) -> &Type {
    return weak_reference(tpe, parser::VarDecl::VAR)
}

export def array(tpe: &Type, kw: parser::VarDecl) -> &Type {
    var t = make_type_raw(TypeKind::ARRAY)
    (@t)._tpe = tpe
    // TODO This is really bad, sure string is an array but we can do better than this
    (@t).size = (size_of string)
    (@t).align = (align_of string)
    (@t).kw = kw
    return t
}

export def array(tpe: &Type) -> &Type {
    return array(tpe, parser::VarDecl::VAR)
}

export def make_static_array(array_tpe: &Type, size: size_t, kw: parser::VarDecl) -> &Type {
    let tpe = make_type_raw(TypeKind::STATIC_ARRAY)
    (@tpe)._tpe = array_tpe
    (@tpe).length = size
    (@tpe).size = (@tpe).length * (@array_tpe).size
    (@tpe).align = (@array_tpe).align
    (@tpe).kw = kw
    return tpe
}

export def make_static_array(array_tpe: &Type, size: size_t) -> &Type {
    return make_static_array(array_tpe, size, parser::VarDecl::VAR)
}

def make_unique_name(name: Str, state: &State) -> Str {
    let cnt = counter
    counter += 1
    return state.module.module + "::" + name + '.' + cnt
}

// Map of type names to identify which ones
// implement structural types
// Map of TypeEntry
export let types_map = map::make(type &TypeEntry)

// The repl needs to invalidate the cache
export def clear_type_cache {
    let keys = map::keys(types_map)
    for var i in 0..keys.size {
        let key = keys(i)
        let type_entry = types_map(key)
        map::clear(type_entry.cached)
    }
}

export def iterate_member_functions(tpe: &Type, visited: &Set(&Type) = null, check_embed: bool = true) -> TypeEntryMember {
    if not tpe { return }
    let name = debug::type_to_str(tpe, full_name = true)
    
    let entry = types_map.get_or_default(name, null)
    if entry {
        for var i in 0..entry.functions.length {
            yield entry.functions(i)
        }
        if check_embed and entry.tpe and is_struct(entry.tpe) {
            for var field in @entry.tpe.fields {
                if field.is_embed {
                    yield from iterate_member_functions(field.tpe, visited)
                }
            }
        }
    }

    let module = get_module(tpe)
    if module {
        for var key in @types_map.keys() {
            let entry = types_map(key)

            if entry.tpe == tpe { continue }
            if not visited { visited = set::make(type &Type) }

            if is_ref_or_weak(entry.tpe) and is_interface(entry.tpe.tpe) {
                if visited.contains(entry.tpe.tpe) { continue }
                visited.add(entry.tpe.tpe)
            } else {
                if visited.contains(entry.tpe) { continue }
                visited.add(entry.tpe)
            }

            if is_interface(entry.tpe) and implements(tpe, entry.tpe, module, visited) or 
                is_ref_or_weak(entry.tpe) and is_interface(entry.tpe.tpe) and 
                    implements(tpe, entry.tpe.tpe, module, visited) {

                for var i in 0..entry.functions.length {
                    yield entry.functions(i)
                }
            }
        }
    }

    let initial = tpe
    let cpy = copy(tpe)
    tpe = cpy
    var prev: &Type = cpy
    while is_box(tpe) {
        prev = tpe
        tpe = tpe.tpe
    }
    
    if tpe and tpe.kind != typechecking::TypeKind::TYPE {
        @tpe = @make_type_raw(TypeKind::TYPE)
    } else if is_box(prev) {
        @prev = @make_type_raw(TypeKind::TYPE)
    } else {
        return
    }

    for var entry in iterate_member_functions(cpy) {
        yield entry
    }
}

def do_get_member_functions(name: Str, vec: &Vector(TypeEntryMember)) {
    let type_entry = types_map.get_or_default(name, null)
    if not type_entry { return }
    if type_entry.functions {
        vector::insert(vec, 0, type_entry.functions)
    }
}

export def get_member_functions(tpe: &Type) -> &Vector(TypeEntryMember) {
    if not tpe { return vector::make(TypeEntryMember) }

    tpe = copy(tpe)
    var tpe2 = get_generic(tpe)
    if tpe2 {
        let vec = vector::make(TypeEntryMember)
        let name = debug::type_to_str(tpe, full_name = true)
        do_get_member_functions(name, vec)

        let tc_args = vector::copy(tpe2.tc_args)
        let len = vector::length(tpe2.tc_args)

        // TODO The complexity of this increases rapidly
        for var i in 0..len {
            tpe2.tc_args = vector::copy(tc_args)
            for var j in i..len {
                let type_def = make_type_raw(TypeKind::TYPE_DEF)
                tpe2.tc_args(i) = type_def
                tpe2.tc_incomplete = true
                let name = debug::type_to_str(tpe, full_name = true)
                do_get_member_functions(name, vec)
            }
        }
        return vec
    } else {
        let vec = vector::make(TypeEntryMember)
        for var member in iterate_member_functions(tpe) {
            vec.push(member)
        }
        return vec
    }
}

type CacheEntry = enum {
    CONTAINS
    NOT_CONTAINS
}

export type TypeEntry = struct {
    tpe: &Type
    // Vector of TypeEntryMember
    functions: &Vector(TypeEntryMember)
    cached: &SMap(CacheEntry)
}

export type TypeEntryMember = struct {
    function: &Type
    exported: bool
    module: weak &toolchain::Module
}
 
export def create_type_entry(tpe: &Type) -> &TypeEntry {
    //if is_polymorph(tpe) { return null }
    let name = debug::type_to_str(tpe, full_name = true)
    var type_entry = types_map.get_or_default(name, null)
    if not type_entry {
        type_entry = [
            tpe = tpe,
            functions = vector::make(TypeEntryMember),
            cached = map::make(CacheEntry)
        ] !&TypeEntry
        types_map(name) = type_entry
    }
    return type_entry
}

export def create_type_entry(tpe: &Type, exported: bool, entry: &Type, module: &toolchain::Module, overwrite: bool = false) -> bool {
    let type_entry = create_type_entry(tpe)
    if not type_entry { return false }

    let member_function = [
        function = shallow_copy(entry),
        exported = exported,
        module = module
    ] !TypeEntryMember

    // TODO Use a set for this
    for var i in 0..vector::length(type_entry.functions) {
        let fun = type_entry.functions(i)
        if fun.function.type_name == entry.type_name {
            if overwrite { type_entry.functions(i) = member_function }
            return false 
        }
    }

    type_entry.functions.push(member_function)
    return true
}

// TODO Remove this
export def copy_parameter_t(parameter_t: &Vector(NamedParameter)) -> &Vector(NamedParameter) {
    let new = vector::make(NamedParameter)
    for var i in 0..vector::length(parameter_t) {
        let np = parameter_t(i)
        np._tpe = copy(np.tpe)
        new.push(np)
    }
    return new
}

// TODO Remove this
export def copy_return_t(return_t: &Vector(&Type)) -> &Vector(&Type) {
    let new = vector::make(type &Type)
    for var i in 0..vector::length(return_t) {
        vector::push(new, copy(return_t(i)))
    }
    return new
}

def copy_types(a: &Vector(&Type)) -> &Vector(&Type) {
    let res = vector::make(type &Type)
    for var i in 0..vector::length(a) {
        let arg = a(i)
        res.push(copy(arg))
    }
    return res
}

// TODO Not a deep copy
export def copy(a: &Type) -> &Type {
    if not a { return null }
    var t: &Type = @a
    t._hash = 0

    if a.tc_args {
        t.tc_args = copy_types(a.tc_args)
    }

    if a.kind == TypeKind::FUNCTION {
        t.return_t = copy_return_t(a.return_t)
        t.parameter_t = copy_parameter_t(a.parameter_t)
    } else if is_box(a) or
        a.kind == TypeKind::TYPE_DEF or
        a.kind == TypeKind::TYPE {
        if a._tpe and a._tpe.kind == TypeKind::BOX {
            t._tpe = copy(a._tpe.wk) // Unbox for copy
        } else {
            t._tpe = copy(a._tpe)
        }
    }

    return t
}

export def shallow_copy(tpe: &Type) -> &Type {
    let ret: &Type = @tpe
    ret._hash = 0
    if tpe.kind == TypeKind::FUNCTION {
        ret.return_t = vector::copy(tpe.return_t)
        ret.parameter_t = vector::copy(tpe.parameter_t)
    }
    return ret
}

export def equals(a: &Type, b: &Type) -> bool {
    if a !* == b !* {
        return true
    }
    if not a or not b { return false }
    if a.kind == TypeKind::BOX {
        a = a.wk
    }
    if b.kind == TypeKind::BOX {
        b = b.wk
    }

    if a.kind != TypeKind::TYPE and a._hash and b._hash {
        // Speed up equality if hashes are defined
        return a._hash == b._hash
    }

    if a.kind == TypeKind::STUB or b.kind == TypeKind::STUB {
        return a.type_name == b.type_name
    }

    if a.tc_args and b.tc_args and a.tc_tpe and b.tc_tpe and equals(a.tc_tpe, b.tc_tpe) {
        for var i in 0..vector::length(a.tc_args) {
            let x = a.tc_args(i)
            let y = b.tc_args(i)
            if not equals(x, y) { return false }
        }
        return true
    }

    if a.kind == TypeKind::VARIANT or b.kind == TypeKind::VARIANT and a.kind != b.kind {
        if b.kind == TypeKind::VARIANT {
            let c = a; a = b; b = c;
        }
        if not a.variants { return true }
        if a.variants.contains(b) { return true }
        return false
    }

    if (@a).kind != (@b).kind { return false }

    let kind = (@a).kind    
    if kind == TypeKind::RANGE or 
        kind == TypeKind::RANGE_INC or 
        kind == TypeKind::VOID or 
        kind == TypeKind::NULL or 
        kind == TypeKind::BOOL or 
        kind == TypeKind::CHAR { 
            
        return true 
    }
    if kind == TypeKind::WORD {
        return (@a).size == (@b).size and (@a).unsig == (@b).unsig
    }
    if kind == TypeKind::FLOAT {
        return (@a).size == (@b).size
    }
    if kind == TypeKind::ENUM or
        kind == TypeKind::STRUCT or
        kind == TypeKind::UNION or
        kind == TypeKind::STUB or
        kind == TypeKind::STRUCTURAL or
        kind == TypeKind::TYPE_CONSTRUCTOR {
        
        return a.hash == b.hash
    }
    if kind == TypeKind::ARRAY or
        kind == TypeKind::POINTER or
        kind == TypeKind::BYREF or
        kind == TypeKind::REFERENCE or
        kind == TypeKind::WEAK_REF {
        
        return equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::STATIC_ARRAY {
        return (@a).length == (@b).length and equals((@a).tpe, (@b).tpe)
    }
    if kind == TypeKind::FUNCTION or kind == TypeKind::TUPLE or kind == TypeKind::CLOSURE {
        if a.parameter_t != b.parameter_t {
            if vector::length((@a).parameter_t) != vector::length((@b).parameter_t) {
                return false        
            }
            for var i in 0..vector::length((@a).parameter_t) {
                let param_a = (@a).parameter_t(i)
                let param_b = (@b).parameter_t(i)
                if not equals(param_a.tpe, param_b.tpe) {
                    return false
                }
            }
        }
        if kind == TypeKind::FUNCTION or kind == TypeKind::CLOSURE {
            if vector::length((@a).return_t) != vector::length((@b).return_t) {
                return false
            }
            for var i in 0..vector::length((@a).return_t) {
                if not equals(a.return_t(i), b.return_t(i)) {
                    return false
                }
            }
        }
        return true
    }
    if kind == TypeKind::TYPE_DEF or kind == TypeKind::TYPE {
        return equals(a.tpe, b.tpe)
    }
    if kind == TypeKind::GENERIC {
        if equals(a.tpe, b.tpe) {
            if vector::length(a.tc_args) != vector::length(b.tc_args) { return false }
            for var i in 0..vector::length(a.tc_args) {
                let arg_a = a.tc_args(i)
                let arg_b = b.tc_args(i)
                if not equals(arg_a, arg_b) { return false }
            }
            return true
        }
        return false
    }
    if kind == TypeKind::NAMESPACE {
        return a !* == b !*
    }
    if kind == TypeKind::TUNION {
        return a.variants == b.variants
    }

    assert
}

def is_setter(mb: StructuralTypeMember) -> bool {
    return mb.name.starts_with("__set_") and mb.name.ends_with("__")
}

def is_getter(mb: StructuralTypeMember) -> bool {
    return mb.parameter_t.length == 0
}

def has_function(entry: &TypeEntry, intf: &Type, mb: StructuralTypeMember, module: &toolchain::Module, visited: &Set(&Type) = null, check_embed: bool = true) -> bool {
    var tpe = entry.tpe

    if tpe.kind == typechecking::TypeKind::STRUCT {
        implements(reference(tpe), intf, module)
    }
    if tpe.kind == typechecking::TypeKind::REFERENCE or tpe.kind == typechecking::TypeKind::WEAK_REF or
        is_pointer(tpe) {
        tpe = tpe.tpe
    }

    if tpe and tpe.kind == typechecking::TypeKind::STRUCT {
        let fields = flatten_fields(tpe)
        if is_setter(mb) {
            let name = mb.name.slice(6, mb.name.length() - 2)
            for var field in fields {
                if field.name == name and equals(mb.parameter_t(0).tpe, field.tpe) { return true }
            }
        } else if is_getter(mb) {
            for var field in fields {
                if field.name == mb.name and equals(mb.return_t(0), field.tpe) { return true }
            }
            if tpe.const_fields {
                for var field in @tpe.const_fields {
                    if field.name == mb.name and equals(mb.return_t(0), field.tpe) { return true }
                }
            }
        }
    }

    for var member in iterate_member_functions(entry.tpe, visited, check_embed) {
        let function = member.function
        if function.name != mb.name { continue }
        if module != member.module and not member.exported { continue }

        var parameter_t = copy_parameter_t(function.parameter_t)
        var return_t = copy_return_t(function.return_t)

        var member_params = vector::make(NamedParameter)
        member_params.push([ _tpe = entry.tpe ] !NamedParameter)
        member_params.insert(1, mb.parameter_t)

        replace_type_defs(parameter_t, return_t, member_params, null, module, true)

        if vector::length(parameter_t) != vector::length(mb.parameter_t) + 1 { continue }
        var mismatch = false
        for var k in 0..vector::length(mb.parameter_t) {
            let npa = parameter_t(k + 1).tpe
            let npb = mb.parameter_t(k).tpe
            if not equals(npa, npb) {
                mismatch = true
                break
            }
        }
        if mismatch { continue }

        if vector::length(return_t) != vector::length(mb.return_t) { continue }
        for var k in 0..vector::length(mb.return_t) {
            let ta = return_t(k)
            var tb = mb.return_t(k)
            if tb.kind == TypeKind::BOX {
                tb = tb.wk
            }
            if not equals(ta, tb) {
                mismatch = true
                break
            }
        }
        if mismatch { continue }
        return true
    }
    return false
}

// Returns true if a implements b
// b needs to be a structural type
export def implements(a: &Type, b: &Type, module: &toolchain::Module, visited: &Set(&Type) = null, check_embed: bool = true) -> bool {
    if not a or not b { return false }
    assert b.kind == TypeKind::STRUCTURAL
    if a.kind == typechecking::TypeKind::REFERENCE and equals(b, a.tpe) {
        return true
    }

    var type_entry = create_type_entry(a)
    if not type_entry { return false }
    let nameb = debug::type_to_str(b, full_name = true)
    if type_entry.cached.contains(nameb) and check_embed {
        return type_entry.cached(nameb) == CacheEntry::CONTAINS
    }

    if a.kind == TypeKind::STRUCTURAL {
        for var i in 0..vector::length(b.members) {
            let mb = b.members(i)

            var found = false
            for var j in 0..vector::length(a.members) {
                let ma = a.members(j)
                if ma.name != mb.name { continue }
                if vector::length(ma.parameter_t) != vector::length(mb.parameter_t) { continue }

                var mismatch = false
                for var k in 0..vector::length(ma.parameter_t) {
                    let npa = ma.parameter_t(k).tpe
                    let npb = mb.parameter_t(k).tpe
                    if not equals(npa, npb) {
                        mismatch = true
                        break
                    }
                }
                if mismatch { continue }

                if vector::length(ma.return_t) != vector::length(mb.return_t) { continue }
                
                for var k in 0..vector::length(ma.return_t) {
                    var ta = ma.return_t(k)
                    if ta.kind == TypeKind::BOX { ta = ta.wk }
                    var tb = mb.return_t(k)
                    if tb.kind == TypeKind::BOX { ta = tb.wk }
                    if not equals(ta, tb) {
                        mismatch = true
                        break
                    }
                }
                if mismatch { continue }
            
                found = true
            }
            if not found {
                found = has_function(type_entry, b, mb, module, visited.copy(), check_embed)
            }
            if not found { 
                type_entry.cached(nameb) = CacheEntry::NOT_CONTAINS
                return false 
            }
        }
        type_entry.cached(nameb) = CacheEntry::CONTAINS
        return true
    } else {
        for var i in 0..vector::length(b.members) {
            let mb = b.members(i)

            if not has_function(type_entry, b, mb, module, visited.copy(), check_embed) {
                type_entry.cached(nameb) = CacheEntry::NOT_CONTAINS
                return false
            }
        }
        type_entry.cached(nameb) = CacheEntry::CONTAINS
        return true
    }
}

// Returns true if b is assignable to a
export def is_assignable(a: &Type, b: &Type, module: &toolchain::Module) -> bool {
    return convert_type_score(a, b, module) >= 0
}

// TODO This needs caching
def infer_interface_types(a: &Type, b: &Type, module: &toolchain::Module) -> &Type {
    assert a.kind == TypeKind::GENERIC
    // TODO We might want to pass a state instead
    if a.tpe.kind != TypeKind::STRUCTURAL { return null }
    let node = a.tpe.node
    if not node or node.kind != parser::NodeKind::STRUCTURAL_T {
        return null
    }

    let state = module.state

    let variants = map::make(type &Type)
    state.scope = scope::enter_scope(state.scope)
    for var i in 0..vector::length(a.tpe.parameter_t) {
        let par = a.tpe.parameter_t(i)
        let variant_tpe = make_type_raw(TypeKind::VARIANT)
        variant_tpe.name = par.name
        variants(variant_tpe.name) = variant_tpe
        scope::create_type(state.scope, parser::make_identifier(par.name), parser::ShareMarker::NONE, variant_tpe)
    }

    var found_all = true
    for var i in 0..vector::length(node.value.body) {
        let member = node.value.body(i)
        let function = make_function_type()
        function.parameter_t = vector::make(NamedParameter)
        function.return_t = vector::make(type &Type)
        function.type_name = function.name = parser::identifier_to_str(member.value.structural_member.name)
 
        function.parameter_t.push([ _tpe = b ] !NamedParameter)

        for var j in 0..vector::length(member.value.structural_member.params) {
            let param = member.value.structural_member.params(j)
            function.parameter_t.push([
                name = parser::identifier_to_str(param.value.param.name),
                _tpe = type_lookup(param.value.param.tpe, state)
            ] !NamedParameter)
        }
        for var j in 0..vector::length(member.value.structural_member.returns) {
            let ret = member.value.structural_member.returns(j)
            let tpe = type_lookup(ret, state)
            function.return_t.push(tpe)
        }

        let functions, result = scope::find_functions(state.scope, member.value.structural_member.name, function)
        if vector::length(functions) == 0 {
            return null
        }
        let keys = map::keys(result)
        for var i in 0..keys.size {
            let key = keys(i)
            let variant_tpe = variants(key)
            let variants2 = set::make(result(key))
            if variant_tpe.variants {
                let new_variants = set::make(type &Type)
                for var a in @variant_tpe.variants.keys() {
                    var contains_both = false
                    for var b in @variants2.keys() {
                        if equals(a, b) {
                            contains_both = true
                            break
                        }
                    }
                    if contains_both {
                        new_variants.add(a)
                    }
                }
                if new_variants.size == 0 {
                    return null
                } else {
                    variant_tpe.variants = new_variants
                }
            } else {
                variant_tpe.variants = variants2
            }
        }
    }

    if found_all {
        let keys = map::keys(variants) 
        for var i in 0..keys.size {
            let key = keys(i)
            let variant = variants(key)
            if not variant.variants or variant.variants.size > 1  {
                return null
            }
        }
    }

    let tpe = copy(b)
    tpe.tc_args = vector::make(type &Type)
    let keys = map::keys(variants)
    for var i in 0..keys.size {
        let key = keys(i)
        let variant = variants(key)
        vector::push(tpe.tc_args, variant.variants.keys()(0))
    }

    return tpe
}

const IMPLICIT = 15

// TODO This isn't very reliable. Especially when returning bigger numbers than 1, integer conversions can interfere with to reference
// Tries to convert type b to type a
// The return value is -1 if b can't be converted to a
// if the types are equal, 0 is returned.
// Otherwise a positive integer is returned.
export def convert_type_score(a: &Type, b: &Type, module: &toolchain::Module, is_type: bool = false, impl: bool = true) -> int {
    if not a or not b { return 0 }
    if a.kind == TypeKind::BOX {
        a = a.wk
    }
    if b.kind == TypeKind::BOX {
        b = b.wk
    }

    if equals(a, b) {
        return 0
    }

    // If both are either refs or pointers
    if is_pointer(a) and is_pointer(b) and equals(a.tpe, b.tpe) {
        return 2
    }

    // Convert anonymous struct to value
    if a.kind == b.kind and b.kind == TypeKind::STRUCT and b.is_anon {
        if a.fields.size != b.fields.size { return -1 }
        for var af in @a.fields {
            var found = false
            for var bf in @b.fields {
                if equals(af.tpe, bf.tpe) and af.name == bf.name {
                    found = true
                    break
                }
            }
            if not found { return -1 }
        }
        return 11
    }

    if a.kind == TypeKind::UNDEF or b.kind == TypeKind::UNDEF { return 0 }

    if (a.kind == TypeKind::REFERENCE or a.kind == TypeKind::WEAK_REF) and 
        (b.kind == TypeKind::REFERENCE or b.kind == TypeKind::WEAK_REF) and 
        (equals(a.tpe, b.tpe) or not a.tpe) {

        return 0 if a.kind == b.kind else 3
    }
    if a.kind == TypeKind::TUNION {
        if b.kind == TypeKind::TUNION {
            for var v in @b.variants.keys() {
                if not a.variants.contains(v) { return -1 }
            }
            return 2
        } else if a.variants.contains(b) {
            return 3
        }
    }

    // Embedded structs
    if b.kind == TypeKind::STRUCT or (is_ref(b) and b.tpe and b.tpe.kind == TypeKind::STRUCT) {
        var nb = b.tpe if is_ref(b) else b
        for var field in @nb.fields {
            if field.is_embed {
                if equals(field.tpe, a) {
                    return 7
                } else if is_ref(a) and equals(field.tpe, a.tpe) {
                    return 8
                }
            }
        }
    }

    // We need to check if they are actually compatible elsewhere
    if a.kind == TypeKind::TYPE_DEF {
        return convert_type_score(a.tpe, b, module, true)
    }
    if a.kind == TypeKind::TYPE and (equals(b, pointer(builtins::Type_)) or b.may_be_type) { 
        return 4
    }
    if (is_pointer(a) or a.kind == TypeKind::REFERENCE or a.kind == TypeKind::WEAK_REF) and (@b).kind == TypeKind::NULL {
        return 0
    }
    if a.kind == TypeKind::REFERENCE and equals(a.tpe, b) {
        return 5
    }
    if a.kind == TypeKind::REFERENCE and (a.tpe == null or equals(b, builtins::Ref_)) {
        return 6
    }
    if a.kind == TypeKind::REFERENCE and a.tpe and a.tpe.kind == TypeKind::ARRAY and b.kind == TypeKind::STATIC_ARRAY and equals(a.tpe.tpe, b.tpe) {
        return 6
    }
    if equals(a, builtins::Ref_) and b.kind == TypeKind::REFERENCE {
        return 6
    }
    if ((@a).kind == TypeKind::WORD or a.kind == TypeKind::CHAR) and 
        ((@b).kind == TypeKind::WORD or b.kind == TypeKind::CHAR) and
        (@a).size >= (@b).size {
        
        // TODO if we are ever going to allow a 24 bit value this is going to fail
        return log2((@a).size) !int - log2((@b).size) !int + 3
    }
    if (@a).kind == TypeKind::FLOAT and (@b).kind == TypeKind::FLOAT {
        // TODO This works because there are only two float sizes
        return 4
    }
    if (@a).kind == TypeKind::FLOAT and
        ((@b).kind == TypeKind::WORD or b.kind == TypeKind::CHAR) {
        return 10
    }
    if (is_pointer(a) and is_pointer(b) or
        (@a).kind == TypeKind::REFERENCE and (@b).kind == TypeKind::REFERENCE) and
        (@a).tpe == null {
        
        return 4
    }
    if a.kind == TypeKind::POINTER and b.kind == TypeKind::POINTER or
        a.kind == TypeKind::BYREF and b.kind == TypeKind::BYREF or
        a.kind == TypeKind::REFERENCE and b.kind == TypeKind::REFERENCE or
        a.kind == TypeKind::WEAK_REF and b.kind == TypeKind::WEAK_REF or
        a.kind == TypeKind::ARRAY and b.kind == TypeKind::ARRAY or
        a.kind == TypeKind::STATIC_ARRAY and b.kind == TypeKind::STATIC_ARRAY {

        if a.tpe and a.tpe.kind == TypeKind::GENERIC {
            let score = convert_type_score(a.tpe, b.tpe, module, is_type)
            if score >= 0 {
                return score
            }
        }
    } 

    if a.kind == TypeKind::TUPLE and b.kind == TypeKind::STATIC_ARRAY and a.return_t.length == b.length {
        var max_conv = 1
        for var tpe in a.return_t {
            let conv = convert_type_score(b.tpe, tpe, module, is_type)
            if conv > max_conv { max_conv = conv }
            else if conv == -1 { max_conv = -1; break }
        }
        if max_conv >= 0 { return max_conv }
    }

    if a.kind == TypeKind::STATIC_ARRAY and b.kind == TypeKind::STATIC_ARRAY {
        if equals(a.tpe, b.tpe) and 
            (a.length == b.length or a.length !uint64 == std::MAX_UINT64) {
            return 0
        }
    }
    if a.kind == TypeKind::STATIC_ARRAY and b.kind == TypeKind::TUPLE {
        var max_conv = 1
        for var tpe in b.return_t {
            let conv = convert_type_score(a.tpe, tpe, module, is_type)
            if conv > max_conv {
                max_conv = conv
            } else if conv == -1 {
                max_conv = -1
                break
            }
        }

        if max_conv >= 0 {
            if a.length !uint64 == std::MAX_UINT64 { return max_conv }
            if b.return_t.length == a.length { return max_conv }
        }
    }
    if (@a).kind == TypeKind::ARRAY {
        if (@b).kind == TypeKind::STATIC_ARRAY and equals((@a).tpe, (@b).tpe) {
            return 1
        }
        if (@a).tpe == null and ((@b).kind == TypeKind::ARRAY or (@b).kind == TypeKind::STATIC_ARRAY) {
            return 1
        }
        if b.kind == TypeKind::TUPLE {
            var max_conv = 1
            for var tpe in b.return_t {
                let conv = convert_type_score(a.tpe, tpe, module, is_type)
                if conv > max_conv {
                    max_conv = conv
                } else if conv == -1 {
                    max_conv = -1
                }
            }
            if max_conv >= 0 { return max_conv }
        }
    }
    if a.kind == TypeKind::GENERIC {
        if a.kind != b.kind {
            if b.tc_args and equals(a.tpe, b.tc_tpe) {
                if vector::length(a.tc_args) != vector::length(b.tc_args) { return -1 }
                for var i in 0..vector::length(a.tc_args) {
                    let arg_a = a.tc_args(i)
                    let arg_b = b.tc_args(i)
                    if arg_a.kind == TypeKind::TYPE_DEF { continue }
                    if not equals(arg_a, arg_b) { return -1 }
                }
                return 3
            } else {
                return 3 if infer_interface_types(a, b, module) != null else -1
            }
        } else {
            return 0 if equals(a.tpe, b.tpe) else -1
        }
    }
    if a.kind == TypeKind::CLOSURE and b.kind == TypeKind::CLOSURE and b.is_anon {
        if vector::length(a.parameter_t) != vector::length(b.parameter_t) {
            return -1
        }
        for var i in 0..vector::length(a.parameter_t) {
            let param_a = a.parameter_t(i)
            let param_b = b.parameter_t(i)
            if not equals(param_a.tpe, param_b.tpe) and not (param_b.tpe and param_b.tpe.kind == TypeKind::TO_INFER) {
                return -1
            }
        }
        // If we have a return type we're going to check them
        var has_right_return_types = false
        if b.return_t.length > 0 {
            if vector::length((@a).return_t) != vector::length((@b).return_t) {
                return -1
            }
            for var i in 0..vector::length((@a).return_t) {
                if not equals(a.return_t(i), b.return_t(i)) {
                    return -1
                }
            }
            has_right_return_types = true
        } else if a.return_t.length == 0 {
            has_right_return_types = true
        }

        return 2 if has_right_return_types else 3
    }
    if a.kind == TypeKind::CLOSURE and is_pointer(b) and b._tpe and b._tpe.kind == TypeKind::FUNCTION {
        b = b._tpe
        if vector::length(a.parameter_t) != vector::length(b.parameter_t) {
            return -1
        }
        for var i in 0..vector::length(a.parameter_t) {
            let param_a = a.parameter_t(i)
            let param_b = b.parameter_t(i)
            if not equals(param_a.tpe, param_b.tpe) {
                return -1
            }
        }
        if vector::length(a.return_t) != vector::length(b.return_t) {
            return -1
        }
        for var i in 0..vector::length(a.return_t) {
            if not equals(a.return_t(i), b.return_t(i)) {
                return -1
            }
        }
        return 2
    }
    
    if impl and a.kind != TypeKind::TYPE {
        let parameter_t = vector::make(NamedParameter)
        parameter_t.push([_tpe = b] !NamedParameter)
        let conv = scope::find_implicit_function(module.scope, parameter_t, a, not consteval::is_static)
        if conv {
            if consteval::is_static {
                consteval::compile_function(conv, module.scope, parameter_t)
            }
            return IMPLICIT
        }
    }

    let intfp = get_interface(a)
    if intfp {
        if a.kind == TypeKind::REFERENCE and b.kind == TypeKind::REFERENCE {
            if b.tpe and b.tpe.kind == TypeKind::NULL or implements(b.tpe, intfp, module) {
                return 6
            }
        }
        if a.kind == TypeKind::REFERENCE and implements(reference(b), intfp, module) { return 6 }
        if a.kind == TypeKind::REFERENCE and implements(b, intfp, module) { return 6 }
        if implements(b, intfp, module) { return 0 } // This is so that new specializations always win
    }

    if is_type { 
        if a.kind == TypeKind::ARRAY {
            if (b.kind == TypeKind::ARRAY or b.kind == TypeKind::STATIC_ARRAY) {
                return convert_type_score(a.tpe, b.tpe, module, true)
            }
            return -1
        }
        if is_pointer(a) or a.kind == TypeKind::REFERENCE or a.kind == TypeKind::WEAK_REF or a.kind == TypeKind::STATIC_ARRAY {
            if a.kind == b.kind {
                return convert_type_score(a.tpe, b.tpe, module, true)
            }
            if convert_type_score(a.tpe, b, module, true) >= 0 {
                return 10
            }
            return -1
        }
        return 1
    }
    return -1
}

export def get_type_constructor(tpe: &Type) -> &Type {
    if not tpe { return null }
    if tpe.tc_tpe { return tpe.tc_tpe }
    if tpe.kind == TypeKind::GENERIC {
        return tpe.tpe
    }
    if is_box(tpe) {
        return get_type_constructor(tpe.tpe)
    }
    return null
}

export def get_generic(tpe: &Type) -> &Type {
    if not tpe { return null }
    if tpe.tc_args { return tpe }
    if is_box(tpe) {
        return get_generic(tpe.tpe)
    }
    return null
}

export def is_polymorph(tpe: &Type, is_ref: bool = false) -> bool {
    if not tpe { return false }
    else if tpe.tc_incomplete {
        return true
    } else if tpe.kind == TypeKind::STRUCTURAL {
        return not is_ref 
    } else if tpe.tc_args {
        return tpe.tc_incomplete
    } else if tpe.kind == TypeKind::TYPE_DEF {
        return true
    } else if tpe.kind == TypeKind::GENERIC {
        return tpe.tc_incomplete
    } else if tpe.kind == TypeKind::TYPE {
        return tpe.tpe == null
    } else if tpe.kind == TypeKind::POINTER or
        tpe.kind == TypeKind::STATIC_ARRAY or tpe.kind == TypeKind::ARRAY {
        return is_polymorph(tpe.tpe)
    } else if tpe.kind == TypeKind::REFERENCE {
        return is_polymorph(tpe.tpe, true)
    } else if tpe.kind == TypeKind::FUNCTION {
        return is_polymorph(tpe.parameter_t)
    } else if tpe.kind == TypeKind::TUPLE {
        for var tpe in tpe.return_t {
            if is_polymorph(tpe) { return true }
        }
        return false
    }
    return false
}

export def is_polymorph(args: &Vector(NamedParameter)) -> bool {
    for var i in 0..vector::length(args) {
        let np = args(i)
        if is_polymorph(np.tpe) {
            return true
        }
    }
    return false
}

def find_type_defs(module: &toolchain::Module, left: &Type, right: &Type, types: &SMap(&Type), replace: bool = true, is_type: bool = false) {
    if not left or not right { return }

    if left.kind == TypeKind::TYPE_DEF and right.kind != TypeKind::TYPE_DEF {
        find_type_defs(module, left.tpe, right, types, replace, true)
        if replace {
            if left.tpe.kind == TypeKind::ARRAY and right.kind == TypeKind::STATIC_ARRAY {
                // Turn static array into a dynamic array
                @left = @right
                left.kind = TypeKind::ARRAY
            } else if left.tpe.kind == TypeKind::STUB or 
                left.tpe.kind == TypeKind::STRUCT or 
                left.tpe.kind == right.kind {
                
                @left = @right
            }
        }
    } else if is_box(left) {
        find_type_defs(module, left.tpe, right.tpe, types, replace, is_type)
    } else if (left.kind == TypeKind::FUNCTION or left.kind == TypeKind::CLOSURE or left.kind == TypeKind::TUPLE) and left.kind == right.kind {
        for var i in 0..vector::length(left.parameter_t) {
            let l = left.parameter_t(i)
            let r = right.parameter_t(i)
            find_type_defs(module, l.tpe, r.tpe, types, replace, is_type)
        }
    } else if left.kind == TypeKind::GENERIC {
        if right.tc_args {
            for var i in 0..vector::length(left.tc_args) {
                let l = left.tc_args(i)
                var r = right.tc_args(i)
                var is_type = false
                if r and r.kind == TypeKind::TYPE_DEF {
                    is_type = true
                    r = r.tpe
                }
                find_type_defs(module, l, r, types, replace, is_type)
            }
            if replace {
                @left = @right
            }
        } else {
            right = infer_interface_types(left, right, module)
            if right {
                for var i in 0..vector::length(left.tc_args) {
                    let l = left.tc_args(i)
                    var r = right.tc_args(i)
                    var is_type = false
                    if r and r.kind == TypeKind::TYPE_DEF {
                        is_type = true
                        r = r.tpe
                    }
                    find_type_defs(module, l, r, types, replace, is_type)
                }
                if replace {
                    @left = @right
                }
            }
        }
    }
    if is_type and left.name {
        types(left.name) = right
    }
}

def replace_parameter(tpe: &Type, types: &SMap(&Type)) -> &Type {
    if not tpe { return null }
    if tpe.tc_args {
        for var i in 0..vector::length(tpe.tc_args) {
            let arg = tpe.tc_args(i)
            tpe.tc_args(i) = replace_parameter(arg, types)
        }
    } else if is_box(tpe) {
        if tpe.tpe {
            tpe._tpe = replace_parameter(tpe.tpe, types)
        }
    } else if tpe.kind == TypeKind::FUNCTION or tpe.kind == TypeKind::CLOSURE {
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = tpe.parameter_t.get(i)
            np._tpe = replace_parameter(np.tpe, types)
        }
        for var i in 0..vector::length(tpe.return_t) {
            let rett = tpe.return_t(i)
            tpe.return_t(i) = replace_parameter(rett, types)
        }
    } else if tpe.kind == tpe.kind == TypeKind::TUPLE {
        for var i in 0..vector::length(tpe.return_t) {
            let rett = tpe.return_t(i)
            tpe.return_t(i) = replace_parameter(rett, types)
        }
    } else if tpe.kind != TypeKind::TYPE_DEF and tpe.name {
        let ntpe = types.get_or_default(tpe.name, null)
        if ntpe { return ntpe }
    }
    tpe._hash = 0
    return tpe
}

// NOTE: This function mutates param_a and return_t, watch out!
export def replace_type_defs(
    param_a: &Vector(NamedParameter), 
    return_t: &Vector(&Type), 
    param_b: &Vector(NamedParameter), 
    types_map: &SMap(&Type), 
    module: &toolchain::Module, 
    replace: bool = true,
    impl: bool = true) {

    if not types_map {
        types_map = map::make(type &Type)
    }

    for var i in 0..vector::length(param_a) {
        let left = param_a.get(i)
        
        let ltpe = copy(left.tpe)
        if not ltpe { continue }

        var right: *NamedParameter = null
        for var j in 0..vector::length(param_b) {
            let r = param_b.get(j)
            if r.name and r.name == left.name {
                right = r
                break
            }
        }
        if not right and i < vector::length(param_b) {
            right = param_b.get(i)
        }

        var rtpe: &Type = null
        if right {
            rtpe = right.tpe
        }
        if not right and left.value {
            rtpe = left.value.tpe
        }

        if not rtpe { return }
        if convert_type_score(ltpe, rtpe, module, impl = impl) < 0 { return }

        let intf = get_interface(ltpe)
        if intf and replace {
            left._tpe = rtpe
            continue
        }

        if ltpe.kind == TypeKind::TYPE {
            if ltpe.name and right and right.value and replace {
                types_map(ltpe.name) = right.value.value_tpe
                ltpe._tpe = right.value.value_tpe
            }
        } else {
            find_type_defs(module, ltpe, rtpe, types_map, replace)
            left._tpe = ltpe
        }

        for var j in (i + 1)..vector::length(param_a) {
            let np = param_a.get(j)
            if np.tpe {
                np._tpe = replace_parameter(np.tpe, types_map)
            }
        }
        for var j in 0..vector::length(return_t) {
            let rtpe = return_t(j)
            return_t(j) = replace_parameter(rtpe, types_map)
        }
    }
}

export def overload_score(a: &Type, param_b: &Vector(NamedParameter), module: &toolchain::Module, positional: bool, partial: bool = false, impl: bool = true) -> int {
    return overload_score(a.parameter_t, a.return_t, param_b, module, positional, partial, impl)
}

// Calculates a score for overload resultion, the result is 0 for an exact match
// and a positive integer if the argument types need to be converted.
// -1 is returned if the argument types don't match.

export def overload_score(
    param_a: &Vector(NamedParameter), 
    return_t: &Vector(&Type), 
    param_b: &Vector(NamedParameter),
    module: &toolchain::Module, 
    positional: bool, partial: bool = false,
    impl: bool = true
) -> int {
    
    param_a = copy_parameter_t(param_a)
    return_t = copy_return_t(return_t)

    if vector::length(param_a) > vector::length(param_b) and not partial {
        let a = param_a(vector::length(param_b))
        let not_default_param = a.value == null or a.tpe.kind == TypeKind::TYPE
        if vector::length(param_a) == vector::length(param_b) + 1 {
            if not vector::peek(param_a).varargs and not_default_param {
                return -1
            }
        } else if not_default_param {
            return -1
        }
    }

    replace_type_defs(param_a, return_t, param_b, null, module, false, impl = impl)

    var sum = 0
    for var i in 0..vector::length(param_b) {
        let right = param_b(i)
        var left: *NamedParameter = null
        if right.name and not positional {
            for var i in 0..vector::length(param_a) {
                let param = param_a.get(i)
                if right.name == param.name {
                    left = param
                    break
                }
            }
            if not left { return -1 }
        } else {
            if i < vector::length(param_a) {
                left = param_a.get(i)
            } else if vector::length(param_a) > 0 {
                left = param_a.get(param_a.length - 1)
                if not left.varargs {
                    return -1
                } 
            } else {
                return -1
            }
        }
        var lvalue = left.tpe
        if i == vector::length(param_a) - 1 and 
            left.varargs and not right.varargs and left.tpe and
            convert_type_score(array(left.tpe), right.tpe, module, impl = impl) >= 0 {

            lvalue = array(left.tpe)
        }
        var score = -1
        if lvalue and lvalue.kind == TypeKind::TYPE {
            // TODO This is not documented and weird in more than one place
            // I think the confusion comes from the fact that sometimes the type is stored in the NamedParameter
            // and sometimes in the type directly. The latter would make more sense
            if right.tpe.may_be_type {
                // This is what it should look like for the others as well
                if not left.tpe.tpe {
                    score = 4
                } else if right.tpe.may_be_type.tpe.tpe and equals(left.tpe.tpe, right.tpe.may_be_type.tpe.tpe) {
                    score = 0
                }
            } else if equals(right.tpe, pointer(builtins::Type_)) {
                if left.value {
                    if equals(left.value.value_tpe, right.tpe.tpe.tpe) {
                        score = 0
                    }
                } else {
                    if left.tpe and equals(left.tpe.tpe, right.tpe.tpe.tpe) {
                        score = 0
                    } else if not left.tpe.tpe {
                        score = 0
                    }
                }
            } else if is_type(right.tpe) {
                if left.value and right.value and equals(left.value.value_tpe, right.value.value_tpe) {
                    score = 0
                } else if not left.tpe.tpe and not right.tpe.tpe {
                    score = 0
                } else if left.tpe.tpe and right.tpe.tpe and equals(left.tpe.tpe, right.tpe.tpe) {
                    score = 0
                }
            }
        } else {
            score = convert_type_score(lvalue, right.tpe, module, impl = impl)
        }
        if score < 0 { return -1 }
        sum += score
    }

    if is_polymorph(param_a) and not is_polymorph(param_b) and sum >= 0 {
        // Penalty for specialization
        sum += 1
    }
    return sum
}

export def mangle_function_name(name: Str, parameter_t: &Vector(NamedParameter), test: bool = false, context: &toolchain::Module = null) -> Str {
    var res = name
    if context {
        res = context.module + "#" + name
    }
    res += "::("

    let len = vector::length(parameter_t)
    for var i in 0..len {
        let np = parameter_t(i)
        if np.varargs and not np.tpe {
            res += "..."
            break
        }
        if np.varargs {
            res += '['
        }
        if np.tpe and np.tpe.kind == TypeKind::TYPE {
            // TODO This should be handled by type_to_str
            res += "type"
            if np.value {
                res += '<' + debug::type_to_str(np.value.value_tpe, true) + '>'
            }
        } else {
            res += debug::type_to_str(np.tpe, true)
        }
        if np.varargs {
            res += ']'
        }
        if i < len - 1 {
            res += ", "
        }
    }
    res += ')'

    if test {
        res = "__test::" + res
    }

    return res
}

// TODO Move this into parser
export def last_ident_to_str(node: &parser::Node) -> String {
    if not node { return "" }
    assert(node.kind == parser::NodeKind::IDENTIFIER)
    if vector::length(node.value.identifier.path) > 1 {
        errors::errorn(node, "Expected plain identifier without path")
    }
    return node.value.identifier.path(0)
}

def flatten_return_type(node: &parser::Node, return_t: &Vector(&Type)) -> &Type {
    let len = vector::length(return_t) 
    if len > 1 {
        // TODO size and alignment! Same as a struct,
        // also refactor type_lookup and compiler (functions with multiple return types)
        // into a single function for calculating the size and alignmenet of a struct
        let return_tpe = make_type_raw(TypeKind::TUPLE)
        (@return_tpe).line = node.loc.line
        (@return_tpe).return_t = return_t
        return return_tpe
    } else if len == 1 {
        return vector::peek(return_t)
    }

    return make_type_raw(TypeKind::VOID)
}

def check_is_identifier_assignable(node: &parser::Node, state: &State) -> bool {
    if node.kw != parser::VarDecl::VAR {
        errors::errorn(node, "Assignment to non var")
        return false
    }
    return true
}

export def make_stub_type(ident: &parser::Node, state: &State, prefix: bool = true) -> &typechecking::Type {
    assert ident.kind == parser::NodeKind::IDENTIFIER

    let name = parser::identifier_to_str(ident)
    let tpe = make_type_raw(TypeKind::STUB)
    tpe.name = ident.value.identifier.path(vector::length(ident.value.identifier.path) - 1)
    tpe.type_name = name
    if prefix and vector::length(ident.value.identifier.path) == 1 {
        tpe.type_name = append_module(tpe.type_name, state.module.module)
    }
    return tpe 
}

export def make_union_type(fields: &[StructMember], const_fields: &[StructMember], current_type: &Type = null) -> &Type {
    let tpe = make_type_raw(TypeKind::UNION) if not current_type else current_type
    let field_types = vector::make(TypeMember)
    
    var size = 0 !size_t
    var align = 1 !size_t
    var biggest_type: &Type = null
    for var i in 0..fields.size {
        let field = fields(i)
        var field_tpe = field.tpe
        if field_tpe {
            if field_tpe.size > size {
                size = field_tpe.size
                biggest_type = field_tpe
            }
            if field_tpe.kind == TypeKind::TYPE_CONSTRUCTOR {
                errors::errorn(field.node, "Can't use type constructor as field type")
            }
            // TODO Alignment of bit fields on Windows is strange
            align = max(field_tpe.align, align) !size_t
        }
    }

    let type_member = [ tpe = biggest_type, offset = 0 ] !TypeMember
    field_types.push(type_member)

    tpe.size = size
    tpe.align = align
    tpe.fields = fields
    tpe.const_fields = const_fields if const_fields else allocate_ref(StructMember, 0)
    tpe.field_types = field_types

    return tpe
}

export def make_tuple_type(types: &Vector(&Type)) -> &Type {
    let fields = vector::make(StructMember)
    let tpe = make_type_raw(TypeKind::TUPLE)

    for var t in types {
        fields.push([ tpe = t ] !StructMember)
    }

    let struct_type = make_struct_type(fields.to_array()) // TODO Maybe a have a seperate function to calculate align and size
    tpe.return_t = types
    tpe.align = struct_type.align
    tpe.size = struct_type.size
    return tpe
}

export def make_struct_type(fields: &[StructMember], const_fields: &[StructMember] = null, current_type: &Type = null) -> &Type {
    let struct_tpe = make_type_raw(TypeKind::STRUCT) if not current_type else current_type
    let field_types = vector::make(TypeMember)

    var j = 0
    var bit_offset = 0
    var bit_type: &Type = null

    for var i in 0..fields.size {
        let field = *fields(i)
        let tpe = field.tpe
        if not tpe { continue }
        field.index = j

        if field.tpe.kind == TypeKind::TYPE_CONSTRUCTOR {
            errors::errorn(field.node, "Can't use type constructor as field type")
            continue
        }

        if field.is_bitfield {
            #if defined WIN32 {
                // TODO Windows
                bit_type = field.tpe
                continue
            } else {
                // Linux
                if not bit_type {
                    bit_type = tpe
                }
                if bit_offset + field.bit_size < bit_type.size * 8 {
                    // Go back and extend the type
                    if tpe.size > bit_type.size {
                        bit_type = tpe
                    }
                    field.bit_offset = bit_offset
                    bit_offset += field.bit_size
                    continue
                } else {
                    // It doesn't fit so let's make a new entry
                    field_types.push([
                        tpe = bit_type
                    ] !TypeMember)

                    bit_type = tpe
                    bit_offset = 0
                    field.bit_offset = 0

                    j += 1
                    continue
                }
            }
        } else {
            if bit_type {
                field_types.push([
                    tpe = bit_type
                ] !TypeMember)
                j += 1
            }

            field.index = j
            
            field_types.push([
                tpe = tpe
            ] !TypeMember)

            bit_type = null
            bit_offset = 0

            j += 1
        }
    }

    if bit_type {
        field_types.push([
            tpe = bit_type
        ] !TypeMember)
    }

    var offset = 0 !size_t
    var align = 1 !size_t

    for var type_member in field_types.iterate_ref() {
        let tpe = type_member.tpe
        if tpe.align > 0 {
            offset = (ceil(offset / tpe.align !double) * tpe.align) !int
            align = util::lcm(align !int, tpe.align !int)
        }

        type_member.offset = offset
        offset += tpe.size
    }

    offset = (ceil(offset / align !double) * align) !int

    struct_tpe.size = offset
    struct_tpe.align = align
    struct_tpe.fields = fields
    struct_tpe.const_fields = const_fields if const_fields else allocate_ref(StructMember, 0)
    struct_tpe.field_types = field_types

    return struct_tpe
}

def lookup_type_constructor(tc: &parser::Node, node: &parser::Node, state: &State) -> &Type {
    if not node { return null }
    let name = tc.value.type_constructor.name
    let tpe = make_type(TypeKind::TYPE_CONSTRUCTOR, name)
    tpe.parameter_t = vector::make(NamedParameter)

    let args = tc.value.type_constructor.args
    for var i in 0..vector::length(args) {
        let arg = args(i)
        assert arg.kind == parser::NodeKind::PARAMETER
        tpe.parameter_t.push([ 
            name = parser::identifier_to_str(arg.value.param.name), 
            _tpe = builtins::type_ 
        ] !NamedParameter)
    }
    tpe.tc_node = node
    tpe.tc_node.module = state.module
    tpe.module = state.module
    tpe.cache = map::make(TypeRef, type &Type)
    return tpe
}

// This generates concrete functons when refering to type constructors
export def generate_concrete_functions(type_constructor: &Type, tpe: &Type, state: &State) {
    if consteval::is_static { return }
    if is_polymorph(tpe) { return }

    let functions = get_member_functions(tpe)
    for var j in 0..vector::length(functions) {
        let function = functions(j)

        let ftpe = copy(function.function)
        if ftpe.kind != TypeKind::FUNCTION { continue }

        let pars = vector::make(NamedParameter)
        pars.push([ _tpe = tpe ] !NamedParameter)
        
        replace_type_defs(ftpe.parameter_t, ftpe.return_t, pars, null, state.module)
        ftpe.type_name = mangle_function_name(append_module(ftpe.name, ftpe.module.module), ftpe.parameter_t, context = ftpe.context)

        if not is_polymorph(ftpe) {
            let new_entry = create_type_entry(tpe, function.exported, ftpe, function.module)
            if new_entry {
                let score, value = scope::get_function_check(state.scope, parser::make_identifier(ftpe.name), pars, false, true, force_compile = true, context = state.context)
            }
        }
    }
}

export def type_lookup(node: &parser::Node, state: &State, current_type: &Type = null, lookup_default: bool = false, cache: &SMap(&Type) = null, prefix: String = null) -> &Type {
    var tpe = do_type_lookup(node, state, current_type, lookup_default, cache, prefix)
    if node { node.tpe = tpe }
    if tpe !* == current_type !* { return current_type }
    
    let type_constructor = get_type_constructor(tpe)
    if tpe and type_constructor and type_constructor.kind != TypeKind::STUB {
        let type_name = debug::type_to_str(tpe, full_name = true)

        let _ref = [module = state.get_context(), name = type_name] !typechecking::TypeRef
        if not map::contains(type_constructor.cache, _ref) {
            type_constructor.cache(_ref) = null
            generate_concrete_functions(type_constructor, tpe, state)
            type_constructor.cache(_ref) = (tpe if tpe.tc_tpe !* == type_constructor !* else null !&Type)
        }
    }
    if tpe and (tpe.kind == TypeKind::STRUCT or tpe.kind == TypeKind::UNION) {
        if check_is_recursive(tpe) {
            if not tpe.node.is_recursive_type { 
                errors::errorn(tpe.node, "Recursive type declaration!")
            }
            tpe.node.is_recursive_type = true
            tpe = make_type_raw(TypeKind::STUB)
        }
    }

    if tpe { 
        tpe.node = node
        if not tpe.module { 
            tpe.module = state.module 
        }
    }
    return tpe
}

def convert_ambiguous_expr_to_type(node: &parser::Node, state: &State) -> &Node {
    if node.kind == parser::NodeKind::STRUCT_LIT and node.value.struct_lit.kwargs.length == 0 {
        if node.value.struct_lit.args.length == 1 {
            var res = [ kind = parser::NodeKind::ARRAY_T ] !&parser::Node
            res.value.t_parr.tpe = convert_ambiguous_expr_to_type(node.value.struct_lit.args(0), state)
            walk(null, res, state)
            res.tpe.node = null // This may be needed to avoid a dangling weak reference
            return res
        } else {
            var res = [ kind = parser::NodeKind::TUPLE_T ] !&parser::Node
            var types = vector::make(type &parser::Node)
            for var n in node.value.struct_lit.args {
                types.push(convert_ambiguous_expr_to_type(n, state))
            }
            res.value.body = types

            walk(null, res, state)
            res.tpe.node = null
            return res
        }
    } else if node.kind == parser::NodeKind::PTR {
        var res = [ kind = parser::NodeKind::PTR_T ] !&parser::Node
        res.value.t_parr.tpe = convert_ambiguous_expr_to_type(node.value.expr, state)

        walk(null, res, state)
        res.tpe.node = null
        return res
    } else if node.kind == parser::NodeKind::IDENTIFIER {
        type_lookup(node, state)
        return node
    }
}

def lookup_field_type(node: &parser::Node, state: &State, current_type: &Type, cache: &map::SMap(&Type)) -> &Type {
    if not node { return null }
    node.scope = state.scope

    let prev_node = node
    if node.kind == parser::NodeKind::WEAK_REF_T {
        // Unwrap weak ref
        node = node.value.t_parr.tpe
    }

    if node.kind == parser::NodeKind::PTR_T or
        node.kind == parser::NodeKind::REF_T or
        node.kind == parser::NodeKind::ARRAY_T or
        node.kind == parser::NodeKind::WEAK_REF_T {
        
        var stub: &Type = null
        let parr = node.value.t_parr.tpe
        if parr {
            parr.parent = node
            if parr.tpe {
                stub = parr.tpe
            } else {
                if parr.kind == parser::NodeKind::IDENTIFIER {
                    stub = make_stub_type(parr, state)
                } else {
                    stub = make_type_raw(TypeKind::STUB)
                }
                stub.state = consteval::copy_state(state)
                stub.module = state.module
                stub.node = parr
                parr.tpe = stub
            }
        }

        if prev_node.kind == parser::NodeKind::PTR_T {
            stub = pointer(stub, node.value.t_parr.kw)
        } else if prev_node.kind == parser::NodeKind::REF_T {
            stub = reference(stub, node.value.t_parr.kw)
        } else if prev_node.kind == parser::NodeKind::ARRAY_T {
            stub = array(stub, node.value.t_parr.kw)
        }

        if prev_node.kind == parser::NodeKind::WEAK_REF_T {
            stub = weak_reference(stub, node.value.t_parr.kw)
            stub.module = state.module
            stub.node = node
            prev_node.tpe = stub
        }
        
        return stub
    } else {
        return type_lookup(node, state, current_type, false, cache)
    }
}

// TODO current_type is basically a hack, there's really no reason why you should already have a type and then look it up again
export def do_type_lookup(node: &parser::Node, state: &State, current_type: &Type = null, lookup_default: bool = false, cache: &map::SMap(&Type) = null, prefix: String = null) -> &Type {
    if not node { return null }
    if node.kind == parser::NodeKind::IDENTIFIER {
        if current_type and not lookup_default and current_type.kind != TypeKind::STUB {
            return current_type
        }
        if not lookup_default {
            let value = scope::get(state.scope, node)
            if not value {
                errors::errorn(node, "Unknown identifier `", parser::identifier_to_str(node), "`")
                scope::create_dependency(state.current_value(), scope::make_ident(parser::identifier_to_str(node)))
                return null
            } else {
                if value.modifier != parser::VarDecl::TYPE { return null }

                let tpe = value.value.value_tpe
                node.svalue = value
                if not tpe {
                    scope::create_dependency_on_type(state.current_value(), node)
                }
                scope::create_dependency(state.current_value(), value)
                return tpe
            }
            
        } else {
            let value = scope::get(state.scope, node, false, false)
            node.svalue = value
            var tpe: &Type = null
            if value {
                if value.modifier != parser::VarDecl::TYPE {
                    errors::errorn(node, "`", parser::identifier_to_str(node), "` is not a type")
                    return null
                }
                scope::create_dependency(state.current_value(), value)
                tpe = value.value.value_tpe
            } else {
                tpe = make_stub_type(node, state, prefix = false)
                tpe.is_type_argument = true // TODO Maybe don't reuse this
                if prefix {
                    tpe.type_name = prefix + tpe.type_name
                }
                var share = parser::ShareMarker::EXPORT
                if vector::length(node.value.identifier.path) == 1 {
                    share = parser::ShareMarker::NONE
                }
                tpe.svalue = scope::create_type(state.scope, node, share, tpe, scope::Phase::DECLARED, null, null)
                scope::create_dependency(state.current_value(), tpe.svalue)
            }
            return tpe
        }
    } else if node.kind == parser::NodeKind::PTR_T {
        if current_type { current_type = current_type.tpe }
        node.scope = state.scope
        if node.value.t_parr.tpe { node.value.t_parr.tpe.parent = node }
        var tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        tpe = pointer(tpe, node.value.t_parr.kw)
        return tpe
    } else if node.kind == parser::NodeKind::REF_T {
        if current_type { current_type = current_type.tpe }
        node.scope = state.scope
        if node.value.t_parr.tpe { node.value.t_parr.tpe.parent = node }
        var tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        tpe = reference(tpe, node.value.t_parr.kw)
        return tpe
    } else if node.kind == parser::NodeKind::WEAK_REF_T {
        if current_type { current_type = current_type.tpe }
        node.scope = state.scope
        if node.value.t_parr.tpe { node.value.t_parr.tpe.parent = node }
        var tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        if not tpe or tpe.kind != TypeKind::REFERENCE {
            errors::errorn(node, "Weak reference must point at a reference!")
        }
        tpe = weak_reference(tpe.tpe, tpe.kw)
        return tpe
    } else if node.kind == parser::NodeKind::STRUCT_T or node.kind == parser::NodeKind::UNION_T {
        
        let length = vector::length(node.value.body)
        let fields = vector::make(StructMember)
        let const_fields = vector::make(StructMember)

        for var i in 0..length {
            let field = node.value.body(i)
            if not field { continue }
            field.scope = state.scope
            let line = (@field).loc.line

            var field_tpe: &Type = null
            var name: Str
            var is_bitfield = false
            var is_embed = field.value.id_decl_struct.is_embed
            var bit_size = 0 !size_t
            var is_const = field.value.id_decl_struct.is_const
            var value: &compiler::Value

            var field_type: &Type = null
            if not is_embed and current_type and current_type.kind != TypeKind::STUB { field_type = current_type.fields(i).tpe }

            if (@field).kind == parser::NodeKind::ID_DECL_STRUCT {
                if field.value.id_decl_struct.is_embed {
                    let ftpe = field.value.id_decl_struct.tpe
                    field_tpe = type_lookup(ftpe, state, ftpe.tpe, false, cache)
                } else {
                    let ident = (@field).value.id_decl_struct.ident
                    name = last_ident_to_str(ident)
                    if field.value.id_decl_struct.tpe { field.value.id_decl_struct.tpe.parent = field }
                    field_tpe = lookup_field_type((@field).value.id_decl_struct.tpe, state, field_type, cache)
                    if field.value.id_decl_struct.is_bitfield {
                        is_bitfield = true
                        bit_size = field.value.id_decl_struct.bit_size
                    }
                    if is_const {
                        // Load value for const
                        value = consteval::expr(field.value.id_decl_struct.value, state)
                    }
                }
            } else if (@field).kind == parser::NodeKind::STRUCT_T or
                (@field).kind == parser::NodeKind::UNION_T {
                field_tpe = type_lookup(field, state, field_type, false, cache)
            }
            
            let member = [ 
                node = field,
                line = line, 
                name = name, 
                tpe = field_tpe,
                is_bitfield = is_bitfield,
                is_embed = is_embed,
                bit_size = bit_size,
                is_const = is_const,
                value = value
            ] !StructMember

            if is_const { const_fields.push(member) }
            else { fields.push(member) }
        }
        
        var tpe = (make_struct_type(fields.to_array(), const_fields.to_array(), current_type)
            if node.kind == parser::NodeKind::STRUCT_T
            else make_union_type(fields.to_array(), const_fields.to_array(), current_type))

        tpe.line = node.loc.line
        if current_type and current_type.type_name {
            tpe.type_name = current_type.type_name
        } else {
            tpe.type_name = make_unique_name("<anonymous>", state)
        }
        tpe.name = "<anonymous>"
        tpe.line = node.loc.line

        return tpe
    } else if node.kind == parser::NodeKind::ENUM_T {
        if current_type { current_type = current_type.tpe }
        var enum_tpe = builtins::int_
        if node.value.t_enum.tpe {
            enum_tpe = type_lookup(node.value.t_enum.tpe, state, current_type, lookup_default, cache)
        }
        let tpe = make_type_raw(TypeKind::ENUM)
        (@tpe).line = node.loc.line
        (@tpe)._tpe = enum_tpe
        (@tpe).size = (@enum_tpe).size
        (@tpe).align = (@enum_tpe).align

        return tpe
    } else if node.kind == parser::NodeKind::ARRAY_T {
        if current_type { current_type = current_type.tpe }
        node.scope = state.scope
        if node.value.t_parr.tpe { node.value.t_parr.tpe.parent = node }
        let array_tpe = type_lookup(node.value.t_parr.tpe, state, current_type, lookup_default, cache)
        let tpe = array(array_tpe, node.value.t_parr.kw)
        return tpe
    } else if node.kind == parser::NodeKind::ARRAY_STATIC_T {
        if current_type { current_type = current_type.tpe }
        node.scope = state.scope
        if node.value.t_arrs.tpe { node.value.t_arrs.tpe.parent = node }
        let array_tpe = type_lookup(node.value.t_arrs.tpe, state, current_type, lookup_default, cache)

        var n = std::MAX_UINT64 !int64
        if node.value.t_arrs.n {
            n = 0
            let value = consteval::expr(node.value.t_arrs.n, state)
            if value.tpe.kind != TypeKind::WORD {
                errors::errorn(node.value.t_arrs.n, "Type needs to be a positive integer, got ", debug::type_to_str(value.tpe))
            } else if not value.tpe.unsig and value.i < 0 {
                errors::errorn(node.value.t_arrs.n, "Negative array size not allowed")
            } else {
                n = value.i
            }
        }

        let tpe = make_static_array(array_tpe, n, node.value.t_arrs.kw)
        return tpe
    } else if node.kind == parser::NodeKind::FUNCTION_T or node.kind == parser::NodeKind::CLOSURE_T {
        var tpe: &Type
        var fun: &Type
        if node.kind == parser::NodeKind::FUNCTION_T {
            tpe = make_function_type()
        } else {
            tpe, fun = make_closure_type()
        }

        (@tpe).line = node.loc.line
        (@tpe).parameter_t = vector::make(NamedParameter)
        for var i in 0..vector::length(node.value.t_func.args) {
            var arg_type: &Type = null
            if current_type and current_type.parameter_t and current_type.parameter_t.length < i { 
                arg_type = (current_type.parameter_t(i)).tpe 
            }

            let arg = node.value.t_func.args(i)
            let np = [
                _tpe = box(type_lookup(arg, state, arg_type, lookup_default, cache)),
                node = arg
            ] !NamedParameter
            tpe.parameter_t.push(np)
            if fun {
                fun.parameter_t.push(np)
            }
        }
        (@tpe).return_t = vector::make(type &Type)
        for var i in 0..vector::length(node.value.t_func.ret) {
            var return_type: &Type = null
            if current_type { 
                return_type = current_type.return_t(i)
            }

            let arg = node.value.t_func.ret(i)
            // TODO This needs to be boxed as well, potential memory leak
            let ret_tpe = type_lookup(arg, state, return_type, lookup_default, cache)

            tpe.return_t.push(ret_tpe)
            if fun {
                fun.return_t.push(ret_tpe)
            }
        }
        tpe.module = state.module
        if node.kind == parser::NodeKind::FUNCTION_T {
            tpe = pointer(tpe)
        }
        return tpe
    } else if node.kind == parser::NodeKind::TYPE_T {
        if current_type { return current_type }
        let wrapped = type_lookup(node.value.expr, state, current_type, lookup_default, cache)
        let tpe = make_type_raw(TypeKind::TYPE_DEF)
        if node.value.expr and node.value.expr.kind == parser::NodeKind::IDENTIFIER {
            tpe.name = parser::identifier_to_str(node.value.expr)
        }
        tpe.line = node.loc.line
        tpe._tpe = wrapped
        return tpe
    } else if node.kind == parser::NodeKind::UNSIGNED_T {
        let signed = copy(type_lookup(node.value.expr, state, current_type, lookup_default, cache)) if not current_type else current_type
        if not is_arithmetic(signed) or signed.unsig {
            errors::errorn(node, "Expected arithmetic type, got ", debug::type_to_str(signed))
            return null
        }
        signed.unsig = true
        return signed
    } else if node.kind == parser::NodeKind::WORD_T {
        let n = node.value.i / 8
        let tpe = make_type_raw(TypeKind::WORD)
        tpe.size = n
        tpe.align = n
        return tpe
    } else if node.kind == parser::NodeKind::TYPE_OF_T {
        if current_type { return current_type }
        walk(node, node.value.expr, state)
        return node.value.expr.tpe
    } else if node.kind == parser::NodeKind::STRUCTURAL_T {
        let tpe = make_type_raw(TypeKind::STRUCTURAL) if not current_type else current_type
        tpe.kind = TypeKind::STRUCTURAL

        if current_type and current_type.type_name {
            tpe.type_name = current_type.type_name
        } else {
            tpe.type_name = make_unique_name("<anonymous>", state)
        }

        tpe.name = "<anonymous>"

        let members = vector::make(StructuralTypeMember)

        for var i in 0..vector::length(node.value.body) {
            let member = node.value.body(i)
            if not member { continue }
            var current_member: *StructuralTypeMember = null
            if current_type { current_member = current_type.members.get(i) }

            let name_node = member.value.structural_member.name
            if not name_node { continue }
            let name = parser::identifier_to_str(name_node)
            
            let kw = member.value.structural_member.kw
            if kw == parser::MemberType::DEF {
                let parameter_t = vector::make(NamedParameter)
                let return_t = vector::make(type &Type)

                for var i in 0..vector::length(member.value.structural_member.params) {
                    let parameter_node = member.value.structural_member.params(i)
                    let current_parameter_type = (current_member.parameter_t(i)).tpe if current_member else null !&Type
                    var ntpe = box(type_lookup(parameter_node.value.param.tpe, state, current_parameter_type, false, cache))
                    parameter_t.push([
                        name = parser::identifier_to_str(parameter_node.value.param.name),
                        _tpe = ntpe
                    ] !NamedParameter)
                }

                for var i in 0..vector::length(member.value.structural_member.returns) {
                    let return_node = member.value.structural_member.returns(i)
                    let current_return_type = current_member.return_t(i) if current_member else null !&Type

                    var ntpe = box(type_lookup(return_node, state, current_return_type, false, cache))
                    vector::push(return_t, ntpe)
                }

                let structural_type_member = [
                    name = name,
                    parameter_t = parameter_t,
                    return_t = return_t
                ] !StructuralTypeMember
                members.push(structural_type_member)
            } else {
                let parameter_t = vector::make(NamedParameter)
                let return_t = vector::make(type &Type)

                let return_node = member.value.structural_member.returns(0)
                let current_return_type = current_member.return_t(0) if current_member else null !&Type
                var rtpe = box(type_lookup(return_node, state, current_return_type, false, cache))
                return_t.push(rtpe)

                let structural_type_member = [
                    name = name,
                    parameter_t = parameter_t,
                    return_t = return_t
                ] !StructuralTypeMember
                members.push(structural_type_member)

                if kw == parser::MemberType::VAR {
                    let parameter_t = vector::make(NamedParameter)
                    let return_t = vector::make(type &Type)

                    parameter_t.push([
                        name = "_value",
                        _tpe = rtpe
                    ] !NamedParameter)

                    let structural_type_member = [
                        name = "__set_" + name + "__",
                        parameter_t = parameter_t,
                        return_t = return_t
                    ] !StructuralTypeMember
                    members.push(structural_type_member)
                }
            }
        }
        tpe.members = members

        return tpe
    } else if node.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
        if current_type and current_type.kind != TypeKind::STUB and not current_type.tc_incomplete and 
            (not current_type.tc_tpe or current_type.tc_tpe.kind != TypeKind::STUB) { 
            return current_type 
        }

        var tpe = current_type
        let name = node.value.type_constructor.name

        var type_constructor = type_lookup(name, state, null, lookup_default, cache)
        if not type_constructor { return current_type }

        if type_constructor.kind != TypeKind::STUB {
            if type_constructor.kind != TypeKind::TYPE_CONSTRUCTOR {
                errors::errorn(node, "Not a type constructor")
                return null
            }
            if vector::length(type_constructor.parameter_t) != vector::length(node.value.type_constructor.args) {
                errors::errorn(node, "Wrong amount of arguments to type constructor, expected ",
                    to_string(vector::length(type_constructor.parameter_t) !&size_t),
                    " got ",
                    to_string(vector::length(node.value.type_constructor.args) !&size_t))
                return null
            }
        }

        var type_name = type_constructor.type_name + '('
       
        var tc_args = vector::make(type &Type)
        var is_incomplete = type_constructor.kind == TypeKind::STUB
        var is_generic = false

        let len = vector::length(node.value.type_constructor.args)
        let scpe = state.scope
        var inner_scope: &scope::Scope = null
        if type_constructor.module { 
            inner_scope = scope::enter_scope(type_constructor.module.scope)
        } else {
            inner_scope = scope::enter_scope(state.scope)
        }
        for var i in 0..len {
            let arg = node.value.type_constructor.args(i)
            var np: *NamedParameter = null
            if type_constructor.kind != TypeKind::STUB {
                np = type_constructor.parameter_t.get(i)
            }

            let argtpe = type_lookup(arg, state, null, lookup_default, cache, prefix = to_string(counter) + ".")
            argtpe.is_type_argument = true
            if argtpe {
                if argtpe.kind == TypeKind::TYPE_DEF { is_generic = true }
                else if argtpe.kind == TypeKind::STUB { is_incomplete = true }
                if np {
                    scope::create_type(inner_scope, parser::make_identifier(np.name), parser::ShareMarker::NONE, argtpe, no_svalue = true)
                }
            } else { is_incomplete = true }
            tc_args.push(argtpe)

            type_name += debug::type_to_str(argtpe, full_name = true)
            if i < len - 1 {
                type_name += ", "
            }
        }
        type_name += ')'
        state.scope = inner_scope

        if is_generic {
            if type_constructor.tc_node and type_constructor.tc_node.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
                if not type_constructor.tc_node.variants {
                    type_constructor.tc_node.variants = map::make(type &parser::Node)
                }
                var tc_node = type_constructor.tc_node.variants.get_or_default(type_name, null)
                if not tc_node {
                    tc_node = parser::deep_copy_node(type_constructor.tc_node)
                    tc_node.variants = null
                    tc_node.scope = state.scope
                    type_constructor.tc_node.variants(type_name) = tc_node
                    tpe = type_lookup(tc_node, state, null, lookup_default, cache)
                } else {
                    tpe = tc_node.tpe
                }
            } else {
                tpe = make_type_raw(TypeKind::GENERIC)
                tpe.type_name = type_name
                tpe.name = type_constructor.type_name
                tpe._tpe = type_constructor
                tpe.tc_args = tc_args
                tpe.tc_incomplete = true
            }

            state.scope = scpe
            return tpe
        }
        if not cache { cache = map::make(type &Type) }
        var cached_type = cache.get_or_default(type_name, null)
        if cached_type != null {
            state.scope = scpe
            return cached_type
        }
        cached_type = make_type_raw(TypeKind::STUB)
        cache(type_name) = cached_type

        if type_constructor.tc_node {
            if not type_constructor.tc_node.variants {
                type_constructor.tc_node.variants = map::make(type &parser::Node)
            }
            var tc_node = type_constructor.tc_node.variants.get_or_default(type_name, null)
            if not tc_node {
                tc_node = parser::deep_copy_node(type_constructor.tc_node)
                tc_node.variants = null
                tc_node.scope = state.scope
                type_constructor.tc_node.variants(type_name) = tc_node
                tpe = type_lookup(tc_node, state, null, lookup_default, cache)
            } else {
                tpe = tc_node.tpe
            }

            if type_constructor.tc_node.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
                type_name = tpe.type_name
                tc_args = tpe.tc_args
                type_constructor = tpe.tc_tpe
                is_incomplete = tpe.tc_incomplete
            }
        } else {
            tpe = make_type_raw(TypeKind::STUB)
        }
        
        tpe.tc_tpe = type_constructor
        tpe.tc_args = tc_args
        tpe.tc_incomplete = is_incomplete
        // TODO use type_to_string by default
        tpe.type_name = type_name
        tpe.name = debug::type_to_str(tpe)
        tpe.module = type_constructor.module
 
        @cached_type = @tpe
        state.scope = scpe
        return cached_type
    } else if node.kind == parser::NodeKind::VARIANT_T {
        let tpe = make_type_raw(TypeKind::TUNION)

        var offset: uint64 = size_of *
        var align: uint64 = align_of *
        var biggest_type: &Type = null
        var variants = vector::make(type &Type)

        for var i in 0..node.value.t_variant.variants.length {
            var vtpe: &Type = null
            if current_type { 
                vtpe = (current_type.variants.keys()(i)).tpe 
            }

            let v = node.value.t_variant.variants(i)
            let variant = type_lookup(v, state, vtpe, lookup_default, cache)
            if variant and variant.kind == TypeKind::TUNION {
                for var inner_variant in @variant.variants.keys() {
                    variants.push(inner_variant)
                    if not biggest_type or biggest_type.size < inner_variant.size {
                        biggest_type = inner_variant
                    }
                }
            } else if variant {
                variants.push(variant)
                if not biggest_type or biggest_type.size < variant.size {
                    biggest_type = variant
                }
            }
        }

        sort_by_typename(variants)

        var fields = allocate_ref(StructMember, variants.length)
        for var i in 0..variants.length {
            fields(i) = [ name = "_" + to_string(i), tpe = variants(i) ] !StructMember
        }

        tpe.size = (ceil(offset / biggest_type.align !double) * biggest_type.align) !int
        tpe.align = util::lcm(align !int, biggest_type.align !int)
    
        tpe._tpe = make_union_type(fields, null, tpe._tpe)
        tpe.variants = set::make(variants)
        tpe.line = node.loc.line

        return tpe
    } else if node.kind == parser::NodeKind::TUPLE_T {
        let tpe = make_type_raw(TypeKind::TUPLE)

        let fields = vector::make(StructMember)
        let return_t = vector::make(type &Type)
        for var i in 0..node.value.body.length {
            var n = node.value.body(i)
            var cur: &Type = null
            if current_type { cur = current_type.return_t(i) }

            let e = type_lookup(n, state, cur, lookup_default, cache)
            return_t.push(e)
            fields.push([ tpe = e ] !StructMember)
        }


        let struct_type = make_struct_type(fields.to_array()) // TODO Maybe a have a seperate function to calculate align and size
        tpe.return_t = return_t
        tpe.align = struct_type.align
        tpe.size = struct_type.size
        tpe.line = node.loc.line

        return tpe
    }

    return null
}

// Returns the common type of two arithmetic types
// byte -> ubyte -> short -> ushort -> int -> uint -> long -> ulong
export def common_type(a: &Type, b: &Type) -> &Type {
    if not a or not b { return null }

    //TODO Should cause an error
    //assert(is_arithmetic(a) and is_arithmetic(b))

    if (@a).kind == TypeKind::FLOAT and ((@b).kind == TypeKind::WORD or b.kind == TypeKind::CHAR) {
        return a
    } else if ((@a).kind == TypeKind::WORD or a.kind == TypeKind::CHAR) and (@b).kind == TypeKind::FLOAT {
        return b
    } else if a.kind == TypeKind::BOOL and is_arithmetic(b) {
        return a
    } else if b.kind == TypeKind::BOOL and is_arithmetic(a) {
        return b
    }

    if is_arithmetic(a) and is_arithmetic(b) {
        if (@a).size == (@b).size {
            if (@b).unsig {
                return b
            } else {
                return a
            }
        } else if (@a).size > (@b).size {
            return a 
        } else {
            return b
        }
    }
    return null
}

def walk_ArrayStaticT(node: &parser::Node, state: &State) {
    let n = node.value.t_arrs.n
    let expr = node.value.t_arrs.tpe
    if not n {
        errors::errorn(n, "Type needs to be sized")
        return
    }

    var size = 0 !int64
    let value = consteval::expr(n, state)
    if value.tpe.kind != TypeKind::WORD {
        errors::errorn(n, "Type needs to be a positive integer, got ", debug::type_to_str(value.tpe))
    } else if not value.tpe.unsig and value.i < 0 {
        errors::errorn(n, "Negative array size not allowed")
    } else {
        size = value.i
    }

    let tpe2 = copy(builtins::Type_) // TODO Use TypeKind::Type
    tpe2._tpe = type_lookup(node, state)
    node.tpe = pointer(tpe2)
}

def walk_TypeOfT(node: &parser::Node, state: &State) {
    let expr = node.value.expr
    walk(node, expr, state)
    let tpe = copy(builtins::Type_) // TODO Use TypeKind::Type
    tpe._tpe = expr.tpe
    node.tpe = pointer(tpe)
}

def walk_Null(node: &parser::Node, state: &State) {
    let tpe = make_type_raw(TypeKind::NULL)
    node.tpe = tpe
}

def walk_Undef(node: &parser::Node, state: &State) {
    let tpe = make_type_raw(TypeKind::UNDEF)
    node.tpe = tpe
}

def walk_Integer(node: &parser::Node, state: &State) {
    node.tpe = builtins::int_
}

def walk_Boolean(node: &parser::Node, state: &State) {
    node.tpe = builtins::bool_
}

def walk_Float(node: &parser::Node, state: &State) {
    node.tpe = builtins::double_
}

def walk_String(node: &parser::Node, state: &State) {
    node.tpe = builtins::string_
}

def walk_Char(node: &parser::Node, state: &State) {
    node.tpe = builtins::char_
}

def walk_Range(node: &parser::Node, state: &State) {
    walk(node, node.value.bin_op.left, state)
    walk(node, node.value.bin_op.right, state)

    var kind = TypeKind::RANGE
    if node.kind == parser::NodeKind::RANGE_INC {
        kind = TypeKind::RANGE_INC
    }
    let tpe = make_type_raw(kind)
    (@tpe).line = node.loc.line
    
    node.tpe = tpe
}

export def lookup_identifier_types(node: &parser::Node, state: &State) {
    if node.value.identifier.args {
        node.value.identifier.types = vector::make(NamedParameter)
        for var i in 0..vector::length(node.value.identifier.args) {
            let arg = node.value.identifier.args(i)
            let tpe = type_lookup(arg, state, null, true)
            node.value.identifier.types.push([
                _tpe = tpe
            ] !NamedParameter)
        }
    }
}

def get_value(node: &parser::Node, state: &State, force_compile: bool = true, dry_run: bool = false) -> &scope::Value {
    var value = scope::get(state.scope, node, force_compile = force_compile, dry_run = dry_run) !&scope::Value
    if not value and state.current_function().is_closure {
        let len = state.function_stack.length
        for var i in 0..len {
            var current_fun = state.function_stack(len - i - 1)
            value = scope::get(current_fun.inner_scope, node, force_compile = force_compile, dry_run = dry_run)
            if value {
                for var j in (len - i - 1)..len {
                    node.svalue = null
                    let parent_function = state.function_stack(j)
                    if parent_function.captures and scope::get(parent_function.inner_scope, node, force_compile = force_compile, dry_run = dry_run) == null {
                        var modifier = parser::VarDecl::LET
                        if value.modifier == parser::VarDecl::CONST {
                            modifier = parser::VarDecl::CONST
                        } else {
                            let new_value_ref = scope::create_variable(
                                parent_function.inner_scope, parser::make_identifier("__ref." + value.name), parser::ShareMarker::NONE,
                                parser::VarDecl::LET, pointer(value.tpe), null
                            )
                            parent_function.captures.push(new_value_ref)
                        }

                        let new_value = scope::create_variable(
                            parent_function.inner_scope, node, parser::ShareMarker::NONE,
                            modifier, value.tpe, null
                        )

                        if modifier == parser::VarDecl::CONST {
                            new_value.value = value.value
                        }
                        if modifier != parser::VarDecl::CONST or value.tpe.kind == TypeKind::CLOSURE {
                            parent_function.captures.push(new_value)   
                        }

                        new_value.is_capture = true
                        value = new_value
                    }
                }
                break
            }
        }
    }
    return value
}

def walk_Identifier(node: &parser::Node, state: &State) {
    lookup_identifier_types(node, state)
    var value = get_value(node, state)

    if not value {
        errors::errorn(node, "Unknown identifier `", parser::identifier_to_str(node), "`")
        scope::create_dependency_on_type(state.current_value(), node)
        return
    }

    scope::create_dependency(state.current_value(), value)
    scope::add_reference(value, node)

    if value.tpe and value.tpe.kind == TypeKind::TYPE {
        let tpe = copy(builtins::Type_) // TODO Use TypeKind::Type
        tpe._tpe = value.value.value_tpe
        node.tpe = pointer(tpe)
    } else {
        node.tpe = value.tpe
    }

    node.svalue = value
    node.kw = value.modifier
    
    if is_function(node.tpe) and 
        (@node.parent).kind != parser::NodeKind::FUNC_CALL and
        (@node.parent).kind != parser::NodeKind::PTR {

        let parent = node.parent
        let old_node = parser::copy_node(node)
        old_node.tpe = flatten_return_type(old_node, node.tpe.return_t)

        @node = [
            kind = parser::NodeKind::FUNC_CALL,
            loc = node.loc,
            parent = node.parent,
            scope = node.scope
        ] !parser::Node
        node.value.func_call = [
            left = old_node,
            args = vector::make(type &parser::Node),
            kwargs = vector::make(type &parser::Node)
        ] !parser::NodeFuncCall
        walk(parent, node, state)
    }
}

def implicit_conversion(node: &parser::Node, tpe: &Type, state: &State) {
    if not tpe { return }
    // Convert type
    if node.tpe and node.tpe.may_be_type {
        node.tpe = node.tpe.may_be_type
    } else if node.kind == parser::NodeKind::NULL and is_pointer(tpe) or
        is_arithmetic(tpe) and (node.kind == parser::NodeKind::INTEGER or
        (node.kind == parser::NodeKind::USUB or node.kind == parser::NodeKind::UADD) and 
        (@node.value.expr).kind == parser::NodeKind::INTEGER) {

        // TODO For integers we need to check the boundaries
        // TODO What about stuff like --10? I mean its kinda useless but for completeness

        node.tpe = tpe
    } else if is_function_pointer(tpe) and 
        node.kind == parser::NodeKind::PTR and 
        node.value.expr and node.value.expr.kind == parser::NodeKind::IDENTIFIER {
        node.tpe = tpe
    } else if not state.block_implicit_conv and node.tpe and not equals(node.tpe, tpe) {
        if convert_type_score(tpe, node.tpe, state.module) == IMPLICIT {
            let child = parser::copy_node(node)
            @node = [ kind = parser::NodeKind::CAST, loc = node.loc ] !parser::Node
            node.value.bin_op = [ left = child ] !parser::NodeBinaryOp
            node.tpe = tpe
        }
    }
}

def infer_struct_type(node: &parser::Node, tpe: &Type) {
    if node.kind != parser::NodeKind::STRUCT_LIT { return }
    if not tpe { return }
    //if not (is_struct(tpe) or is_ref(tpe) and is_struct(tpe.tpe)) {
    //    errors::errorn(node, "Incompatible types ", debug::type_to_str(tpe), " is not a structure type")
    //   return
    //}
    if is_ref(tpe) {
        node.tpe = tpe.tpe
    } else {
        node.tpe = tpe
    }
}

def infer_lambda_parameter_types(node: &parser::Node, tpe: &Type, state: &State) -> bool {
    let ftpe = node.value.lambda.closure_type

    if tpe.parameter_t.length != ftpe.parameter_t.length {
        errors::errorn(node, "Can't assign lambda, parameter length mismatch, got ", 
            to_string(ftpe.parameter_t.length), " parameters, expected ", to_string(tpe.parameter_t.length))
        return false
    }

    // Replace to_infer types
    for var i in 0..ftpe.parameter_t.length {
        let ftpe_n = ftpe.parameter_t(i).tpe
        let expected = tpe.parameter_t(i).tpe

        if ftpe_n and ftpe_n.kind == TypeKind::TO_INFER {
            @ftpe_n = @expected
        }
    }

    ftpe.return_t.add_all(tpe.return_t)

    return true
}

def check_lambda_return_type(node: &parser::Node, tpe: &Type, state: &State) {
    let ftpe = node.value.lambda.closure_type

    if tpe.return_t.length > 0 {
        if ftpe.return_t.length < 1 {
            errors::errorn(node, "Can't assign lambda, expected a return type of ",
                debug::type_to_str(tpe.return_t(0)), " and lambda doesn't return a value")
        } else if not is_assignable(tpe.return_t(0), ftpe.return_t(0), state.module) {
            errors::errorn(node, "Can't assign lambda, wrong return type. Expected ", 
                debug::type_to_str(tpe.return_t(0)), " got ", debug::type_to_str(ftpe.return_t(0)))
        }
    } else {
        if ftpe.return_t.length > 0 and tpe.return_t.length > 0 {
            errors::errorn(node, "Can't assign lambda, expected no return type but lambda returns ", 
                debug::type_to_str(tpe.return_t(0)))
        }
    }
}

def walk_lambda(value: &parser::Node, ltpe: &Type, state: &State) -> bool {
    if value and value.kind == parser::NodeKind::LAMBDA and ltpe {
        // Infer type for lambda
        walk_Lambda(value, state)
        if value.value.lambda.function.is_typechecked { return true }

        if infer_lambda_parameter_types(value, ltpe, state) {
            walk_Lambda_body(value, state)
            check_lambda_return_type(value, ltpe, state)
        }
        return true
    }
    return false
}

def collapse_types(
    node: &parser::Node, ltypes: &Vector(&Type), 
    right: &Vector(&parser::Node), state: &State, 
    left: &Vector(&parser::Node) = null
) -> &Vector(&Type) {
    let rtypes = vector::make(type &Type)
    var k = 0
    for var i in 0..vector::length(right) {
        let value = right(i)
        if not value { continue }

        var ltpe: &Type = null
        if k < vector::length(ltypes) {
            ltpe = ltypes(k)
            infer_struct_type(value, ltpe)
        }

        if not value.is_assign_right {
            let cond = left and i < left.length and node.parent.kind == parser::NodeKind::PROGRAM
            var current_value: &scope::Value
            if cond {
                let l = left(i)
                let current_value = state.current_value
                state.current_variable = l.value.id_decl.value.svalue
            }

            if not walk_lambda(value, ltpe, state) {
                walk(node, value, state)
            }

            if cond {
                state.current_variable = current_value
            }
        }

        let rtpe = (@value).tpe
        if rtpe and (@rtpe).kind == TypeKind::TUPLE and (not left or left.length > 1) {
            for var j in 0..vector::length((@rtpe).return_t) {
                let t = (@rtpe).return_t(j)
                rtypes.push(t)
                k += 1
            }
        } else {
            implicit_conversion(value, ltpe, state)
            rtypes.push(value.tpe)
            k += 1
        }
    }
    return rtypes
}

def walk_Assign(node: &parser::Node, state: &State) {
    let left = node.value.assign.left
    let right = node.value.assign.right

    let ltypes = vector::make(type &Type)
    for var i in 0..vector::length(left) {
        let l = left(i)
        if not l { continue }
        if l.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(l) == "_" {
            l.is_initializer = true
        } else {
            walk(node, l, state)
        }
        ltypes.push(l.tpe)
    }
    let rtypes = collapse_types(node, ltypes, right, state)

    if vector::length(ltypes) != vector::length(rtypes) {
        errors::errorn(node, "Unbalanced assignment")
        return
    }

    for var i in 0..vector::length(left) {
        let l = left(i)
        if not l { continue }
        var rtpe = rtypes(i)

        if l.kind == parser::NodeKind::MEMBER_ACCESS {
            // Check for overloaded assignment
            let value = l.value.bin_op.left
            let name = l.value.bin_op.right
            if not value or not name or name.kind != parser::NodeKind::IDENTIFIER { continue }

            let args = vector::make(NamedParameter)
            args.push([ _tpe = value.tpe ] !NamedParameter)
            args.push([ _tpe = rtpe ] !NamedParameter)

            let ident = parser::make_identifier("__set_" + parser::identifier_to_str(name) + "__")
            let fun = scope::get_function(state.scope, ident, args, false, true, force_compile = not consteval::is_static)
            if fun {
                compile_function(*fun, state.scope, args)
            }
        }

        var ltpe = l.tpe
        if not check_is_identifier_assignable(l, state) {
            continue
        }

        if l.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(l) == "_" {
            ltpe = rtpe
            l.tpe = rtpe
            l.svalue = scope::create_underscore(state.scope, l, rtpe)
        }

        if not ltpe or not rtpe { continue }
        if not is_assignable(ltpe, rtpe, state.module) {
            errors::errorn(l, "Incompatible types, can't assign ", debug::type_to_str(rtpe), " to ", debug::type_to_str(ltpe))
        }
    }
    if ltypes.length > 0 {
        node.tpe = vector::peek(ltypes)
    }
}

export def walk_top_VarDecl(node: &parser::Node, state: &State, set_constant: bool = false) {
    let current_signature = errors::current_signature
    errors::current_signature = node.signature_hash
    defer errors::current_signature = current_signature

    walk_VarDecl(node, state, set_constant)
}

// This is getting called from consteval for constants
export def walk_VarDecl(node: &parser::Node, state: &State, set_constant: bool = false) {
    let share = node.value.var_decl.share
    let kw = node.value.var_decl.kw
    let left = node.value.var_decl.left
    let right = node.value.var_decl.right
    let extern = node.value.var_decl.extern
    let parent = node.parent

    if kw == parser::VarDecl::CONST and not set_constant {
        for var i in 0..vector::length(left) {
            let id = left(i)
            assert(id.kind == parser::NodeKind::ID_DECL)
            
            let ident = id.value.id_decl.value
            ident.svalue = scope::get(state.scope, ident)
        }
        return 
    }

    let function = current_function(state)
    if not function.is_global {
        if share != parser::ShareMarker::NONE {
            errors::errorn(node, "Can't share non top level variable")
        }
    }

    let ltypes = vector::make(type &Type)
    for var i in 0..vector::length(left) {
        let l = left(i)
        if l.kind == parser::NodeKind::ID_DECL {
            let tpe_node = l.value.id_decl.tpe
            let ident = l.value.id_decl.value
            if not ident { 
                ltypes.push(null)
                continue 
            }

            let current_variable = state.current_variable
            if node.parent.kind == parser::NodeKind::PROGRAM {
                state.current_variable = ident.svalue
            }

            if tpe_node {
                let tpe = type_lookup(tpe_node, state)
                ltypes.push(tpe)
            } else {
                ltypes.push(null)
            }
            state.current_variable = current_variable
        } else {
            let n = l.value.expr
            walk(l, n, state)
            ltypes.push((@n).tpe)
        }
    }

    // Remove node that we are currently traversing to avoid recursing infinitely
    for var i in 0..vector::length(left) {
        let l = left(i)
        if l.kind == parser::NodeKind::ID_DECL {
            let ident = l.value.id_decl.value
            if l.svalue {
                l.svalue.state = null
            }
        }
    }

    let rtypes = collapse_types(node, ltypes, right, state, left)
    	
    var balanced = true
    if (kw == parser::VarDecl::CONST or 
        kw == parser::VarDecl::LET) and 
        vector::length(ltypes) != vector::length(rtypes) {
        
        errors::errorn(node, "Unbalanced assignment")
        balanced = false
    }

    for var i in 0..vector::length(left) {
        var ltpe = ltypes(i)

        let node = left(i)
        if node.kind == parser::NodeKind::ID_DECL {
            if not ltpe and i < vector::length(rtypes) {
                ltpe = rtypes(i)
            }
            if balanced and not ltpe and i >= vector::length(rtypes) {
                errors::errorn(node, "Need to specify a type")
            }

            let ident = node.value.id_decl.value
            if not ident { continue }
            let is_underscore = scope::last_path_element(ident) == "_"

            var rtpe: &Type = null
            if i < vector::length(rtypes) {
                rtpe = rtypes(i)
                
                if is_underscore {
                    ltpe = rtpe
                } else if not is_assignable(ltpe, rtpe, state.module) {
                    errors::errorn(node, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
                } else if ltpe and ltpe.kind == TypeKind::STATIC_ARRAY and ltpe.length == std::MAX_UINT64 {
                    ltpe.length = rtpe.length
                    ltpe.size = rtpe.size
                }
                if rtpe and rtpe.kind == TypeKind::TYPE_CONSTRUCTOR {
                    errors::errorn(node, "Can't use type constructor as variable type")
                    ltpe = null
                }
            }

            if not rtpe and ltpe and ltpe.kind == TypeKind::STATIC_ARRAY and ltpe.length == std::MAX_UINT64 {
                errors::errorn(node, "Array size indeterminate")
            }

            ident.scope = state.scope
            ident.tpe = ltpe

            if ltpe and ltpe.kind == typechecking::TypeKind::STUB {
                errors::errorn(node, "Can't resolve type of expression")
            }

            if is_underscore {
                ident.svalue = scope::create_underscore(state.scope, ident, ltpe)
            } else {
                ident.svalue = scope::create_variable(state.scope, ident, share, kw, ltpe, extern, null)
            }

            scope::add_reference(ident.svalue, ident)

        } else {
            let n = node.value.expr
            if not check_is_identifier_assignable(n, state) {
                continue
            }

            if i >= vector::length(rtypes) {
                errors::errorn(node, "Must assign a value")
                continue
            }
            let rtpe = rtypes(i)

            if node.kind == parser::NodeKind::IDENTIFIER and scope::last_path_element(node) == "_" {
                ltpe = rtpe
                node.tpe = rtpe
                node.svalue = scope::create_underscore(state.scope, node, rtpe)
            }

            if not ltpe or not rtpe { continue }
            if not is_assignable(ltpe, rtpe, state.module) {
                errors::errorn(node, "Incompatible types ", debug::type_to_str(rtpe), " and ", debug::type_to_str(ltpe))
            }
        }
    }
}

def walk_Not(node: &parser::Node, state: &State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }
    if not is_boolean(tpe, state.module) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }
    node.tpe = tpe
}

def walk_BNot(node: &parser::Node, state: &State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }

    let args = vector::make(NamedParameter)
    args.push([
        _tpe = tpe
    ] !NamedParameter)
    convert_to_call(node, "__invert__", args, state)

    if node.kind != parser::NodeKind::FUNC_CALL and not is_integer(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be integer type")
    }
    node.tpe = tpe
}

def walk_UAdd(node: &parser::Node, state: &State) {
    walk(node, node.value.expr, state)
    if not node.value.expr { return }
    let tpe = (@node.value.expr).tpe
    if not tpe { return }

    let args = vector::make(NamedParameter)
    args.push([
        _tpe = tpe
    ] !NamedParameter)
    convert_to_call(node, "__pos__", args, state)

    if node.kind != parser::NodeKind::FUNC_CALL and not is_arithmetic(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be arithmetic type")
    }
    node.tpe = tpe
}

def walk_USub(node: &parser::Node, state: &State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }

    let args = vector::make(NamedParameter)
    args.push([ _tpe = tpe ] !NamedParameter)
    convert_to_call(node, "__neg__", args, state)

    if node.kind != parser::NodeKind::FUNC_CALL and not is_arithmetic(tpe) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be arithmetic type")
    }
    node.tpe = tpe
}

def make_function_call(node: &parser::Node, ident: &parser::Node) -> &parser::Node {
    let args = vector::make(type &parser::Node)
    args.push(node.value.bin_op.left)
    args.push(node.value.bin_op.right)

    return make_function_call(node, ident, args)
}

def make_function_call(node: &parser::Node, ident: &parser::Node, args: &Vector(&parser::Node)) -> &Node {
    let function = [
        kind = parser::NodeKind::FUNC_CALL,
        loc = node.loc
    ] !&parser::Node
    function.value.func_call = [
        left = ident,
        args = args,
        kwargs = vector::make(type &parser::Node)
    ] !parser::NodeFuncCall
    function.parent = node.parent
    function.scope = node.scope

    return function
}

def convert_to_call(node: &parser::Node, name: Str, args: &Vector(NamedParameter), state: &State) {
    let ident = parser::make_identifier(name)
    let fun = scope::get_function(state.scope, ident, args, false, true, force_compile = not consteval::is_static)
    if fun {
        compile_function(*fun, state.scope, args)
        let parent = node.parent
        @node = @make_function_call(node, ident)
        consteval::walk_Call(node, state)
        let bic = state.block_implicit_conv
        state.block_implicit_conv = true
        walk(parent, node, state)
        state.block_implicit_conv = bic
    }
}

def convert_to_icall(node: &parser::Node, name: Str, args: &Vector(NamedParameter), state: &State) {
    let ident = parser::make_identifier(name)
    let fun = scope::get_function(state.scope, ident, args, false, true, force_compile = not consteval::is_static)
    if fun { 
        compile_function(*fun, state.scope, args)

        let parent = node.parent
        var assign = [
            kind = parser::NodeKind::ASSIGN,
            loc = node.loc
        ] !&parser::Node
        let left = vector::make(type &parser::Node)
        let right = vector::make(type &parser::Node)
        assign.value.assign = [
            left = left,
            right = right
        ] !parser::NodeAssign
        assign.scope = node.scope
        assign.parent = node.parent

        vector::push(right, make_function_call(node, ident))
        left.push(node.value.bin_op.left)
        @node = @assign
        let bic = state.block_implicit_conv
        state.block_implicit_conv = true
        walk(parent, node, state)
        state.block_implicit_conv = bic
    }
}

def create_args(left: &parser::Node, right: &parser::Node) -> &Vector(NamedParameter) {
    let args = vector::make(NamedParameter)
    args.push([ _tpe = left.tpe  if left  else null ] !NamedParameter)
    args.push([ _tpe = right.tpe if right else null ] !NamedParameter)
    return args
}

def walk_ArithmeticOp(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    node.tpe = common_type((@left).tpe, (@right).tpe)

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::ADD
            convert_to_call(node, "__add__", args, state)
        case parser::NodeKind::SUB
            convert_to_call(node, "__sub__", args, state)
        case parser::NodeKind::MUL
            convert_to_call(node, "__mul__", args, state)
        case parser::NodeKind::DIV
            convert_to_call(node, "__div__", args, state)
        case parser::NodeKind::MOD
            convert_to_call(node, "__mod__", args, state)
    }

    if not node.tpe {
        // TODO better error message
        errors::errorn(node, "Invalid operation")
    }
}
    

def walk_BitwiseOp(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    node.tpe = common_type((@left).tpe, (@right).tpe)

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::BAND
            convert_to_call(node, "__and__", args, state)
        case parser::NodeKind::BOR
            convert_to_call(node, "__or__", args, state)
        case parser::NodeKind::BXOR
            convert_to_call(node, "__xor__", args, state)
        case parser::NodeKind::SHR
            convert_to_call(node, "__rshift__", args, state)
        case parser::NodeKind::SHL
            convert_to_call(node, "__lshift__", args, state)
    }

    if node.kind != parser::NodeKind::FUNC_CALL {
        if not is_integer((@left).tpe) or not is_integer((@right).tpe) {
            errors::errorn(node, "Invalid operands of type ", debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to bitwise operator")
        }
    }
}

def walk_BooleanOp(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }
    
    walk(node, left, state)
    walk(node, right, state)

    if not (@left).tpe or not (@right).tpe { return }
    if not is_boolean((@left).tpe, state.module) or not is_boolean((@right).tpe, state.module) {
        errors::errorn(node, "Invalid operands of type ", debug::type_to_str((@left).tpe), " and ", debug::type_to_str((@right).tpe), " to boolean operator")
    }

    node.tpe = builtins::bool_
}

// TODO implicit conversions here too
def walk_AssignEqArithmetic(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::ADD_EQ
            convert_to_icall(node, "__iadd__", args, state)
        case parser::NodeKind::SUB_EQ
            convert_to_icall(node, "__isub__", args, state)
        case parser::NodeKind::MUL_EQ
            convert_to_icall(node, "__imul__", args, state)
        case parser::NodeKind::DIV_EQ
            convert_to_icall(node, "__idiv__", args, state)
        case parser::NodeKind::MOD_EQ
            convert_to_icall(node, "__imod__", args, state)
    } 

    if node.kind != parser::NodeKind::ASSIGN {
        if not is_arithmetic((@right).tpe) {
            errors::errorn(right, "Incompatible type, expected arithmetic type, got ", debug::type_to_str((@right).tpe))
        }
        if not is_arithmetic((@left).tpe) {
            errors::errorn(right, "Incompatible type, expected arithmetic type, got ", debug::type_to_str((@left).tpe))
        }
        node.tpe = (@left).tpe
    }
}

def walk_AssignEqBitwise(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }

    let args = create_args(left, right)
    switch node.kind {
        case parser::NodeKind::AND_EQ
            convert_to_icall(node, "__iand__", args, state)
        case parser::NodeKind::OR_EQ
            convert_to_icall(node, "__ior__", args, state)
        case parser::NodeKind::XOR_EQ
            convert_to_icall(node, "__ixor__", args, state)
        case parser::NodeKind::SHL_EQ
            convert_to_icall(node, "__ilshift__", args, state)
        case parser::NodeKind::SHR_EQ
            convert_to_icall(node, "__irshift__", args, state)
    } 

    if node.kind != parser::NodeKind::ASSIGN {
        if not is_integer((@right).tpe) {
            errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@right).tpe))
        }
        if not is_integer((@left).tpe) {
            errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@left).tpe))
        }

        node.tpe = (@left).tpe
    }
}

def walk_AssignEqPtr(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }

    walk(node, left, state)
    walk(node, right, state)
    if not check_is_identifier_assignable(left, state) {
        return
    }

    if not (@left).tpe or not (@right).tpe { return }
    if not is_integer((@right).tpe) {
        errors::errorn(right, "Incompatible type, expected integer type, got ", debug::type_to_str((@right).tpe))
    }
    if not is_pointer((@left).tpe) {
        errors::errorn(right, "Incompatible type, expected pointer type, got ", debug::type_to_str((@left).tpe))
    }

    node.tpe = (@left).tpe
}

def walk_Cast(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left or not right { return }
    
    right.parent = node
    var rtpe = type_lookup(right, state)

    if not rtpe { return }
    if rtpe.kind == TypeKind::TYPE_CONSTRUCTOR {
        errors::errorn(right, "Can't cast to type constructor")
        return
    }

    if left.kind == parser::NodeKind::STRUCT_LIT {
        if rtpe.kind != TypeKind::STRUCT and
            rtpe.kind != TypeKind::UNION and
            rtpe.kind != TypeKind::STATIC_ARRAY and
            rtpe.kind != TypeKind::ARRAY and
            not (rtpe.kind == TypeKind::REFERENCE and rtpe.tpe and 
                (rtpe.tpe.kind == TypeKind::STRUCT or 
                 rtpe.tpe.kind == TypeKind::UNION or
                 rtpe.tpe.kind == TypeKind::TUPLE or 
                 rtpe.tpe.kind == TypeKind::STATIC_ARRAY or
                 rtpe.tpe.kind == TypeKind::ARRAY)) {

            errors::errorn(left, "Invalid cast")
            return
        }
        node.tpe = left.tpe = rtpe
        walk(node, left, state)
        return
    }
    /*if (@left).kind == parser::NodeKind::ARRAY_LIT {
        if (@rtpe).kind != TypeKind::ARRAY and 
            (@rtpe).kind != TypeKind::STATIC_ARRAY {
            errors::errorn(left, "Invalid cast")
            return
        }
        walk(node, left, state)
        node.tpe = rtpe
        return
    }*/

    walk(node, left, state)
    var ltpe = left.tpe
    if not ltpe { return }

    if left.kind == parser::NodeKind::INTEGER and 
        is_integer(ltpe) and is_integer(rtpe) {
        left.tpe = rtpe
    }

    if equals(ltpe, rtpe) or (equals(ltpe, builtins::Ref_) and (is_ref(rtpe) or is_weak_ref(rtpe))) {
    } else if ltpe.kind == TypeKind::TUNION {
        if not (ltpe.variants.contains(rtpe)) {
            errors::errorn(left, "Invalid cast")
            return
        }
    } else if equals(rtpe, builtins::Ref_) {
        if not (is_ref(ltpe) or is_weak_ref(ltpe)) {
            errors::errorn(left, "Invalid cast")
            return
        }
    } else if is_struct(ltpe) or is_struct(rtpe) {
        if ltpe.kind != rtpe.kind and not is_ref(rtpe) { 
            errors::errorn(left, "Invalid cast") 
            return
        }
    } else if is_struct(ltpe) and is_struct(rtpe) {
        if not equals(ltpe, rtpe) { 
            errors::errorn(left, "Invalid cast") 
            return
        }
    }

    if not node.tpe {
        node.tpe = rtpe
    }

    var initial_ltpe = copy(left.tpe)
    ltpe = initial_ltpe

    while ltpe and rtpe and ltpe.kind == rtpe.kind and is_box(ltpe) {            
        ltpe = ltpe.tpe
        rtpe = rtpe.tpe
    }

    if ltpe and rtpe and rtpe.tc_args {
        node.tpe = initial_ltpe
        ltpe.tc_args = rtpe.tc_args
        ltpe.tc_tpe = rtpe.tc_tpe
    } 
}

def walk_Import(node: &parser::Node, state: &State) {
    if not current_function(state).is_global {
        errors::errorn(node, "Can only import at top level")
        return
    }

    let imports = node.value.body
    for var i in 0..vector::length(imports) {
        let imprt = imports(i)
        var name = (@imprt).value.import_module.name
        if not name { return }
        toolchain::typecheck_module(name, state.module)
        toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)
    }
}

def put_type_defs(tpe: &Type, parameter_types: &SSet) {
    if not tpe { return }
    if tpe.kind == TypeKind::TYPE_DEF or tpe.kind == TypeKind::TYPE {
        parameter_types.add(tpe.name)
    } else if tpe.kind == TypeKind::POINTER or
        tpe.kind == TypeKind::REFERENCE or
        tpe.kind == TypeKind::STATIC_ARRAY or
        tpe.kind == TypeKind::ARRAY {
        put_type_defs(tpe.tpe, parameter_types)
    } else if tpe.kind == TypeKind::GENERIC {
        for var i in 0..vector::length(tpe.tc_args) {
            let arg = tpe.tc_args(i)
            put_type_defs(arg, parameter_types)
        }
    }
}

// Redefine function parameters to get rid of the stub types
export def lookup_parameters(node: &parser::Node, state: &State) -> &Type {
    let share = node.value.def_.share
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let test = node.value.def_.test
    let tpe = node.tpe

    if not tpe { return null }
    if not params or not returns { return tpe }
    if node.value.def_.has_lookup { return tpe }
    node.value.def_.has_lookup = true

    for var i in 0..vector::length(params) {
        let param = params(i)
        if not param { continue }
        if i >= tpe.parameter_t.length { continue }
        let named = tpe.parameter_t.get(i)

        if not named.tpe or named.tpe.kind != TypeKind::TYPE {
            var new_type: &Type
            if param.value.param.is_ref {
                new_type = typechecking::byref(type_lookup(param.value.param.tpe, state, named.tpe.tpe, false))
            } else {
                new_type = type_lookup(param.value.param.tpe, state, named.tpe, false)
            }

            if new_type {
                //generate_ctor_and_dtor(new_type)
                @named.tpe = @new_type
                param.value.param.tpe.tpe = named.tpe
            }
        }
    }
    for var i in 0..vector::length(returns) {
        let n = returns(i)
        let current_return_type = tpe.return_t(i)
        let new_type = type_lookup(n, state, current_return_type, false)
        if new_type {
            //generate_ctor_and_dtor(new_type)
            @current_return_type = @new_type
            n.tpe = current_return_type
        }
    }

    tpe.type_name = mangle_function_name(append_module(tpe.name, tpe.module.module), tpe.parameter_t, test, tpe.context)
    node.tpe = tpe

    return tpe
}

def check_is_valid_function(ident: &parser::Node, par: &Vector(NamedParameter), state: &State) {
    let name = parser::identifier_to_str(ident)
    if name == "destruct" {
        if vector::length(par) != 1 {
            errors::errorn(ident, "Destructor takes exactly one parameter of a pointer type")
            return
        }
        let first = (par(0)).tpe
        if not first or first.kind != TypeKind::POINTER {
            errors::errorn(ident, "Destructor takes exactly one parameter of a pointer type")
            return
        }
        // TODO This is a useful restriction but its problematic with polymorphic types
        /*if not first.tpe or first.tpe.module != state.module {
            errors::errorn(ident, "Argument type needs to be defined in the same file as the destructor")
            return
        }*/
    } else if name == "construct" {
        if vector::length(par) != 2 {
            errors::errorn(ident, "Copy constructor takes exactly two parameters of the same pointer type")
            return
        }
        let first = (par(0)).tpe
        let second = (par(1)).tpe
        if first.kind != TypeKind::POINTER or not equals(first, second) {
            errors::errorn(ident, "Copy constructor takes two parameters of the same pointer type")
            return
        }
        /*if not first.tpe or first.tpe.module != state.module {
            errors::errorn(ident, "Argument types need to be defined in the same file as the copy constructor")
            return
        }*/
    }
}

def make_closure_type(name: &parser::Node, parameter_t: &Vector(NamedParameter), return_t: &Vector(&Type)) -> &Type {
    let types = allocate_ref(StructMember, 2)
    types(0) = [ tpe = pointer(make_function_type_n(name, parameter_t, return_t)), name = "function" ] !StructMember
    types(1) = [ tpe = reference(null), name = "data"] !StructMember
    let closure_type = make_struct_type(types)
    closure_type.kind = TypeKind::CLOSURE
    closure_type.parameter_t = vector::make(NamedParameter)
    closure_type.return_t = vector::make(type &typechecking::Type)
    return closure_type
}

export def walk_Lambda(node: &parser::Node, state: &State) {
    let params = node.value.lambda.parameters
    let outer_scope = node.scope
    let inner_scope = node.inner_scope

    var tpe: &Type
    var closure_type: &Type

    let parameter_t = vector::make(NamedParameter)
    var return_t = vector::make(type &Type)

    let ident = parser::make_identifier(state.function_stack.peek().unmangled + "#lambda." + lambda_counter)
    closure_type = make_closure_type(ident, parameter_t, return_t)
    closure_type.is_anon = true
    lambda_counter += 1

    let c_parameter_t = closure_type.parameter_t
    return_t = closure_type.return_t

    // Need to store a strong reference
    node.value.lambda.closure_type = closure_type
    
    // State argument
    parameter_t.push([ name = "__state", _tpe = reference(null) ] !NamedParameter)

    var needs_inference = false
    for var i in 0..params.length {
        let param = params(i)

        let name = param.value.param.name
        var tpe: &Type
        if param.value.param.tpe {
            tpe = typechecking::type_lookup(param.value.param.tpe, state, null, true)
        } else {
            // Place type placeholder for inference
            tpe = make_type_raw(TypeKind::TO_INFER)
            needs_inference = true
        }

        let np = [
            name = last_ident_to_str(name),
            node = name,
            _tpe = tpe
        ] !NamedParameter
        parameter_t.push(np)
        c_parameter_t.push(np)
    }

    // Create function type
    tpe = make_function_type()
    tpe.parameter_t = parameter_t
    tpe.return_t = return_t
    tpe.node = node
    tpe.name = parser::identifier_to_str(ident, false)
    tpe.type_name = tpe.name
    tpe.line = node.loc.line
    tpe.module = state.module

    let function = [
        tpe = tpe,
        module = state.module,
        locals = map::make(type &Type),
        unmangled = tpe.name,
        is_closure = true,
        scope = state.scope,
        inner_scope = inner_scope,
        captures = vector::make(type weak &scope::Value)
    ] !&compiler::Function
    node.value.lambda.function = function

    node.tpe = closure_type

    if not needs_inference {
        walk_Lambda_body(node, state)
        function.is_typechecked = true
    }
}

// We can only go into the body once the types are figured out
def walk_Lambda_body(node: &parser::Node, state: &State) {
    let body = node.value.lambda.body
    let inner_scope = node.inner_scope
    let outer_scope = node.scope
    let function = node.value.lambda.function

    let tpe = function.tpe
    if function.is_typechecked { return }

    // State parameter
    let value = scope::create_variable(inner_scope, parser::make_identifier("__state"), parser::ShareMarker::NONE, parser::VarDecl::VAR, reference(null), null)

    // Create parameters
    for var i in 0..tpe.parameter_t.length - 1 {
        let np = tpe.parameter_t(i + 1)
        if not np.node { continue }
        var tpe2 = np.tpe
        if tpe2 and tpe2.kind == TypeKind::TO_INFER {
            errors::errorn(np.node, "Couldn't infer type for lambda parameter")
            node.value.lambda.function = null // So that this doesn't make it to compile
            return
        }

        let value = scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, tpe2, null)
        np.node.svalue = value
    }

    state.scope = inner_scope
    push_function(state, function)
    let prev_lambda = state.current_lambda
    state.current_lambda = tpe

    var global_scope = state.scope.parent
    while not scope::is_global(global_scope) {
        global_scope = global_scope.parent 
    }

    let body_copy = vector::copy(body)
    for var i in 0..vector::length(body_copy) {
        // Eval constant expressions
        consteval::walk(node, body_copy(i), state)
    }
    for var i in 0..vector::length(body) {
        let inner = body(i)
        // Create scopes for inner functions
        if inner.kind == parser::NodeKind::DEF {
            inner.scope = state.scope
            inner.inner_scope = scope::enter_function_scope(global_scope)
        }
        walk(node, inner, state)
    }

    pop_function(state)
    state.scope = outer_scope

    let members = allocate_ref(StructMember, function.captures.length)
    for var i in 0..function.captures.length {
        members(i) = [ name = to_string(i), tpe = function.captures(i).tpe ] !StructMember
    }

    function.state = make_struct_type(members)
    function.state.name = function.unmangled + ".context"
    function.state.type_name = append_module(function.state.name, state.module.module)

    // We need to do this here again
    if vector::length(tpe.parameter_t) > 0 {
        let first_param = tpe.parameter_t(0)
        create_type_entry(first_param.tpe, false, tpe, state.module, overwrite = true)
    }

    state.current_lambda = prev_lambda
}

export def walk_Def(node: &parser::Node, state: &State, polymorph: bool = false) {
    node.value.def_.is_compiled = true

    let share = node.value.def_.share
    let body = node.value.def_.body
    let name = node.value.def_.name
    let params = node.value.def_.params
    let returns = node.value.def_.returns
    let extern = node.value.def_.extern
    let dllimport = node.value.def_.dllimport
    let dllexport = node.value.def_.dllexport
    let impl = node.value.def_.impl
    let test = node.value.def_.test
    var outer_scope = state.context if state.context else node.scope
    let inner_scope = node.inner_scope
    let imported = (share !int & parser::ShareMarker::IMPORT !int) !bool

    if not name or not params or not returns { return }
    var function = node.value.def_.function
    if function {
        if function.is_typechecked { return }
        function.is_typechecked = true
    }

    // So that returns don't confuse lambda functions with written out function definitions
    let prev_lambda = state.current_lambda
    state.current_lambda = null

    let is_closure = state.function_stack.length > 1 // Main function is 0

    var tpe: &Type
    var closure_type: &Type
    var state_node = parser::make_identifier("__state") // This is needed for ref counting reasons
    let current_function = errors::current_function
    let current_signature = errors::current_signature

    if is_closure {
        let parameter_t = vector::make(NamedParameter)
        var return_t = vector::make(type &Type)

        closure_type = make_closure_type(name, parameter_t, return_t)
        let c_parameter_t = closure_type.parameter_t
        let c_return_t = closure_type.return_t

        // Need to store a strong reference
        node.value.def_.closure_type = closure_type

        if dllimport or extern or share != parser::ShareMarker::NONE {
            errors::errorn(name, "Invalid modifier to closure")
            return
        }
        
        // State argument
        parameter_t.push([ name = "__state", _tpe = reference(null), node = state_node ] !NamedParameter)

        for var i in 0..params.length {
            let param = params(i)
            assert param.kind == parser::NodeKind::PARAMETER
            if param.value.param.value {
                errors::errorn(param, "Can't have default parameters for closure")
                return
            }
            if param.value.param.varargs {
                errors::errorn(param, "Can't have varargs for closure")
                return
            }
            if param.value.param.kw == parser::VarDecl::TYPE {
                errors::errorn(param, "Can't have type argument in closure")
                return
            }
            // TODO : type T is also not allowed

            let name = param.value.param.name
            let tpe = typechecking::type_lookup(param.value.param.tpe, state, null, true)
            let np = [
                name = last_ident_to_str(name),
                node = name,
                _tpe = tpe
            ] !NamedParameter
            parameter_t.push(np)
            c_parameter_t.push(np)
        }

        for var i in 0..returns.length {
            let tpe = typechecking::type_lookup(returns(i), state, null, true)
            return_t.push(tpe)
            c_return_t.push(tpe)
        }

        let arr = zero_allocate(String, state.function_stack.length)
        for var i in 1..state.function_stack.length {
            arr(i - 1) = state.function_stack(i).unmangled
        }
        arr(state.function_stack.length - 1) = parser::identifier_to_str(name)

        // Unpack tuple
        if node.tpe and node.tpe.return_t and node.tpe.return_t.length == 1 {
            let tuple = node.tpe.return_t(0)
            if tuple and tuple.kind == TypeKind::TUPLE {
                return_t = tuple.return_t
            }
        }

        tpe = make_function_type_n(make_identifier(arr), parameter_t, return_t, state.module)
        tpe.type_name += "." + lambda_counter
        lambda_counter += 1

        delete(arr)
        tpe.node = node
    } else {
        if not node.tpe { return }

        // Unpack tuple
        var return_t = node.tpe.return_t
        if node.tpe.return_t and node.tpe.return_t.length == 1 {
            let tuple = node.tpe.return_t(0)
            if tuple and tuple.kind == TypeKind::TUPLE {
                return_t = tuple.return_t
            }
        }

        tpe = make_function_type_n(name, node.tpe.parameter_t, return_t, state.module, extern, test = test, context = outer_scope.module if polymorph else null)

        tpe.node = node
        check_is_valid_function(name, node.tpe.parameter_t, state)
    } 

    if not function {
        function = [
            tpe = tpe,
            module = outer_scope.module,
            locals = map::make(type &Type),
            unmangled = parser::identifier_to_str(name),
            is_closure = node.parent.kind != parser::NodeKind::PROGRAM,
            scope = state.scope,
            inner_scope = inner_scope,
            captures = vector::make(type weak &scope::Value),
            dllimport = dllimport,
            dllexport = dllexport,
            test = test,
            imported = imported,
            has_yield = node.value.def_.has_yield,
            is_typechecked = true
        ] !&compiler::Function
        node.value.def_.function = function
    } else {
        function.tpe = tpe
    }

    var phase = scope::Phase::DECLARED
    if body {
        phase = scope::Phase::COMPILED
        for var i in 0..vector::length(tpe.parameter_t) {
            let np = tpe.parameter_t(i)
            if not np.node { continue }
            var tpe2 = np.tpe
            if tpe2 {
                if tpe2.kind == TypeKind::TYPE { continue }
                if tpe2.kind == TypeKind::TYPE_CONSTRUCTOR {
                    errors::errorn(np.node, "Can't use type constructor as function argument")
                    np._tpe = null
                }
            }
            if np.varargs {
                if tpe2 {
                    let value = scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, array(tpe2), null)
                    np.node.svalue = value
                }
            } else {
                let value = scope::create_variable(inner_scope, np.node, parser::ShareMarker::NONE, parser::VarDecl::VAR, tpe2, null)
                np.node.svalue = value
            }
        }
        if test {
            scope::create_variable(inner_scope, parser::make_identifier("env"), parser::ShareMarker::NONE, parser::VarDecl::LET, pointer(builtins::TestEnvironment_), null)
        }
    }

    if is_closure {
        tpe.parameter_t.get(0).node = null // TODO This is ugly, maybe NamedParameter should have a strong reference instead?
        function.value = scope::create_variable(outer_scope, name, parser::ShareMarker::NONE, parser::VarDecl::CONST, closure_type, null)
    } else {
        errors::current_function = tpe.type_name
        errors::current_signature = node.signature_hash
        if not function.value {
            if polymorph and parser::identifier_to_str(name) != "construct" {
                function.value = scope::create_polymorph(outer_scope, node.scope, name, tpe, phase, node, consteval::copy_state(state), impl = impl)
            } else {
                function.value = scope::create_function(outer_scope, name, share, tpe, phase, node, consteval::copy_state(state), impl = impl)
            }
            if is_closure { state.module.closures.push(function.value) }
            function.value.polymorph = polymorph
            function.value.imported = imported
        }
        if impl {
            for var i in 0..outer_scope.implicits.length {
                let value = outer_scope.implicits(i)
                if value !* == function.value !* { continue }
                if tpe.parameter_t.length == 1 and 
                    tpe.return_t.length == 1 and
                    equals(value.tpe.parameter_t(0).tpe, tpe.parameter_t(0).tpe) and
                    equals(value.tpe.return_t(0), tpe.return_t(0)) {
                    errors::errorn(name, "Duplicate implicit function")
                }
            }
        }
    }

    for var i in 0..params.length {
        let param = params(i)
        if i >= tpe.parameter_t.length { continue }
        let p = tpe.parameter_t.get(i)

        if p.tpe {
            generate_ctor_and_dtor(p.tpe)
        }

        let value = consteval::evaluate_parameter(node, param, p.tpe, state)
        p.value = value
    }
    
    if body {
        state.scope = inner_scope
        push_function(state, function)

        if function.has_yield {
            let generator_ctor = [
                kind = parser::NodeKind::TYPE_CONSTRUCTOR
            ] !&parser::Node
            generator_ctor.value.type_constructor = [
                name = parser::make_identifier("Generator"),
                args = node.value.def_.returns
            ] !parser::NodeTypeConstructor

            var generator = typechecking::type_lookup(generator_ctor, state)
            tpe.return_t(0) = reference(generator)

            has_destructor(generator)
            has_copy_constructor(generator)
            function.generator_ctor = generator_ctor
        }

        var global_scope = state.scope.parent
        while not scope::is_global(global_scope) {
            global_scope = global_scope.parent 
        }

        let body_copy = vector::copy(body)
        for var i in 0..vector::length(body_copy) {
            // Eval constant expressions
            consteval::walk(node, body_copy(i), state)
        }
        for var i in 0..vector::length(body) {
            let inner = body(i)
            // Create scopes for inner functions
            if inner.kind == parser::NodeKind::DEF {
                inner.scope = state.scope
                inner.inner_scope = scope::enter_function_scope(global_scope)
            }
            walk(node, inner, state)
        }

        pop_function(state)
        state.scope = outer_scope
    }

    if is_closure {
        let members = allocate_ref(StructMember, function.captures.length)
        for var i in 0..function.captures.length {
            members(i) = [ name = to_string(i), tpe = function.captures(i).tpe ] !StructMember
        }

        function.state = make_struct_type(members)
        function.state.name = tpe.type_name + ".context"
        function.state.type_name = append_module(function.state.name, state.module.module)
    }

    // We need to do this here again
    if vector::length(tpe.parameter_t) > 0 {
        let first_param = tpe.parameter_t(0)
        create_type_entry(first_param.tpe, (share !int & parser::ShareMarker::EXPORT !int) != 0, tpe, state.module, overwrite = true)
    }

    errors::current_function = current_function
    errors::current_signature = current_signature
    state.current_lambda = prev_lambda

    node.tpe = tpe
}

def check_is_recursive(tpe: &Type, types: &SMap(&Type) = null) -> bool {
    if not tpe { return false }
    if not types { types = map::make(type &Type) }
    if tpe.kind == TypeKind::STATIC_ARRAY {
        return check_is_recursive(tpe.tpe, types)
    }
    if tpe.kind == TypeKind::STRUCT or tpe.kind == TypeKind::UNION {
        if tpe.name != "<anonymous>" {
            if map::contains(types, tpe.type_name) { return true }
            types(tpe.type_name) = tpe
        }
        for var i in 0..tpe.fields.size {
            let new_types = map::make(type &Type)
            let keys = map::keys(types)
            for var j in 0..keys.size {
                new_types(keys(j)) = types(keys(j))
            }
            if check_is_recursive(tpe.fields(i).tpe, new_types) { return true }
        }
    }
    return false
}

export def walk_TypeDecl(node: &parser::Node, state: &State) {
    let share = node.value.type_decl.share
    let left = node.value.type_decl.left
    let right = node.value.type_decl.right
        
    let current_signature = errors::current_signature
    errors::current_signature = node.signature_hash
    defer errors::current_signature = current_signature

    if vector::length(left) < vector::length(right) {
        errors::errorn(node, "Too many values to assign")
        return
    }

    for var i in 0..vector::length(left) {
        let left = left(i)
        if not left { continue }
        var name = left
        if left.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
            name = left.value.type_constructor.name
        }

        var value: &parser::Node = null
        if i < vector::length(right) {
            value = right(i)
        }

        var tpe = make_type_raw(TypeKind::STUB)
        left.svalue = scope::create_type(state.scope, name, share, tpe, scope::Phase::COMPILED, node, null)
        if value {
            if left.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
                tpe = lookup_type_constructor(left, value, state)
            } else {
                tpe = copy(type_lookup(value, state))
                if tpe and not tpe.tc_args {
                    tpe.module = state.module
                }
            }
            if not tpe { continue }
            tpe._defmodule = state.module

            tpe.share = share
            tpe.name = parser::identifier_to_str(name)
            if value.kind != parser::NodeKind::TYPE_CONSTRUCTOR {
                tpe.type_name = append_module(tpe.name, node.loc.module)
            }
            
            left.svalue = node.svalue = scope::create_type(state.scope, name, share, tpe, scope::Phase::COMPILED, node, null)
        }
        name.tpe = tpe

        if is_static and tpe.kind != typechecking::TypeKind::STUB {
            compiler::create_type(tpe, state.module)
        }
    }
}

def check_return_arguments(is_yield: bool, node: &parser::Node, ltypes: &Vector(&Type), rtypes: &Vector(&Type), state: &State) {
    if vector::length(ltypes) != vector::length(rtypes) {
        // TODO Improve error message
        errors::errorn(node, "Wrong number of arguments to ", "yield" if is_yield else "return")
    }

    for var i in 0..vector::length(ltypes) {
        let argtpe = ltypes(i)
        if i >= vector::length(rtypes) { return }

        var rettpe = rtypes(i)
        
        if not argtpe or not rettpe { continue }
        if not is_assignable(argtpe, rettpe, state.module) {
            // TODO This doesn't point to the actual value
            errors::errorn(node, 
                "Wrong type of ", "yield" if is_yield else "return",
                " argument, got ", debug::type_to_str(rettpe), ", expected ", debug::type_to_str(argtpe)
            )
        }
    }
}

def walk_Return(node: &parser::Node, state: &State) {
    let body = node.value.body

    if state.current_lambda {
        let return_t = state.current_lambda.return_t

        let rtypes = collapse_types(node, return_t, body, state)
        if state.current_lambda.return_t.length != 0 {
            // Check if the types match up
            if return_t.length != rtypes.length {
                errors::errorn(node, "Return types for lambda disagree with previous return statement")
                return
            }
            for var i in 0..return_t.length {
                if not equals(return_t(i), rtypes(i)) {
                    errors::errorn(node, "Return types for lambda disagree with previous return statement")
                    return
                }
            }
        } else {
            state.current_lambda.return_t.add_all(rtypes)
        }
        return
    }

    let current_fun = current_function(state)
    if current_fun.is_global {
        // TODO This is actually allowed, I just need to infer the types
        // and assign to some sort of internal variable
        errors::errorn(node, "return outside of a function")
        return
    }
    if not current_fun.value { return }

    let tpe = current_fun.value.tpe
    let ltypes = tpe.return_t
    let rtypes = collapse_types(node, ltypes, body, state)

    if not current_fun.has_yield {
        check_return_arguments(false, node, ltypes, rtypes, state)
    } else if rtypes.length > 0 {
        let argtpe = tpe.return_t(0).tpe.tc_args(0)
        if not is_assignable(argtpe, rtypes(0), state.module) {
            errors::errorn(node, "Expected 0 return arguments or ", 
                debug::type_to_str(argtpe), " but got ", debug::type_to_str(rtypes(0)))
        }
    }
    
    node.tpe = tpe
}

def walk_Yield(node: &parser::Node, state: &State) {
    let current_fun = current_function(state)
    let body = node.value.body
    if current_fun.is_global {
        errors::errorn(node, "Yield outside of a function")
        return
    }
    let tpe = current_fun.value.tpe
    let ltypes = copy_return_t(tpe.return_t)
    let rtypes = collapse_types(node, ltypes, body, state)
    if rtypes.length != 1 {
        errors::errorn(node, "Yield needs a single argument")
    }
    ltypes(0) = ltypes(0).tpe.tc_args(0)
    check_return_arguments(true, node, ltypes, rtypes, state)
    
    node.tpe = tpe
}

def walk_YieldFrom(node: &parser::Node, state: &State) {
    let current_fun = current_function(state)
    if current_fun.is_global {
        errors::errorn(node, "`yield from` outside of a function")
        return
    }
    if not node.value.expr { return }

    let ftpe = current_fun.value.tpe
    let generator = ftpe.return_t(0)

    walk(node, node.value.expr, state)
    var tpe = node.value.expr.tpe

    if not equals(generator, tpe) {
        let new_expr = wrap_iterable(node.value.expr, state)
        if not new_expr {
            errors::errorn(node, "Invalid generator, got ", debug::type_to_str(node.value.expr.tpe), " expected iterable")
            return
        }
        tpe = new_expr.tpe
        node.value.expr = new_expr
    }

    if not equals(generator, tpe) {
        errors::errorn(node, "`yield from` expects a generator of type " + 
            debug::type_to_str(generator.tc_args(0)) + " but got " + debug::type_to_str(tpe))
        return
    }

    let inner_scope = scope::enter_scope(state.scope)
    
    let name = "__yfm." + counter
    let ident = parser::make_identifier(name)
    counter += 1
    let v = scope::create_variable(
        inner_scope, 
        ident,
        parser::ShareMarker::NONE,
        parser::VarDecl::VAR,
        tpe.tpe.tc_args(0), true, null // extern so that we don't change the variable name
    )
    v.is_internal = true
    v.identifier = ident
    ident.tpe = v.tpe
    ident.svalue = v
    node.svalue = v
    node.inner_scope = inner_scope
}

export def append_arguments(arguments: &Vector(NamedParameter)) -> Str {
    let len = vector::length(arguments)
    var res: StringBuffer = ""
    if len > 0 {
        res = "Arguments were of type "
    } else {
        res = "No arguments."
    }
    for var i in 0..len {
        let arg = arguments(i)
        res += debug::type_to_str(arg.tpe)
        if i < len - 1 {
            res += ", "
        }
    }
    return res
}

def compile_function(function: *&scope::Value, context: &scope::Scope, arguments: &Vector(typechecking::NamedParameter)) {
    if consteval::is_static and @function {
        if not (@function).imported {
            consteval::load_function(@function)
        }
        @function = consteval::compile_function(@function, context, arguments)
    }
}

def check_for_apply_and_update(node: &parser::Node, left: &parser::Node, arguments: &Vector(NamedParameter), index: int64, state: &State) -> bool {
    if arguments.length < 1 { return false }
    let right = arguments(0).node
    
    if not left or not right { return false }
    let tpe = (@left).tpe
    if not tpe { return false }
    if is_function(tpe) { return false }

    let parent = node.parent
    if index == -1 {
        let args = vector::copy(arguments)
        vector::insert(args, 0, [ _tpe = tpe ] !NamedParameter)

        let ident = parser::make_identifier("apply")
        let fun = scope::get_function(state.scope, ident, args, false, true, force_compile = not consteval::is_static)
        if fun {
            vector::insert(node.value.func_call.args, 0, left)
            @node = @make_function_call(node, ident, node.value.func_call.args) 
            walk_Call(node, state)
            return true
        }
    } else if index < vector::length(parent.value.assign.right) {
        let value = parent.value.assign.right(index)
        value.is_assign_right = true
        walk(node, value, state)

        let args = vector::copy(arguments)
        vector::insert(args, 0, [ _tpe = tpe ] !NamedParameter)        
        args.push([ _tpe = value.tpe ] !NamedParameter)

        let ident = parser::make_identifier("update")
        let fun = scope::get_function(state.scope, ident, args, false, true, force_compile = not consteval::is_static)
        if fun {
            let args = vector::copy(node.value.func_call.args)
            vector::insert(args, 0, left)
            vector::push(args, value)
            @parent = @make_function_call(parent, ident, args)
            walk_Call(parent, state)
            return true
        }
    }
    
    if tpe.kind == TypeKind::TUPLE {
        if arguments.length != 1 {
            errors::errorn(node, "Tuple can only be indexed using one int argument")
            return false
        }
        let val = consteval::expr(arguments(0).node, state)
        if val.kind != compiler::ValueKind::INT {
            errors::errorn(node, "Tuple access needs to be integer")
            return false
        }
        if val.i < 0 {
            errors::errorn(node, "Tuple access needs to be greater than 0")
            return false
        }
        if val.i >= tpe.return_t.length {
            errors::errorn(node, "Tuple has " + tpe.return_t.length + " elements, trying to access element " + val.i)
            return false
        }

        var argument = arguments(0).node
        @argument = [ kind = parser::NodeKind::INTEGER ] !parser::Node
        argument.value.i = val.i
        argument.tpe = builtins::uint64_

        node.tpe = tpe.return_t(val.i)
    } else if (@tpe).kind == TypeKind::ARRAY or (@tpe).kind == TypeKind::STATIC_ARRAY {
        node.kw = tpe.kw
        node.tpe = tpe.tpe
    } else if is_ref(tpe) and tpe.tpe and is_array(tpe.tpe) {
        node.kw = tpe.kw
        node.tpe = tpe.tpe.tpe
    } else {
        return false
    }
    if not is_arithmetic(right.tpe) {
        errors::errorn(right, "Array access needs to be of arithmetic type")
        return false
    }

    return true
}

def access_check(function: &scope::Value, node: &parser::Node, state: &State) -> bool {
    return not (function and (function.share !int & parser::ShareMarker::EXPORT !int == 0) and function.module != node.scope.module and function.module != state.context.module)
}

export def walk_Call(node: &parser::Node, dry_run: bool, state: &State) -> bool {
    var left = node.value.func_call.left
    if not left { return false }
    left.parent = node  // Prevent the parent from being orphaned
    if not dry_run {
        if left.kind != parser::NodeKind::IDENTIFIER {
            walk(node, left, state)
        } else {
            let value = get_value(left, state, force_compile = not consteval::is_static, dry_run = true)
            if value {
                left.svalue = value
                left.tpe = value.tpe
            }
        }
    }
    // We need to do this because member access overwrites the parent node
    left = node.value.func_call.left
    var tpe = (@left).tpe

    if tpe and tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.wk
    }

    var arguments = vector::make(NamedParameter)
    for var i in 0..vector::length(node.value.func_call.args) {
        let n = node.value.func_call.args(i)
        if not n { continue }

        if n.kind == parser::NodeKind::LAMBDA {
            walk_Lambda(n, state)
        } else {
            walk(node, n, state)
        }
        
        let np = [
            _tpe = (@n).tpe,
            varargs = false,
            node = n
        ] !NamedParameter
        
        if equals(np.tpe, pointer(builtins::Type_)) {
            np.value = [ kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe ] !&compiler::Value
        }

        arguments.push(np)
    }

    let parameter_map = set::make()
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let n = node.value.func_call.kwargs(i)
        if not n { continue }
        let v = (@n).value.named_arg.value

        if v.kind == parser::NodeKind::LAMBDA {
            walk_Lambda(v, state)
        } else {
            walk(node, v, state)
        }

        let name = last_ident_to_str((@n).value.named_arg.name)

        if map::contains(parameter_map, name) {
            // and we cannot have two things with the same name so just error here...
            errors::errorn(n, "Cannot have the same parameter name multiple times in a function call. Parameter name was `", name, "`.")
            break
        } else {
            parameter_map.add(name)
            let np = [
                name = name,
                _tpe = (@(@n).value.named_arg.value).tpe,
                varargs = false,
                node = (@n).value.named_arg.name
            ] !NamedParameter

            if equals(np.tpe, builtins::Type_) {
                np.value = [ kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe ] !&compiler::Value
            }

            arguments.push(np)
        }
    }
    node.value.func_call.arguments = arguments

    if not is_function_pointer(tpe) and (not tpe or tpe.kind != TypeKind::CLOSURE) {
        
        let parent = node.parent

        var index: int64 = -1
        if parent.kind == parser::NodeKind::ASSIGN {
            index = index_of(parent.value.assign.left, node)
        }

        if check_for_apply_and_update(node, left, arguments, index, state) { return true }
        if (@left).kind == parser::NodeKind::IDENTIFIER {
            let only_function = node.value.func_call.is_member_access
            var exists, function = scope::get_function_check(state.scope, left, arguments, dry_run, not consteval::is_static, only_function = only_function, context = state.context)
            left.svalue = function

            // Access check
            if not access_check(function, node, state) {
                errors::errorn(left, "Can't access function ", function.tpe.type_name)
                function = null
            }
            // Try to call a zero arg function to retrieve a value that can be called
            if not function {
                let args = vector::make(NamedParameter)
                if node.value.func_call.is_member_access {
                    args.push(arguments(0))
                }
                let e, za_fun = scope::get_function_check(state.scope, left, args, true, not consteval::is_static, context = state.context)
                
                // make sure we only try this if there's something returned
                if e and za_fun.tpe.return_t.length == 1 and access_check(za_fun, node, state) {
                    // Build the zero args function
                    let za_args = vector::make(type &parser::Node)
                    if node.value.func_call.is_member_access {
                        za_args.push(node.value.func_call.args(0))
                    }
                    let za_call = make_function_call(left, left, za_args)
                    za_call.tpe = za_fun.tpe.return_t(0)
                    za_call.function = za_fun.tpe
                    
                    let args = vector::copy(arguments)
                    if node.value.func_call.is_member_access {
                        args.remove(0)
                    }

                    let main_args = vector::copy(node.value.func_call.args)
                    if node.value.func_call.is_member_access {
                        main_args.remove(0)
                    }
                    let new_call = make_function_call(node, za_call, main_args)

                    // Only do this if we have an apply or update call
                    if check_for_apply_and_update(new_call, za_call, args, index, state) {
                        @node = @new_call
                        return true
                    }
                }
            }

            if not function {
                scope::create_dependency(state.current_value(), scope::make_ident(parser::identifier_to_str(left)))
                if dry_run { return false }
            } else { 
                scope::add_reference(function, left)
            }

            compile_function(*function, state.scope, arguments)

            if left.value.identifier.types {
                if not function {
                    errors::errorn(left, "Function overload not found")
                    return false
                }
                if overload_score(function.tpe, arguments, state.module, false) < 0 {
                    var msg: StringBuffer = "Incorrect arguments to overloaded function. "
                    msg += append_arguments(arguments)
                    errors::errorn(left, msg)
                    return false
                }
            }

            if function {
                for var i in 0..arguments.length {
                    let param = arguments(i)
                    // TODO Check for varargs?
                    let ltpe = function.tpe.parameter_t(i).tpe if i < length(function.tpe.parameter_t) else function.tpe.parameter_t.peek().tpe

                    if param.node and param.node.kind == parser::NodeKind::LAMBDA {
                        let value = param.node
                        if not value.value.lambda.function.is_typechecked {
                            if infer_lambda_parameter_types(value, ltpe, state) {
                                walk_Lambda_body(value, state)
                                check_lambda_return_type(value, ltpe, state)
                            }
                        }
                    }
                }
            }

            if not function and not exists {
                for var i in 0..vector::length(arguments) {
                    // Suppress error message if we got invalid parameters
                    let np = arguments(i)
                    if not np.tpe { return false }
                }

                var msg: StringBuffer = "Function `" + parser::identifier_to_str(left) + "` not found. "
                msg += append_arguments(arguments)
                errors::errorn(left, msg)
            }
            if not function {
                scope::create_dependency_on_type(state.current_value(), left)
                return false 
            }

            // Check if all arguments were provided
            for var i in 0..vector::length(function.tpe.parameter_t) {
                let np = function.tpe.parameter_t(i)
                if i < vector::length(node.value.func_call.args) { continue }
                if not map::contains(parameter_map, np.name) and not np.value and not np.varargs {
                    errors::errorn(node, "Missing argument `", np.name, "` at position ", to_string(i !&size_t))
                }
            }
            // Dependencies
            scope::create_dependency(state.current_value(), function)
            if function.polymorph {
                // Pull in dependencies of generic function
                let cvar = state.current_value()
                if cvar.dependencies and function.dependencies {
                    cvar.dependencies.add_all(function.dependencies)
                }
            }
            
            tpe = copy(function.tpe)
        } else if left.kind == parser::NodeKind::MEMBER_ACCESS and left.tpe and arguments.length == 0 {
            // "Call" a field
            node.tpe = left.tpe
            return true
        } else {
            errors::errorn(left, "Can't call expression")
            return false
        }
    }

    node.function = tpe
    if is_function_pointer(tpe) {
        tpe = (@tpe).tpe
    }
    
    let parameter_t = (@tpe).parameter_t

    // Implicit conversions, this also removes type parameters from the argument list
    for var i in 0..vector::length(node.value.func_call.args) {
        let n = node.value.func_call.args(i)
        if not n { continue }
        var rhstpe: &Type = null
        if i < vector::length(parameter_t) {
            rhstpe = parameter_t(i).tpe
        } else if vector::length(parameter_t) > 0 {
            let np = vector::peek(parameter_t)
            if not np.varargs {
                errors::errorn(np.node, "Needs to be varargs")
            }
            rhstpe = np.tpe
        }

        implicit_conversion(n, rhstpe, state)
    }
    for var i in 0..vector::length(node.value.func_call.kwargs) {
        let n = node.value.func_call.kwargs(i)
        if not n { continue }

        let name = last_ident_to_str((@n).value.named_arg.name)
        let arg = (@n).value.named_arg.value

        var rhstpe: &Type = null
        for var j in 0..vector::length(parameter_t) {
            let param = parameter_t(j)
            if param.name == name {
                rhstpe = param.tpe
                break
            }
        }

        implicit_conversion(arg, rhstpe, state)
    }

    node.tpe = flatten_return_type(node, tpe.return_t)
    return true
}

def walk_Call(node: &parser::Node, state: &State) {
    walk_Call(node, false, state)
}

def walk_Case(node: &parser::Node, state: &State) {
    for var i in 0..vector::length(node.value.case_.expr) {
        let expr = node.value.case_.expr(i)
        walk(node, expr, state)
        if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) or is_range((@expr).tpe)){
            errors::errorn(expr, "Incompatible type, expected arithmetic type, range or enum, got ", debug::type_to_str((@expr).tpe))
            return
        }

        if expr.kind == parser::NodeKind::RANGE or expr.kind == parser::NodeKind::RANGE_INC {
            let left = expr.value.bin_op.left
            let right = expr.value.bin_op.right
            left.svalue = consteval::make_value(consteval::expr(left, state))
            right.svalue = consteval::make_value(consteval::expr(right, state))
        } else {
            expr.svalue = consteval::make_value(consteval::expr(expr, state))
        }
    }

    for var i in 0..vector::length(node.value.case_.body) {
        let expr = node.value.case_.body(i)
        walk(node, expr, state)
    }
}

def walk_Switch(node: &parser::Node, state: &State) {
    let expr = node.value.switch_.expr
    walk(node, expr, state)
    if not (is_arithmetic((@expr).tpe) or is_enum((@expr).tpe) ){
        errors::errorn(expr, "Incompatible type, expected arithmetic type or enum, got ", debug::type_to_str((@expr).tpe))
        return
    }

    for var i in 0..vector::length(node.value.switch_.body) {
        walk(node, node.value.switch_.body(i), state)
    }
}

def walk_If(node: &parser::Node, state: &State) {
    let cond = node.value.if_.cond
    walk(node, cond, state)
    if not cond { return }
    let tpe = (@cond).tpe
    if not tpe { return }
    if not is_boolean(tpe, state.module) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }
    
    for var i in 0..vector::length(node.value.if_.body) {
        let n = node.value.if_.body(i)
        walk(node, n, state)
    }

    for var i in 0..vector::length(node.value.if_.else_if) {
        let n = node.value.if_.else_if(i)
        
        let cond = (@n).value.else_if.cond
        walk(node, cond, state)
        let tpe = (@cond).tpe
        
        if not is_boolean(tpe, state.module) {
            errors::errorn(n, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
        }

        for var i in 0..vector::length((@n).value.else_if.body) {
            let n2 = (@n).value.else_if.body(i)
            walk(node, n2, state)
        }   
    }

    let else_ = node.value.if_.else_
    if else_ {
        for var i in 0..vector::length((@else_).value.body) {
            let n = (@else_).value.body(i)
            walk(node, n, state)
        }
    }
}

def walk_IfExpr(node: &parser::Node, state: &State) {
    let cond = node.value.if_expr.cond
    walk(node, cond, state)

    let tpe = cond.tpe
    if not tpe { return }
    if not is_boolean(tpe, state.module) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str(tpe), ", must be boolean type")
    }

    let if_true = node.value.if_expr.if_true
    let if_false = node.value.if_expr.if_false
    walk(node, if_true, state)
    walk(node, if_false, state)

    if is_arithmetic(if_true.tpe) and is_arithmetic(if_false.tpe) {
        node.tpe = common_type(if_true.tpe, if_false.tpe)
    } else if if_true.tpe and if_true.tpe.kind == TypeKind::NULL and (is_ref_or_weak(if_false.tpe) or is_pointer(if_false.tpe)) {
        node.tpe = if_false.tpe
    } else if if_false.tpe and if_false.tpe.kind == TypeKind::NULL and (is_ref_or_weak(if_true.tpe) or is_pointer(if_true.tpe)) {
        node.tpe = if_true.tpe
    } else if not equals(if_true.tpe, if_false.tpe) {
        errors::errorn(node, "If expression needs to have a single type. Types were ", debug::type_to_str(if_true.tpe), " and ", debug::type_to_str(if_false.tpe))
    } else {
        node.tpe = if_true.tpe
    }
}

def walk_Loop(node: &parser::Node, state: &State) {
    for var i in 0..vector::length(node.value.body) {
        let n = node.value.body(i)
        walk(node, n, state)
    }
}

def walk_While(node: &parser::Node, state: &State) {
    let expr = node.value.while_loop.expr
    if not expr { return }
    walk(node, expr, state)
    if not is_boolean((@expr).tpe, state.module) {
        errors::errorn(node, "Incompatible type ", debug::type_to_str((@expr).tpe), ", must be boolean type")
    }

    for var i in 0..vector::length(node.value.while_loop.body) {
        let n = node.value.while_loop.body(i)
        walk(node, n, state)
    }
}

def for_setup_generator(expr: &parser::Node, node: &parser::Node, state: &State) {
    for_setup_generator(expr, node, state.scope)
}

export def for_setup_generator(expr: &parser::Node, node: &parser::Node, scpe: &scope::Scope) {
    let parameter_t = vector::make(NamedParameter)
    parameter_t.push([ _tpe = expr.tpe ] !NamedParameter)
    let generator_next = scpe.get_function(
        id = parser::make_identifier("next"),
        parameter_t = parameter_t
    )
    node.value.for_loop.generator_next = generator_next

    let parameter_t2 = vector::make(NamedParameter)
    parameter_t2.push([ _tpe = generator_next.tpe.return_t(0) ] !NamedParameter)
    let generator_get = scpe.get_function(
        id = parser::make_identifier("get"),
        parameter_t = parameter_t2
    )
    node.value.for_loop.generator_get = generator_get
}

def wrap_iterable(expr: &parser::Node, state: &State) -> &parser::Node {
    let args = vector::make(NamedParameter)
    args.push([ _tpe = expr.tpe ] !NamedParameter)
    let ident = parser::make_identifier("iterate")
    let fun = scope::get_function(state.scope, ident, args, true)
    if fun {
        let args = vector::make(type &parser::Node)
        args.push(expr)

        let function = [
            kind = parser::NodeKind::FUNC_CALL,
            loc = expr.loc
        ] !&parser::Node
        function.value.func_call = [
            left = ident,
            args = args,
            kwargs = vector::make(type &parser::Node)
        ] !parser::NodeFuncCall
        function.parent = expr.parent
        function.scope = expr.scope

        walk(expr.parent, function, state)

        if not (function.tpe.kind == TypeKind::REFERENCE and function.tpe.tpe and function.tpe.tpe.tc_tpe == builtins::Generator_) {        
            errors::errorn(expr, "Wrong return type for generator, needs to return &Generator(T), got ", debug::type_to_str(expr.tpe))  
            return null
        }
        return function
    }
    return null
}

def walk_For(node: &parser::Node, state: &State) {
    var expr = node.value.for_loop.expr
    if not expr { return }
    walk(node, expr, state)
    if not expr.tpe { return }

    let iddecl = node.value.for_loop.iddecl
    var tpe: &typechecking::Type
    if is_array(expr.tpe) {
        tpe = expr.tpe.tpe
    } else if expr.tpe.kind == TypeKind::RANGE or expr.tpe.kind == TypeKind::RANGE_INC {
        tpe = builtins::int_
    } else if expr.tpe.kind == TypeKind::REFERENCE and expr.tpe.tpe and equals(expr.tpe.tpe.tc_tpe, builtins::Generator_) {
        tpe = expr.tpe.tpe.tc_args(0)
        for_setup_generator(expr, node, state)
    } else {
        let new_expr = wrap_iterable(expr, state)
        if not new_expr {
            errors::errorn(expr, "Invalid generator, got ", debug::type_to_str(expr.tpe), " expected array, range or iterable")
        } else {
            node.value.for_loop.expr = new_expr
            tpe = new_expr.tpe.tpe.tc_args(0)
            for_setup_generator(new_expr, node, state)
        }
    }

    if (@iddecl).kind == parser::NodeKind::FOR_ID_DECL {
        (@iddecl).tpe = tpe
        (@iddecl).scope = node.inner_scope
        let ident = (@iddecl).value.for_id_decl.ident
        ident.svalue = scope::create_variable(
            node.inner_scope, 
            ident, 
            parser::ShareMarker::NONE, 
            (@iddecl).value.for_id_decl.kw, 
            tpe, null
        )
    } else {
        walk(node, iddecl, state)
        if not equals(tpe, (@iddecl).tpe) {
            errors::errorn(iddecl, "Type didn't match, expected ", debug::type_to_str(tpe), ", got ", debug::type_to_str((@iddecl).tpe))
        }
    }

    for var i in 0..vector::length(node.value.for_loop.body) {
        let n = node.value.for_loop.body(i)
        walk(node, n, state)
    }
}

def walk_Deref(node: &parser::Node, state: &State) {
    walk(node, node.value.expr, state)
    let tpe = (@node.value.expr).tpe
    if not tpe { return }
    if not is_pointer(tpe) and not is_ref_or_weak(tpe) {
        errors::errorn(node, "Needs to be a pointer or reference type, got ", debug::type_to_str(tpe))
        return
    }
    if is_interface(tpe.tpe) {
        errors::errorn(node, "Can't dereference a structural type")
        return
    }
    node.tpe = tpe.tpe
    node.kw = tpe.kw
}

def walk_Ptr(node: &parser::Node, state: &State) {
    let expr = node.value.expr
    if not expr { return }
    walk(node, expr, state)
    let tpe = expr.tpe
    if not tpe { return }

    if expr.kind == parser::NodeKind::IDENTIFIER and expr.svalue {
        if expr.svalue.is_capture {
            let name = parser::make_identifier("__ref." + expr.svalue.name)
            var value = scope::get(state.scope, name)
            if value {
                @node = @expr
                node.svalue = value
            }
        }
    }

    node.tpe = pointer(tpe, tpe.kw)

    if equals(tpe, pointer(builtins::Type_)) or tpe.may_be_type {
        node.tpe.may_be_type = convert_ambiguous_expr_to_type(node, state).tpe
    }
}

def walk_MemberAccess_ucs(node: &parser::Node, state: &State) -> bool {
    let right = node.value.bin_op.right
    let left = node.value.bin_op.left
    let parent = node.parent
    let tpe = (@left).tpe

    if (@parent).kind == parser::NodeKind::FUNC_CALL and
        (@parent).value.func_call.left == node {
        let old_parent = @parent
        let old_args = vector::copy((@parent).value.func_call.args)
        parent.value.func_call.left = right
        vector::prepend((@parent).value.func_call.args, left)
        parent.value.func_call.is_member_access = true

        if not walk_Call(parent, true, state) {
            @parent = old_parent
            parent.value.func_call.args = old_args
            return false 
        }
    } else {
        let parameter_t = vector::make(NamedParameter)
        parameter_t.push([
            _tpe = (@left).tpe
        ] !NamedParameter)

        let function = scope::get_function(node.scope, right, parameter_t, false, false, only_function = true)
        if not function { return false }
        if node.parent.kind == parser::NodeKind::ASSIGN and node.parent.value.assign.right.index_of(node) == -1 {
            return true
        }

        let args = vector::make(type &parser::Node)
        args.push(left)
        @node = [
            kind = parser::NodeKind::FUNC_CALL,
            loc = node.loc,
            parent = parent,
            scope = node.scope
        ] !parser::Node
        node.value.func_call = [
            left = right,
            args = args,
            kwargs = vector::make(type &parser::Node),
            is_member_access = true
        ] !parser::NodeFuncCall
        
        walk_Call(node, false, state)
    }
    return true
}

export def lookup_struct_member(member: StructMember, resolved: &SSet = null) {
    let tpe = member.tpe
    if not tpe { return }
    if not resolved { resolved = set::make() }

    let name = debug::type_to_str(tpe, full_name = true)
    if resolved.contains(name) { return }
    resolved.add(name)

    if (is_pointer(tpe) or
        tpe.kind == TypeKind::REFERENCE or
        tpe.kind == TypeKind::ARRAY) {
        if tpe._tpe and tpe._tpe.kind == TypeKind::STUB and tpe._tpe.state {
            tpe._tpe = box(type_lookup(tpe._tpe.node, tpe._tpe.state))
        }
        tpe._hash = 0
    } else if tpe.kind == TypeKind::WEAK_REF {
        if tpe._tpe and tpe._tpe.kind == TypeKind::STUB and tpe._tpe.state {
            tpe._tpe = box(type_lookup(tpe.node.value.t_parr.tpe, tpe._tpe.state))
        }
        tpe._hash = 0
    } else if tpe.kind == typechecking::TypeKind::STRUCT {
        for var i in 0..tpe.fields.size {
            let field = tpe.fields(i)
            lookup_struct_member(field, resolved)
        }
    }
}

def resolve_member(tpe: &Type, name: String) -> &Type {
    for var member in @tpe.fields {
        if member.name {
            if member.name == name {
                lookup_struct_member(member)
                return member.tpe
            }
        } else {
            var tpe = member.tpe
            if member.is_embed and is_ref(member.tpe) {
                tpe = member.tpe.tpe
            }
            let member = resolve_member(tpe, name)
            if member { return member }
        }
    }
    for var member in @tpe.const_fields {
        if member.name == name {
            return member.tpe
        }
    }
    return null
}

def walk_MemberAccess(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    if not left { return }

    // Opportunistically walk the right part so if it is a function it is going to get resolved
    if right {
        scope::get(state.scope, right, not consteval::is_static, false, true)
    }

    walk(node, left, state)
    let tpe = (@left).tpe

    if not right or not left { return }
    if parser::identifier_to_str(right) == "type" {
        if tpe and not is_ref_or_weak(tpe) and tpe.kind != TypeKind::TUNION {
            errors::errorn(node, "Can't get type from `" + debug::type_to_str(tpe) + "`, only references or variants allowed")
        } else {
            node.tpe = pointer(builtins::Type_)
        }
        return
    }

    if is_pointer(tpe) or is_ref_or_weak(tpe) {
        let old_left = parser::copy_node(left)
        let new_left = [
            kind = parser::NodeKind::DEREF,
            loc = (@left).loc,
            tpe = tpe.tpe
        ] !parser::Node
        new_left.value.expr = old_left
        @left = new_left
        if walk_MemberAccess_aggregate(node, false, state) { return }
        
        @left = @old_left
        if walk_MemberAccess_ucs(node, state) { return }

        @left = new_left
        if not walk_MemberAccess_ucs(node, state) {
            errors::errorn(node, "Unknown field `", last_ident_to_str(right), "`")
        }
        return
    }

    walk_MemberAccess_aggregate(node, true, state)
}

def walk_MemberAccess_aggregate(node: &parser::Node, ucs: bool, state: &State) -> bool {
    let right = node.value.bin_op.right
    let left = node.value.bin_op.left
    let tpe = left.tpe
    if not tpe { return false }

    if (@tpe).kind == TypeKind::STRUCT or (@tpe).kind == TypeKind::UNION {
        let name = last_ident_to_str(right)

        var rtpe = resolve_member(tpe, name)
        if not rtpe {
            if ucs {
                if walk_MemberAccess_ucs(node, state) { return true }
                errors::errorn(node, "Unknown field `", name, "`")
            }
            return false
        }
        if rtpe.kind == TypeKind::BOX {
            rtpe = rtpe.wk
        }
        node.tpe = rtpe
    } else if (@tpe).kind == TypeKind::ARRAY or (@tpe).kind == TypeKind::STATIC_ARRAY {
        let name = last_ident_to_str(right)
        if name == "size" {
            node.tpe = builtins::size_t_
        } else if name == "value" {
            node.tpe = pointer((@tpe).tpe)
        } else {
            if ucs {
                if walk_MemberAccess_ucs(node, state) { return true }
                errors::errorn(node, "Expected size or value")
            }
            return false
        }
    // TODO Enums might have ordinal and some other information
    } else {
        if ucs {
            if walk_MemberAccess_ucs(node, state) { return true }
            errors::errorn(node, "Expected aggregate type, got ", debug::type_to_str(tpe), )
        }
        return false
    }
    return true
}

// TODO Make this a generator, doesn't work for some reason
def flatten_fields(tpe: &Type, v: &Vector(StructMember) = null) -> &Vector(StructMember) {
    if not v { v = vector::make(StructMember) }
    if not tpe { return v }
    if not is_struct(tpe) { 
        errors::errorn(tpe.node, "Invalid embed, needs to be a struct or a reference to a struct")
        return v
    }

    for var field in @tpe.fields {
        if field.is_embed {
            let tpe = field.tpe.tpe if is_box(field.tpe) else field.tpe
            flatten_fields(tpe, v)
        } else {
            v.push(field)
        }
    }
    return v
}

def walk_StructLit(node: &parser::Node, state: &State) {
    let prev_tpe = node.tpe
    var tpe = prev_tpe

    if is_ref(tpe) {
        tpe = tpe.tpe
    }

    if vector::length(node.value.struct_lit.kwargs) == 0 {
        // No kwargs means we could have an array or a tuple
        for var arg in node.value.struct_lit.args {
            // Infer types
            if tpe and (tpe.kind == TypeKind::ARRAY or tpe.kind == TypeKind::STATIC_ARRAY) and arg {
                arg.tpe = tpe.tpe
                walk(node, arg, state)
                implicit_conversion(arg, tpe.tpe, state)
            } else {
                walk(node, arg, state)
            }
        }
        var curtpe: &Type
        var is_tuple = node.value.struct_lit.args.length == 0
        for var arg in node.value.struct_lit.args {
            if not curtpe { curtpe = arg.tpe }
            else if not equals(arg.tpe, curtpe) {
                is_tuple = true
                break
            }
        }

        if tpe {
            if tpe.kind == TypeKind::TUPLE {
                // Check conversion to tuple
                if tpe.return_t.length != node.value.struct_lit.args.length {
                    errors::errorn(node, "Wrong number of arguments. Expected " + tpe.return_t.length + " got " + node.value.struct_lit.args.length)
                    return
                }
                for var i in 0..vector::length(node.value.struct_lit.args) {
                    var n = node.value.struct_lit.args(i)
                    var etpe = tpe.return_t(i)
                    implicit_conversion(n, etpe, state)
                    
                    if not is_assignable(etpe, n.tpe, state.module) {
                        errors::errorn(n, "Incompatible types, got " + debug::type_to_str(n.tpe) + " and expected " + debug::type_to_str(etpe))
                        return
                    }
                }
            } else if tpe.kind == TypeKind::ARRAY or tpe.kind == TypeKind::STATIC_ARRAY {
                // Check conversion to array
                if tpe.kind == TypeKind::STATIC_ARRAY {
                    if tpe.length != MAX_UINT64 and tpe.length != node.value.struct_lit.args.length {
                        errors::errorn(node, "Wrong number of arguments. Expected " + tpe.length + " got " + node.value.struct_lit.args.length)
                        return
                    }
                }

                for var n in node.value.struct_lit.args {
                    implicit_conversion(n, tpe.tpe, state)

                    if not is_assignable(tpe.tpe, n.tpe, state.module) {
                        errors::errorn(n, "Incompatible types, got " + debug::type_to_str(n.tpe) + " and expected " + debug::type_to_str(tpe.tpe))
                        return
                    }
                }
            }
        }

        if not tpe or (tpe.kind != TypeKind::STRUCT and tpe.kind != TypeKind::UNION) {
            if not is_tuple and curtpe {
                let len = node.value.struct_lit.args.length

                let ret_tpe = make_type_raw(TypeKind::STATIC_ARRAY)
                ret_tpe.line = node.loc.line
                ret_tpe.length = len
                ret_tpe._tpe = curtpe
                ret_tpe.size = len * curtpe.size
                ret_tpe.align = curtpe.align

                // Check if we have a type array, in this case it might also be a type
                if equals(curtpe, pointer(builtins::Type_)) or curtpe.may_be_type {
                    ret_tpe.may_be_type = convert_ambiguous_expr_to_type(node, state).tpe
                }

                node.tpe = ret_tpe
                return
            } else {
                // This is a tuple
                let ret_tpe = make_type_raw(TypeKind::TUPLE)

                let fields = vector::make(StructMember)
                let return_t = vector::make(type &Type)

                for var arg in node.value.struct_lit.args {
                    return_t.push(arg.tpe)
                    fields.push([ tpe = arg.tpe ] !StructMember)
                }

                let struct_type = make_struct_type(fields.to_array()) // TODO Maybe a have a seperate function to calculate align and size
                ret_tpe.return_t = return_t
                ret_tpe.align = struct_type.align
                ret_tpe.size = struct_type.size
                ret_tpe.line = node.loc.line

                node.tpe = ret_tpe
                return
            }
        }
    }

    // This instructs compile to skip the struct literal completely
    node.tpe = null

    if not tpe {
        // Create anonymous struct literal
        if vector::length(node.value.struct_lit.args) != 0 {
            errors::errorn(node, "Can't create anonymous struct with indexed values")
            return
        }

        let len = vector::length(node.value.struct_lit.kwargs) 
        let fields = allocate_ref(StructMember, len)

        for var i in 0..len {
            let arg = node.value.struct_lit.kwargs(i)
            let name = parser::identifier_to_str(arg.value.named_arg.name)

            let n = arg.value.named_arg.value
            walk(node, n, state)

            fields(i) = [ name = name, tpe = n.tpe ] !StructMember
        }

        tpe = make_struct_type(fields)
        tpe.is_anon = true
        node.tpe = tpe

        return
    }

    for var i in 0..tpe.fields.size {
        lookup_struct_member(tpe.fields(i))
    }

    if node.value.struct_lit.args.length != 0 {
        errors::errorn(node, "Indexed arguments aren't allowed for struct literals")
        return
    }
    
    for var i in 0..vector::length(node.value.struct_lit.kwargs) {
        let kwarg = node.value.struct_lit.kwargs(i)
        let n = (@kwarg).value.named_arg.value
        let name = last_ident_to_str((@kwarg).value.named_arg.name)

        var found = false
        for var field in flatten_fields(tpe) {
            if field.name == name {
                found = true

                var ntpe = field.tpe
                // Infer type
                if n {
                    n.tpe = ntpe
                }

                walk(node, n, state)
                implicit_conversion(n, ntpe, state)

                if not ntpe or not (@n).tpe { continue }
                if not is_assignable(ntpe, (@n).tpe, state.module) {
                    errors::errorn(n, "Incompatible types ", debug::type_to_str((@n).tpe), " and ", debug::type_to_str(ntpe), )
                    return
                }
                break
            }
        }
        if not found {
            errors::errorn(n, "Unknown field `", name, "`")
            return
        }
    }

    node.tpe = prev_tpe
}

def walk_SizeOf(node: &parser::Node, state: &State) {
    let expr = node.value.expr
    if not expr { return }
    expr.tpe = type_lookup(expr, state)
    node.tpe = builtins::size_t_
}

def walk_AlignOf(node: &parser::Node, state: &State) {
    let expr = node.value.expr
    if not expr { return }
    expr.tpe = type_lookup(expr, state)
    node.tpe = builtins::size_t_
}

// TODO the operator overloading breaks a > b > c chains
// Do the conversion inside of the parser
def walk_ComparisionOp(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)

    let args = create_args(left, right)

    switch node.kind {
        case parser::NodeKind::EQ
            convert_to_call(node, "__eq__", args, state)
        case parser::NodeKind::NEQ
            convert_to_call(node, "__ne__", args, state)
        case parser::NodeKind::GT
            convert_to_call(node, "__gt__", args, state)
        case parser::NodeKind::LT
            convert_to_call(node, "__lt__", args, state)
        case parser::NodeKind::GEQ
            convert_to_call(node, "__ge__", args, state)
        case parser::NodeKind::LEQ
            convert_to_call(node, "__le__", args, state)
    }

    if node.kind != parser::NodeKind::FUNC_CALL {
        if builtins::Type_ and equals(left.tpe, pointer(builtins::Type_)) {
            let equals = scope::get(toolchain::runtime_.scope, parser::make_identifier("equals"), not consteval::is_static)
            consteval::compile_function(equals, toolchain::runtime_.scope)
        }

        // TODO We can compare almost everything
        node.tpe = builtins::bool_
    }
}

def walk_PAdd(node: &parser::Node, state: &State) {
    let left = node.value.bin_op.left
    let right = node.value.bin_op.right
    walk(node, left, state)
    walk(node, right, state)
    if not is_pointer((@left).tpe) {
        errors::errorn(left, "Must be pointer type, got ", debug::type_to_str((@left).tpe))
    }
    if not is_arithmetic((@right).tpe) {
        errors::errorn(left, "Must be arithmetic type, got ", debug::type_to_str((@right).tpe))
    }
    // TODO should probably not set this to a garbage value
    node.tpe = (@left).tpe
}

def walk_PSub(node: &parser::Node, state: &State) {
    walk_PAdd(node, state)
}

def walk_Defer(node: &parser::Node, state: &State) {
    if state.in_defer { 
        errors::errorn(node, "Can't nest defers!")
    }

    state.in_defer = true
    for var i in 0..vector::length(node.value.body) {
        let n = node.value.body(i)
        walk(node, n, state)
    }
    state.in_defer = false
}

def walk_Assert(node: &parser::Node, state: &State) {
    let cond = node.value.assert_.cond
    let msg = node.value.assert_.message
    walk(node, cond, state)
    walk(node, msg, state)
    
    if consteval::is_static {
        let context = toolchain::find_module("std").scope
        let stderr_fun = get(context, parser::make_identifier("stderr"), force_compile = false)
        consteval::compile_function(stderr_fun, context)
    }

    if cond and not is_boolean(cond.tpe, state.module) {
        errors::errorn(cond, "Incompatible type ", debug::type_to_str(cond.tpe), ", must be boolean type")
    }
    if msg and not equals(msg.tpe, builtins::string_) {
        errors::errorn(msg, "Incompatible type ", debug::type_to_str(msg.tpe), ", must be string type")
    }

    // Compile stderr function
    let std_module = toolchain::find_module("std")
    scope::get(std_module.scope, parser::make_identifier("stderr"))
}

export def generate_ctor_and_dtor(tpe: &Type) {
    if not tpe { return }
    if tpe.kind == TypeKind::REFERENCE {
        tpe = tpe._tpe
    }

    if tpe and tpe.tc_args {
        has_copy_constructor(tpe)
        has_destructor(tpe)
    }
}

export def walk(parent: &parser::Node, node: &parser::Node, state: &State) {
    if not node { return }
    node.parent = parent

    let scpe = state.scope
    if node.scope {
        state.scope = node.scope
    }

    switch node.kind !int {
        case parser::NodeKind::NULL
            walk_Null(node, state)
        case parser::NodeKind::UNDEF
            walk_Undef(node, state)
        case parser::NodeKind::INTEGER
            walk_Integer(node, state)
        case parser::NodeKind::BOOLEAN
            walk_Boolean(node, state)
        case parser::NodeKind::STRING
            walk_String(node, state)
        case parser::NodeKind::CHAR
            walk_Char(node, state)
        case parser::NodeKind::FLOAT
            walk_Float(node, state)
        case parser::NodeKind::RANGE..=parser::NodeKind::RANGE_INC
            walk_Range(node, state)
        case parser::NodeKind::IDENTIFIER
            walk_Identifier(node, state)
        case parser::NodeKind::SIZE_OF
            walk_SizeOf(node, state)
        case parser::NodeKind::ALIGN_OF
            walk_AlignOf(node, state)
        case parser::NodeKind::LOOP
            walk_Loop(node, state)
        case parser::NodeKind::WHILE
            walk_While(node, state)
        case parser::NodeKind::FOR
            walk_For(node, state)
        case parser::NodeKind::IF_EXPR
            walk_IfExpr(node, state)
        case parser::NodeKind::IF
            walk_If(node, state)
        case parser::NodeKind::SWITCH
            walk_Switch(node, state)
        case parser::NodeKind::CASE
            walk_Case(node, state)
        case parser::NodeKind::DEF
            let prev_context = state.context
            state.context = node.scope
            walk_Def(node, state)
            state.context = prev_context
        case parser::NodeKind::IMPORT
            walk_Import(node, state)
        case parser::NodeKind::CAST
            walk_Cast(node, state)
        case parser::NodeKind::ASSIGN
            walk_Assign(node, state)
        case parser::NodeKind::VAR_DECL
            if node.parent.kind == parser::NodeKind::PROGRAM {
                walk_top_VarDecl(node, state)
            } else {
                walk_VarDecl(node, state)
            }
        case parser::NodeKind::UADD
            walk_UAdd(node, state)
        case parser::NodeKind::USUB
            walk_USub(node, state)
        case parser::NodeKind::BNOT
            walk_BNot(node, state)
        case parser::NodeKind::NOT
            walk_Not(node, state)
        case parser::NodeKind::ADD..=parser::NodeKind::MOD
            walk_ArithmeticOp(node, state)
        case parser::NodeKind::BAND..=parser::NodeKind::SHR
            walk_BitwiseOp(node, state)
        case parser::NodeKind::AND..=parser::NodeKind::OR
            walk_BooleanOp(node, state)
        case parser::NodeKind::EQ..=parser::NodeKind::LEQ
            walk_ComparisionOp(node, state)
        case parser::NodeKind::ADD_EQ..=parser::NodeKind::MOD_EQ
            walk_AssignEqArithmetic(node, state)
        case parser::NodeKind::AND_EQ..=parser::NodeKind::SHR_EQ
            walk_AssignEqBitwise(node, state)
        case parser::NodeKind::PADD_EQ..=parser::NodeKind::PSUB_EQ
            walk_AssignEqPtr(node, state)
        case parser::NodeKind::PADD
            walk_PAdd(node, state)
        case parser::NodeKind::PSUB
            walk_PSub(node, state)
        case parser::NodeKind::DEREF
            walk_Deref(node, state)
        case parser::NodeKind::PTR
            walk_Ptr(node, state)
        case parser::NodeKind::TYPE_DECL
            walk_TypeDecl(node, state)
        case parser::NodeKind::RETURN
            walk_Return(node, state)
        case parser::NodeKind::YIELD
            walk_Yield(node, state)
        case parser::NodeKind::FUNC_CALL
            walk_Call(node, state)
        case parser::NodeKind::BREAK..=parser::NodeKind::CONTINUE
            null // NOOP
        case parser::NodeKind::MEMBER_ACCESS
            walk_MemberAccess(node, state)
        case parser::NodeKind::STRUCT_LIT
            walk_StructLit(node, state)
        case parser::NodeKind::DEFER
            walk_Defer(node, state)
        case parser::NodeKind::ASSERT
            walk_Assert(node, state)
        case parser::NodeKind::PTR_T, parser::NodeKind::REF_T, 
            parser::NodeKind::ARRAY_T, parser::NodeKind::WEAK_REF_T,
            parser::NodeKind::TYPE_CONSTRUCTOR, parser::NodeKind::FUNCTION_T,
            parser::NodeKind::CLOSURE_T, parser::NodeKind::TUPLE_T
            let tpe = copy(builtins::Type_) // TODO use TypeKind::TYPE
            tpe._tpe = type_lookup(node, state)
            node.tpe = pointer(tpe)
        case parser::NodeKind::ARRAY_STATIC_T
            walk_ArrayStaticT(node, state)
        case parser::NodeKind::TYPE_OF_T
            walk_TypeOfT(node, state)
        case parser::NodeKind::FROM
            // Do nothing
        case parser::NodeKind::YIELD_FROM
            walk_YieldFrom(node, state)
        case parser::NodeKind::LAMBDA
            walk_Lambda(node, state)
            walk_Lambda_body(node, state)
        case
            error(node.kind, "\n")
            assert
    }

    if node.tpe and is_struct(node.tpe) {
        // Generate copy constructor and destructor
        // TODO Why here you might ask? I have no idea but it works!
        generate_ctor_and_dtor(node.tpe)
        scope::create_dependency(state.current_value(), node.tpe.svalue)
    }

    state.scope = scpe
}

export def make_state(module: &toolchain::Module) -> &State {
    return [
        module = module,
        scope = module.scope,
        function_stack = vector::make(type &compiler::Function)
    ] !&State
}

def find_dependencies(type_variables: &Vector(&scope::Value), tpe: &Type) {
    if not tpe { return }
    if is_box(tpe) {
        find_dependencies(type_variables, tpe.tpe)
    } else if tpe.kind == TypeKind::FUNCTION or tpe.kind == TypeKind::CLOSURE or tpe.kind == TypeKind::VARIANT {
        if tpe.kind != TypeKind::VARIANT {
            for var np in tpe.parameter_t {
                find_dependencies(type_variables, np.tpe)
            }
        }
        for var rtpe in tpe.return_t {
            find_dependencies(type_variables, rtpe)
        }
    } else if is_struct(tpe) and not tpe.tc_args and not tpe.svalue {
        for var field in @tpe.fields {
            find_dependencies(type_variables, field.tpe)
        }
    }
    
    if tpe.tc_args {
        for var arg in tpe.tc_args {
            find_dependencies(type_variables, arg)
        }
        type_variables.push(tpe.tc_tpe.svalue)
    }
    if tpe.svalue {
        type_variables.push(tpe.svalue)
    }
}

export def walk_Def_with_type_argument(node: &parser::Node, parameter_t: &Vector(NamedParameter), context: &scope::Scope, state: &State) -> &parser::Node {
    let old_node = node
    node = parser::deep_copy_node(node)
    node.value.def_.function = null
    node.value.def_.is_generic_instance = true
    node.tpe = lookup_parameters(node, state)

    // Unbox
    let module = context.module
    context = module.scope

    /*var in_context = false
    var super_scope = node.scope
    while super_scope.parent and super_scope.parent != builtins::builtins {
        if super_scope !* == context !* {
            break
        }
        super_scope = super_scope.parent
    }
    if super_scope == context { in_context = true }

    // Temporarily change parent scope to get into the context of the invocation
    if not in_context {
        super_scope.parent = context
    }*/
    
    if not node.scope { return old_node }
    node.inner_scope = scope::enter_function_scope(node.scope)

    let share = node.value.def_.share
    var tpe = node.tpe
    var body = node.value.def_.body
    let test = node.value.def_.test

    for var i in 0..vector::length(parameter_t) {
        let np = parameter_t(i)
        var left: *NamedParameter = null
        if np.name {
            for var j in 0..vector::length(tpe.parameter_t) {
                let l = tpe.parameter_t.get(j)
                if l.name == np.name {
                    left = l
                    break
                }
            }
        } else if i < tpe.parameter_t.length {
            left = tpe.parameter_t.get(i)
        }

        if left and equals(left.tpe, builtins::type_) {
            if np.tpe and np.tpe.may_be_type {
                np._tpe = np.tpe.may_be_type
                left.value = [ kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe ] !&compiler::Value
                parameter_t(i) = np
            } else {
                left.value = [ kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = np.tpe.tpe.tpe ] !&compiler::Value
            }
        }
    }

    let types_map = map::make(type &Type)
    replace_type_defs(tpe.parameter_t, tpe.return_t, parameter_t, types_map, context.module)
    tpe.type_name = mangle_function_name(append_module(tpe.name, tpe.module.module), tpe.parameter_t, test, context.module)

    // TODO This is quite hacky but we need to copy the nodes
    for var i in 0..vector::length(node.value.def_.params) {
        let param = node.value.def_.params(i)
        let np = tpe.parameter_t(i)
        np.type_node = param.value.param.tpe
        np.node = param.value.param.name
        tpe.parameter_t(i) = np
    }

    let type_variables = vector::make(type &scope::Value)

    let keys = map::keys(types_map)
    for var i in 0..keys.size {
        let key = keys(i)
        let tpe2 = types_map(key)
        find_dependencies(type_variables, tpe2)
        let value = scope::create_type(node.inner_scope, parser::make_identifier(key), parser::ShareMarker::NONE, tpe2, no_svalue = true)
    }

    let old_scope = state.scope
    state.scope = node.inner_scope
    node.value.def_.has_lookup = false
    node.tpe.context = context.module
    node.tpe = lookup_parameters(node, state)

    // Replace contextual type parameters
    for var i in 0..node.tpe.parameter_t.length {
        let left = node.tpe.parameter_t.get(i)
        if i >= tpe.parameter_t.length { break }
        let right = tpe.parameter_t.get(i)
        if is_type(left.tpe) {
            left._tpe._tpe = right.value.value_tpe
        }
    }

    tpe = node.tpe

    if vector::length(tpe.parameter_t) > 0 {
        let first_param = tpe.parameter_t(0)
        create_type_entry(first_param.tpe, (share !int & parser::ShareMarker::EXPORT !int) != 0, tpe, state.module, true)
    }

    let prev_context = state.context
    state.context = context
    walk_Def(node, state, polymorph = true)
    state.context = prev_context

    state.scope = old_scope
    let function = node.value.def_.function
    function.value.is_internal = true // So that generic functions don't show up in autocomplete
    function.polymorph = true
    for var tvar in type_variables {
        scope::create_dependency(function.value, tvar)
    }

    node.scope = context.module.scope
    // This makes sure that the function is walked by the compiler
    context.module.node.body.push(node)

    // Extra state for the repl
    if toolchain::is_in_repl {
        compiler::predeclare_function(function)
        consteval::const_module.result.functions(node.tpe.type_name) = function
        consteval::const_module.delayed_compile.push(node)
    }
    
    //if not in_context {
    //    super_scope.parent = builtins::builtins
    //}
    
    return node
}

// Stub types get replaced with actual types.
// When you are using a function with an unknown type in consteval it creates a stub type
// inside the current module. In typechecking we know the actual type which is inside the imports.
def lookup_stub_types(state: &State) {
    let scpe = state.scope
    for var key in @state.scope.fields.keys() {
        let value = state.scope.fields(key)
        if value.tpe and value.tpe.kind == TypeKind::TYPE {
            let tpe = value.value.value_tpe
            if tpe and tpe.kind == TypeKind::STUB and util::find_substr(tpe.type_name, "::", 0) == -1 {
                state.scope.fields.remove(key)
                var new_value = scope::get(scpe, parser::make_identifier(key), dry_run = true)
                if new_value and new_value.tpe.kind == TypeKind::TYPE {
                    @value.value.value_tpe = @new_value.value.value_tpe
                }
                state.scope.fields(key) = value
            }
        }
    }
}

export def typecheck(module: &toolchain::Module) {
    let state = make_state(module)
    module.state = state
    typecheck(state)
}

export def typecheck(state: &State) {

    toolchain::progress_update(state.module, toolchain::ProgressUpdate::START)

    let node = state.module.node
    assert(node.kind == parser::NodeKind::PROGRAM)

    node.scope = state.scope

    let string_array_tpe = array(builtins::string_)
    let args_ident = parser::make_identifier("args")

    // repl tries to define this multiple times 
    // so we need to skip the declaration if it already exists
    if not scope::get(node.scope, args_ident) {
        scope::create_variable(
            node.scope, 
            args_ident, 
            parser::ShareMarker::NONE, 
            parser::VarDecl::VAR, 
            string_array_tpe, null
        )
    }
    let args_value = scope::get(node.scope, args_ident)
    args_value.global = false
    args_value._assembly_name = "args"
    
    if not toolchain::is_preload(state.module) {
        // compile standard library
        toolchain::typecheck_module(parser::make_identifier("cstd"), state.module)
        toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)

        if not toolchain::no_stdlib {
            toolchain::typecheck_module(parser::make_identifier("std"), state.module)
            toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)

            toolchain::typecheck_module(parser::make_identifier("runtime"), state.module)
            toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)

            toolchain::typecheck_module(parser::make_identifier("optional"), state.module)
            toolchain::progress_update(state.module, toolchain::ProgressUpdate::CONTINUE)
        }
    }

    let ident = parser::make_identifier("__main__")
    ident.loc.module = state.module.module
    ident.loc.filename = state.module.filename
    ident.loc.line = 0
    ident.loc.column = 0

    let args = vector::make(NamedParameter)
    args.push([
        name = "args",
        _tpe = string_array_tpe
    ] !NamedParameter)

    let main_tpe = typechecking::make_function_type_n(ident, args, vector::make(type &typechecking::Type), state.module)
    let value = scope::create_function(node.scope, ident, parser::ShareMarker::EXPORT, main_tpe)
    value.identifier = ident

    node.value.program.function.value = value

    lookup_stub_types(state)
    typecheck(node, state)

    let keys = map::keys(node.scope.fields)
    for var i in 0..keys.size {
        var value = node.scope.fields.get_or_default(keys(i), null)
        while value {
            if value.phase == scope::Phase::DEFINED {
                scope::typecheck(value)
            }
            value = value.next
        }
    }

    toolchain::progress_update(state.module, toolchain::ProgressUpdate::END)
}

export def typecheck(node: &parser::Node, state: &State) {
    assert node.kind == parser::NodeKind::PROGRAM

    let function = node.value.program.function

    push_function(state, function)
    for var i in 0..vector::length(node.body) {
        let n = node.body(i)
        switch n.kind !int {
            case parser::NodeKind::TYPE_DECL, parser::NodeKind::DEF, parser::NodeKind::VAR_DECL
            case
                walk(node, n, state)
        }
    }
    pop_function(state)

    node.value.program.has_defer = function.has_defer
    node.value.program.locals = function.locals
}