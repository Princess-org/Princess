// TODO Eval is slow, and it would be much faster if we didn't serialize value back and forth

import vector
import map
import set as _set  // TODO Rename the function!
import util
import compiler
import typechecking
import scope
import builtins
import consteval
import toolchain
import debug
import errors
import preload
import ffi
import symbol
import arena
import codegen

export type StackFrame = struct {
    next: &compiler::Block
    jump_table: &SMap(&compiler::Block)
    locals: &SMap(*)
    function_name: Str
    line: int
    ret: compiler::Value
    mem: &arena::Arena
}

export def destruct(frame: *StackFrame) {
    frame.mem.free()
}

export type State = struct {
    temp_counter: int
    cstate: &compiler::State
    // Vector of StackFrame
    stack: &Vector(&StackFrame)
}

export type FunctionPtr = struct {
    is_fp: bool
    struct #union {
        fp: def ->
        function: &compiler::Function
    }
}

export def push_stack_frame(stack_frame: &StackFrame, state: &State) {
    state.stack.push(stack_frame)
}

export def pop_stack_frame(state: &State) {
    vector::pop(state.stack)
}

export def get_stack_frame(state: &State) -> &StackFrame {
    return vector::peek(state.stack)
}

def print_stack_trace(state: &State) {
    for var i in 0..vector::length(state.stack) {
        let frame = state.stack[vector::length(state.stack) - 1 - i]
        print(frame.function_name, ":", frame.line, "\n")
    }
}

export def make_stack_frame(block: &compiler::Block, name: Str, line: int) -> &StackFrame {
    let stack_frame = {
        locals = map::make(type *),
        function_name = name,
        line = line,
        jump_table = map::make(type &compiler::Block),
        mem = arena::make(1024) // TODO maybe calculate the size based on the local variables...
    } !&StackFrame

    while block {
        stack_frame.jump_table[block.label_] = block
        block = block.next
    }

    return stack_frame
}

export def get(mem: *, tpe: &typechecking::Type) -> compiler::Value {
    if not mem { return NO_VALUE }
    switch tpe.kind !int {
        case typechecking::TypeKind::WORD, typechecking::TypeKind::CHAR:
            let size = tpe.size
            var result: int64 = 0
            for var i in 0..size {
                result |= (@((mem !*uint8) ++ i) !uint64 << (i * 8))
            }
            if not tpe.unsig {
                let sign = (result >> ((size - 1) * 8)) & 0x80
                if sign {
                    for var i in size..(size_of int64) {
                        result |= 0xFF !int64 << (i * 8)
                    }
                }
            }
            return { kind = compiler::ValueKind::INT, tpe = tpe, i = result } !compiler::Value
        case typechecking::TypeKind::FLOAT:
            var result: double
            if tpe.size == (size_of float) {
                result = @(mem !*float) !double
            } else if tpe.size == (size_of double) {
                result = @(mem !*double)
            } else {
                assert(false)
            }
            return { kind = compiler::ValueKind::FLOAT, tpe = tpe, f = result } !compiler::Value
        case typechecking::TypeKind::BOOL:
            return { kind = compiler::ValueKind::BOOL, tpe = tpe, i = (@(mem !*bool)) !int64 } !compiler::Value
        case typechecking::TypeKind::POINTER:
            return { kind = compiler::ValueKind::POINTER, tpe = tpe, i = @(mem !*int64) } !compiler::Value
        case typechecking::TypeKind::REFERENCE, typechecking::TypeKind::WEAK_REF:
            let values = allocate_ref(compiler::Value, 3)
            values[0] = { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(builtins::size_t_), i = @(mem !*int64) } !compiler::Value
            values[1] = { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(tpe.tpe), i = @((mem ++ (size_of type *)) !*int64) } !compiler::Value
            values[2] = { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(builtins::Type_), i = @((mem ++ (size_of type *) * 2) !*int64) } !compiler::Value
            return { kind = compiler::ValueKind::STRUCT, tpe = tpe, values = values } !compiler::Value
        case typechecking::TypeKind::UNION:
            return get(mem, typechecking::make_static_array(builtins::int8_, tpe.size))
        case typechecking::TypeKind::STRUCT, typechecking::TypeKind::CLOSURE:
            let len = vector::length(tpe.field_types)
            let values = allocate_ref(compiler::Value, len)
            for var i in 0..len {
                let type_member = tpe.field_types[i]
                values[i] = get(mem ++ type_member.offset, type_member.tpe)
            }
            return { kind = compiler::ValueKind::STRUCT, tpe = tpe, values = values } !compiler::Value
        case typechecking::TypeKind::STATIC_ARRAY:
            if typechecking::equals(tpe.tpe, builtins::char_) {
                let str = allocate_ref(char, tpe.size)
                memcopy(mem, str.value, tpe.size)
                return { kind = compiler::ValueKind::STRING, tpe = tpe, s = str } !compiler::Value
            } else {
                let values = allocate_ref(compiler::Value, tpe.size / tpe.tpe.size)
                for var i in 0..values.size {
                    values[i] = get(mem, tpe.tpe)
                    mem = mem ++ tpe.tpe.size
                }
                return { kind = compiler::ValueKind::ARRAY, tpe = tpe, values = values } !compiler::Value
            }
        case typechecking::TypeKind::ARRAY:
            let values = allocate_ref(compiler::Value, 2)
            values[0] = { kind = compiler::ValueKind::INT, tpe = builtins::size_t_, i = @(mem !*int64) } !compiler::Value
            values[1] = { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(tpe.tpe), i = @((mem ++ (size_of size_t)) !*int64) } !compiler::Value
            return { kind = compiler::ValueKind::STRUCT, tpe = tpe, values = values } !compiler::Value
        case typechecking::TypeKind::FUNCTION:
            return { kind = compiler::ValueKind::FUNCTION, tpe = tpe, function = mem !*FunctionPtr } !compiler::Value
        case typechecking::TypeKind::ENUM:
            let value = get(mem, tpe.tpe)
            value.tpe = tpe
            return value
        case: assert(false)
    }
}

export def get_address(loc: compiler::Value, state: &State) -> * {
    if loc.kind == compiler::ValueKind::LOCAL {
        let mem = get_stack_frame(state).locals.get_or_default(loc.name, null)
        if not mem {
            errors::errorv("Couldn't find memory for `", loc.name, "`")
        }
        return mem
    } else if loc.kind == compiler::ValueKind::GLOBAL {
        assert(typechecking::is_pointer(loc.tpe))
        var mem = state.cstate.globals.get_or_default(loc.name, null)
        if not mem {
            var ptr: *

            var function = consteval::const_module.result.functions.get_or_default(loc.name, null)
            if function {
                ptr = state.cstate.mem.allocate(FunctionPtr)
                (ptr !*FunctionPtr).function = function
                //set(ptr, loc.tpe.tpe, { kind = compiler::ValueKind::FUNCTION, tpe = loc.tpe.tpe, function = (ptr !*FunctionPtr) } !compiler::Value)
            } else {
                let ffi_global = preload::symbols.get_or_default(loc.name, null)
                if ffi_global and ffi_global.kind == preload::SymbolKind::VARIABLE {
                    ptr = ffi_global.variable
                } else {
                    var global = state.cstate.module.result.globals.get_or_default(loc.name, null)
                    if not global {
                        global = consteval::const_module.result.globals.get_or_default(loc.name, null)
                    }
                    if not global {
                        errors::errorv("Global by the name of `", loc.name, "` not found")
                        return null
                    } else {
                        ptr = state.cstate.mem.allocate(loc.tpe.tpe.size)
                        if global.value {
                            set(ptr, loc.tpe.tpe, @global.value)
                        }
                    }
                }
            }

            mem = state.cstate.mem.allocate(loc.tpe.size)
            let value = { kind = compiler::ValueKind::POINTER, tpe = loc.tpe, i = ptr !int64 } !compiler::Value
            set(mem, loc.tpe, value)
            state.cstate.globals[loc.name] = mem
        }
        return mem
    }
    return null
}

export def get_value(loc: compiler::Value, state: &State) -> compiler::Value {
    if loc.kind == compiler::ValueKind::LOCAL or loc.kind == compiler::ValueKind::GLOBAL {
        let mem = get_address(loc, state)
        return get(mem, loc.tpe)
    } else {
        return loc
    }
}

def set(mem: *, tpe: &typechecking::Type, value: compiler::Value) {
    if not mem { 
        errors::errorv("Tried to assign a null pointer")
        return
    }
    if not tpe { return }
    if value.kind == compiler::ValueKind::UNDEF { return }
    if value.kind == compiler::ValueKind::ZEROINITIALIZER {
        cstd::memset(mem, 0, tpe.size)
        return
    }
    switch tpe.kind !int {
        case typechecking::TypeKind::WORD, typechecking::TypeKind::CHAR:
            var v = value.i
            let size = tpe.size
            for var i in 0..size {
                @(mem !*uint8 ++ i) = (v >> (i * 8)) !uint8
            }
        case typechecking::TypeKind::FLOAT:
            if tpe.size == (size_of float) {
                @(mem !*float) = value.f !float
            } else if tpe.size == (size_of double) {
                @(mem !*double) = value.f
            } else {
                assert(false)
            }
        case typechecking::TypeKind::POINTER:
            (@(mem !*int64)) = value.i
        case typechecking::TypeKind::REFERENCE, typechecking::TypeKind::WEAK_REF:
            @(mem !*int64) = value.values[0].i
            @((mem ++ (size_of type *)) !*int64) = value.values[1].i
            @((mem ++ (size_of type *) * 2) !*int64) = value.values[2].i
        case typechecking::TypeKind::BOOL:
            (@(mem !*int8)) = value.i !int8
        case typechecking::TypeKind::STRUCT, typechecking::TypeKind::CLOSURE:
            for var i in 0..vector::length(tpe.field_types) {
                let type_member = tpe.field_types[i]
                set(mem ++ type_member.offset, type_member.tpe, value.values[i])
            }
        case typechecking::TypeKind::UNION:
            set(mem, typechecking::make_static_array(builtins::int8_, tpe.size), value)
        case typechecking::TypeKind::STATIC_ARRAY:
            if typechecking::equals(tpe.tpe, builtins::char_) and value.kind == compiler::ValueKind::STRING {
                memcopy(value.s.value, mem, tpe.length)
            } else {
                for var i in 0..value.values.size {
                    let value = value.values[i]
                    set(mem, tpe.tpe, value)
                    mem = mem ++ tpe.tpe.size
                }
            }
        case typechecking::TypeKind::ARRAY:
            // TODO Implementation specific
            @(mem !*size_t) = value.values[0].i !size_t
            @((mem ++ (size_of size_t)) !*int64) = value.values[1].i
        case typechecking::TypeKind::FUNCTION:
            @(mem !*FunctionPtr) = @value.function
        case typechecking::TypeKind::ENUM:
            set(mem, tpe.tpe, value)
        case:
            error(tpe.kind, "\n") 
            assert(false)
    }
}

export def set_value(loc: compiler::Value, value: compiler::Value, state: &State) {
    if loc.kind == compiler::ValueKind::LOCAL {
        var mem = get_stack_frame(state).locals.get_or_default(loc.name, null)
        if not mem {
            let frame = get_stack_frame(state)
            mem = frame.mem.allocate(loc.tpe.size)
            frame.locals[loc.name] = mem
        }
        set(mem, loc.tpe, value)
    } else if loc.kind == compiler::ValueKind::GLOBAL {
        var mem = state.cstate.globals.get_or_default(loc.name, null)
        var ptr: * = null
        if not mem {
            mem = state.cstate.mem.allocate(loc.tpe.size)
            state.cstate.globals[loc.name] = mem
            ptr = state.cstate.mem.allocate(loc.tpe.tpe.size)
            set(mem, loc.tpe, { kind = compiler::ValueKind::POINTER, tpe = loc.tpe, i = ptr !int64 } !compiler::Value)
        } else {
            ptr = get(mem, loc.tpe).i !*
        }
        set(ptr, loc.tpe.tpe, value)
    } else {
        assert(false)
    }
}

def unwrap_undef(value: compiler::Value) -> compiler::Value {
    if value.kind == compiler::ValueKind::UNDEF or value.kind == compiler::ValueKind::ZEROINITIALIZER {
        if value.tpe.kind == typechecking::TypeKind::STRUCT or value.tpe.kind == typechecking::TypeKind::CLOSURE {
            let values = allocate_ref(compiler::Value, value.tpe.fields.size)
            for var i in 0..value.tpe.fields.size {
                let field = value.tpe.fields[i]
                values[i] = unwrap_undef({ kind = compiler::ValueKind::UNDEF, tpe = field.tpe } !compiler::Value)
            }
            value = { kind = compiler::ValueKind::STRUCT, tpe = value.tpe, values = values } !compiler::Value
        } else if value.tpe.kind == typechecking::TypeKind::UNION {
            let values = allocate_ref(compiler::Value, 1)
            let type_member = value.tpe.field_types[0]
            values[0] = unwrap_undef({ kind = compiler::ValueKind::UNDEF, tpe = type_member.tpe } !compiler::Value)
            value = { kind = compiler::ValueKind::STRUCT, tpe = value.tpe, values = values } !compiler::Value
        } else if value.tpe.kind == typechecking::TypeKind::ARRAY {
            let values = allocate_ref(compiler::Value, 2)
            values[0] = { kind = compiler::ValueKind::UNDEF, tpe = builtins::size_t_ } !compiler::Value
            values[1] = { kind = compiler::ValueKind::UNDEF, tpe = typechecking::pointer(value.tpe.tpe) } !compiler::Value
            value = { kind = compiler::ValueKind::ARRAY, tpe = value.tpe, values = values } !compiler::Value
        } else if value.tpe.kind == typechecking::TypeKind::REFERENCE or value.tpe.kind == typechecking::TypeKind::WEAK_REF {
            let values = allocate_ref(compiler::Value, 3)
            values[0] = { kind = compiler::ValueKind::UNDEF, tpe = typechecking::pointer(builtins::size_t_) } !compiler::Value
            values[1] = { kind = compiler::ValueKind::UNDEF, tpe = typechecking::pointer(value.tpe.tpe) } !compiler::Value
            values[2] = { kind = compiler::ValueKind::UNDEF, tpe = typechecking::pointer(builtins::Type_) } !compiler::Value
            value = { kind = compiler::ValueKind::STRUCT, tpe = value.tpe, values = values } !compiler::Value
        }
    }
    return value
}

def eval_InsertValue(insn: &compiler::Insn, state: &State) {
    // We need a deep copy here because we don't want to modify the operand,
    // if we didn't do this, the operation would fail when executed multiple times
    let value = unwrap_undef(compiler::copy(get_value(insn.value.insert_value.value, state)))
    let element = get_value(insn.value.insert_value.element, state)
    let ret = insn.value.insert_value.ret
    let index = insn.value.insert_value.index

    var to_set = *value
    for var i in 0..index.size {
        let j = index[i]
        if typechecking::is_struct(to_set.tpe) or 
            to_set.tpe.kind == typechecking::TypeKind::REFERENCE or 
            to_set.tpe.kind == typechecking::TypeKind::WEAK_REF or
            to_set.tpe.kind == typechecking::TypeKind::ARRAY or
            to_set.tpe.kind == typechecking::TypeKind::CLOSURE {
            
            to_set = *to_set.values[j]
        } else if to_set.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            if typechecking::equals(to_set.tpe.tpe, builtins::char_) {
                to_set.s[j] = element.i !char // TODO Can we assume this? Verify somehow
            } else {
                to_set = *to_set.values[j]
            }
        } else {
            assert(false)
        }
    }
    @to_set = element

    set_value(ret, value, state)
}

def eval_ExtractValue(insn: &compiler::Insn, state: &State) {
    let value = get_value(insn.value.extract_value.value, state)
    let ret = insn.value.extract_value.ret
    let index = insn.value.extract_value.index

    var to_get = value
    for var i in 0..index.size {
        let j = index[i]
        if typechecking::is_struct(to_get.tpe) or 
            to_get.tpe.kind == typechecking::TypeKind::ARRAY or
            to_get.tpe.kind == typechecking::TypeKind::REFERENCE or 
            to_get.tpe.kind == typechecking::TypeKind::WEAK_REF or
            to_get.tpe.kind == typechecking::TypeKind::CLOSURE {
            
            to_get = to_get.values[j]
        } else if to_get.tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            if typechecking::equals(to_get.tpe.tpe, builtins::char_) {
                to_get = { kind = compiler::ValueKind::INT, tpe = builtins::char_, i = to_get.s[j] !int64 } !compiler::Value
            } else {
                to_get = to_get.values[j]
            }
        } else {
            assert(false)
        }
    }

    set_value(ret, to_get, state)
}

def eval_GetElementPtr(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.gep.ret
    let value = insn.value.gep.value
    let index = insn.value.gep.index

    var tpe =  insn.value.gep.tpe
    var addr = get(get_address(value, state), value.tpe).i !* ++ (get_value(index[0], state).i * tpe.size)

    for var i in 1..index.size {
        let index = get_value(index[i], state).i
        if tpe.kind == typechecking::TypeKind::STRUCT or tpe.kind == typechecking::TypeKind::CLOSURE {
            let len = vector::length(tpe.field_types)
            assert(index < len)
            let type_member = tpe.field_types[index]
            addr = addr ++ type_member.offset
            tpe = type_member.tpe
        } else if tpe.kind == typechecking::TypeKind::UNION {
            assert(index == 0)
            tpe = typechecking::make_static_array(builtins::int8_, tpe.size)
        } else if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            assert(index < tpe.length)
            addr = addr ++ tpe.tpe.size * index
            tpe = tpe.tpe
        } else if tpe.kind == typechecking::TypeKind::ARRAY {
            if index == 0 {
                tpe = builtins::size_t_
            } else if index == 1 {
                addr = addr ++ (size_of size_t)
                tpe = tpe.tpe
            } else {
                assert(false)
            }
        } else if tpe.kind == typechecking::TypeKind::REFERENCE {
            if index == 0 {
                tpe = typechecking::pointer(builtins::size_t_)
            } else if index == 1 {
                addr = addr ++ (size_of type *)
                tpe = tpe.tpe
            } else if index == 2 {
                addr = addr ++ (size_of type *) * 2
                tpe = typechecking::pointer(builtins::Type_)
            }
        } else {
            error(tpe.kind, "\n")
            assert(false)
        }
    }

    //assert(ret.kind == compiler::ValueKind::LOCAL)
    //get_stack_frame(state).locals[ret.name] = addr
    set_value(ret, { kind = compiler::ValueKind::POINTER, tpe = typechecking::pointer(tpe), i = addr !int64 } !compiler::Value, state)
}

def eval_Convert(insn: &compiler::Insn, state: &State) {
    // This is basically a noop
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, value, state)
}

// TODO These functions should be made faster by directly working with the memory
def eval_Load(insn: &compiler::Insn, state: &State) {
    let loc = insn.value.load.loc
    let mem = get_address(loc, state)
    let ptr = get(mem, loc.tpe).i !*
    let value = get(ptr, loc.tpe.tpe)
    set_value(insn.value.load.value, value, state)
}

def eval_Store(insn: &compiler::Insn, state: &State) {
    let loc = insn.value.store.loc
    let mem = get_address(loc, state)
    let ptr = get(mem, loc.tpe).i !*
    let value = get_value(insn.value.store.value, state)
    set(ptr, value.tpe, value)
}

def eval_Alloca(insn: &compiler::Insn, state: &State) {
    let frame = get_stack_frame(state)
    let ret = insn.value.alloca.ret

    let mem = frame.mem.allocate(ret.tpe.size) // TODO: We shouldn't have to initialize this
    ret.tpe = typechecking::pointer(ret.tpe)
    let ptr = { kind = compiler::ValueKind::POINTER, tpe = ret.tpe, i = mem !int64 } !compiler::Value
    let addr = frame.mem.allocate(ret.tpe.size)
    frame.locals[ret.name] = addr
    set(addr, ret.tpe, ptr)
}

def eval_FAdd(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f + right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FSub(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f - right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FMul(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f * right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FRem(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f % right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FDiv(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret 

    var result = left.f / right.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_FNeg(insn: &compiler::Insn, state: &State) {
    let value = get_value(insn.value.fneg.value, state)
    let ret = insn.value.fneg.ret 

    var result = -value.f
    set_value(ret, { kind = ValueKind::FLOAT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_SRem(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i % right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_URem(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = (left.i !uint64 % right.i !uint64) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Add(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i + right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Sub(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i - right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_AShr(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i >> right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_LShr(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = (left.i !uint64 >> right.i) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Shl(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i << right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_And(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i & right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Or(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i | right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_XOr(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i ^ right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}


def eval_Mul(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i * right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_SDiv(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i / right.i
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_UDiv(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.arith.left, state)
    let right = get_value(insn.value.arith.right, state)
    let ret = insn.value.arith.ret

    var result = left.i !uint64 / right.i !uint64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_ICmp(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.icmp.left, state)
    let right = get_value(insn.value.icmp.right, state)
    let ret = insn.value.icmp.ret
    let op = insn.value.icmp.op

    var result = false
    if op == compiler::CompareInt::eq {
        result = left.i == right.i
    } else if op == compiler::CompareInt::ne {
        result = left.i != right.i
    } else if op == compiler::CompareInt::ugt {
        result = left.i !uint64 > right.i !uint64
    } else if op == compiler::CompareInt::uge {
        result = left.i !uint64 >= right.i !uint64
    } else if op == compiler::CompareInt::ult {
        result = left.i !uint64 < right.i !uint64
    } else if op == compiler::CompareInt::ule {
        result = left.i !uint64 <= right.i !uint64
    } else if op == compiler::CompareInt::sgt {
        result = left.i > right.i
    } else if op == compiler::CompareInt::sge {
        result = left.i >= right.i
    } else if op == compiler::CompareInt::slt {
        result = left.i < right.i
    } else if op == compiler::CompareInt::sle {
        result = left.i <= right.i
    } else {
        assert(false)
    }

    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result !int64 } !compiler::Value, state)
}

def eval_FCmp(insn: &compiler::Insn, state: &State) {
    let left = get_value(insn.value.fcmp.left, state)
    let right = get_value(insn.value.fcmp.right, state)
    let ret = insn.value.fcmp.ret
    let op = insn.value.fcmp.op

    var result = false
    if op == compiler::CompareFloat::ueq {
        result = left.f == right.f
    } else if op == compiler::CompareFloat::une {
        result = left.f != right.f
    } else if op == compiler::CompareFloat::ugt {
        result = left.f > right.f
    } else if op == compiler::CompareFloat::uge {
        result = left.f >= right.f
    } else if op == compiler::CompareFloat::ult {
        result = left.f < right.f
    } else if op == compiler::CompareFloat::ule {
        result = left.f <= right.f
    } else {
        assert(false)
    }

    set_value(ret, { kind = ValueKind::BOOL, tpe = ret.tpe, i = result !int64 } !compiler::Value, state)
}

// TODO
def struct_to_ffi(tpe: &typechecking::Type) -> ffi::s__ffi_type {
    assert(false)
    return ffi::ffi_type_void
}

def union_to_ffi(tpe: &typechecking::Type) -> ffi::s__ffi_type {
    assert(false)
    return ffi::ffi_type_void
}

def type_to_ffi(tpe: &typechecking::Type, varargs: bool = false) -> ffi::s__ffi_type {
    if not tpe {
        return ffi::ffi_type_void
    } else if tpe.kind == typechecking::TypeKind::STRUCT {
        return struct_to_ffi(tpe)
    } else if tpe.kind == typechecking::TypeKind::UNION {
        return union_to_ffi(tpe)
    } else if typechecking::is_enum(tpe) {
        return type_to_ffi(tpe.tpe)
    } else if typechecking::is_pointer(tpe) {
        return ffi::ffi_type_pointer
    } else if typechecking::equals(tpe, builtins::char_) {
        return ffi::ffi_type_uint8
    } else if typechecking::equals(tpe, builtins::int8_) {
        return ffi::ffi_type_sint8
    } else if typechecking::equals(tpe, builtins::uint8_) {
        return ffi::ffi_type_uint8
    } else if typechecking::equals(tpe, builtins::int16_) {
        return ffi::ffi_type_sint16
    } else if typechecking::equals(tpe, builtins::uint16_) {
        return ffi::ffi_type_uint16
    } else if typechecking::equals(tpe, builtins::int32_) {
        return ffi::ffi_type_sint32
    } else if typechecking::equals(tpe, builtins::uint32_) {
        return ffi::ffi_type_uint32
    } else if typechecking::equals(tpe, builtins::int64_) {
        return ffi::ffi_type_sint64
    } else if typechecking::equals(tpe, builtins::uint64_) {
        return ffi::ffi_type_uint64
    } else if typechecking::equals(tpe, builtins::float_) {
        return ffi::ffi_type_float
    } else if typechecking::equals(tpe, builtins::double_) {
        return ffi::ffi_type_double
    } else if typechecking::equals(tpe, builtins::bool_) {
        return ffi::ffi_type_sint8
    } else {
        error(debug::type_to_str(tpe), "\n")
        assert(false)
    }
}

// ARGH C Why
def promote(tpe: &typechecking::Type) -> &typechecking::Type {
    if typechecking::equals(tpe, builtins::float_) { return builtins::double_ }
    if (tpe.kind == typechecking::TypeKind::WORD or tpe.kind == typechecking::TypeKind::CHAR) and tpe.size < builtins::int_.size {
        if tpe.unsig { return builtins::uint_ }
        return builtins::int_
    }
    return tpe
}

def ffi_call(args: &[compiler::Value], ret: compiler::Value, parameter_t: &Vector(typechecking::NamedParameter), ret_tpe: &typechecking::Type, ffi_function: &symbol::Symbol, varargs: bool, state: &State) {
    let function = preload::get_function(ffi_function)
    if not function {
        errors::errorv("Failed to find function ", ffi_function.name)
        return
    }

    let ffi_cif = *ffi_function.ffi_cif
    var ffi_args: **ffi::s__ffi_type
    var ffi_ret_tpe: *ffi::s__ffi_type

    if varargs or not ffi_function.initialized {
        ffi_args = allocate((size_of type *ffi::s__ffi_type) * args.size) !**ffi::s__ffi_type
        for var i in 0..args.size {
            var tpe = args[i].tpe
            if varargs { tpe = promote(tpe) }
            let ffi_tpe = allocate(ffi::s__ffi_type)
            @ffi_tpe = type_to_ffi(tpe)
            ffi_args[i] = ffi_tpe
        }
        ffi_ret_tpe = allocate(ffi::s__ffi_type)
        @ffi_ret_tpe = type_to_ffi(ret_tpe)

        ffi_function.arglen = args.size
        ffi_function.args = ffi_args
        ffi_function.ret = ffi_ret_tpe
    }
    

    var status: ffi::e_ffi_status = ffi::e_ffi_status::FFI_OK
    if varargs {
        status = ffi::ffi_prep_cif_var(ffi_cif, ffi::e_ffi_abi::FFI_DEFAULT_ABI, (vector::length(parameter_t) - 1) !uint, args.size !uint, ffi_ret_tpe, ffi_args)
    } else if not ffi_function.initialized {
        status = ffi::ffi_prep_cif(ffi_cif, ffi::e_ffi_abi::FFI_DEFAULT_ABI, args.size !uint, ffi_ret_tpe, ffi_args)
        ffi_function.initialized = true
    }

    if status != ffi::e_ffi_status::FFI_OK {
        errors::errorv("Failed to prepare ffi for function `", ffi_function.name, "`. Status: ", status.to_string())
        return
    }

    let avalues = allocate((size_of type *) * args.size) !**
    for var i in 0..args.size {
        var arg = args[i]
        if arg.kind == compiler::ValueKind::LOCAL or arg.kind == compiler::ValueKind::GLOBAL {
            arg = get(get_address(arg, state), arg.tpe)
        }
        
        var tpe = arg.tpe
        if varargs { tpe = promote(tpe) }

        let mem = allocate(tpe.size)
        set(mem, tpe, arg)
        avalues[i] = mem
    } 

    var rvalue: * = null
    if ret.tpe {
        // TODO Define the register size somewhere
        var size = 8 !size_t
        if ret_tpe.size > size {
            size = ret_tpe.size
        }
        let frame = get_stack_frame(state)
        rvalue = frame.mem.allocate(size)
        // TODO This will fail for function pointers
        frame.locals[ret.name] = rvalue
    }
    
    ffi::ffi_call(ffi_cif, function, rvalue, avalues)

    if varargs {
        // Cleanup
        for var i in 0..args.size {
            free(ffi_args[i])
        }
        free(ffi_args)
        free(ffi_ret_tpe)
    }

    for var i in 0..args.size {
        free(avalues[i])
    }
    free(avalues)
}

def eval_Call(insn: &compiler::Insn, state: &State) {
    let call = insn.value.call.name 
    let args = insn.value.call.args
    let ret = insn.value.call.ret
   
    var name = call.name
    var fp: *FunctionPtr = null

    if call.kind == compiler::ValueKind::LOCAL {
        let mem = get_address(call, state)
        let value = get(get(mem, call.tpe).i !*, call.tpe.tpe)
        fp = value.function
    } else if call.kind == compiler::ValueKind::GLOBAL {
        if starts_with(name, "llvm.") { return }
        var function = consteval::const_module.result.functions.get_or_default(name, null)
        if function {
            let functionptr = { is_fp = false } !FunctionPtr
            functionptr.function = function
            fp = *functionptr
        } else {
            let mem = get_address(call, state)
            let value = get(get(mem, call.tpe).i !*, call.tpe.tpe)
            fp = value.function
        }
    }

    if not fp {
        errors::errorv("Function `", name, "` not found")
        return
    }
    
    /*print(name, " ")
    for var i in 0..args.size {
        print(debug::type_to_str(args[i].tpe), " ")
    }
    print("\n")*/

    if fp.is_fp {
        let ffi_function = {
            name = @name.to_array(),
            function = fp.fp
        } !symbol::Symbol

        var varargs = false
        var ret_tpe: &typechecking::Type = null
        if vector::length(call.tpe.return_t) >= 1 {
            ret_tpe = call.tpe.return_t[0]
        }
        if vector::length(call.tpe.parameter_t) > 0 {
            let last_arg = vector::peek(call.tpe.parameter_t) 
            varargs = last_arg.varargs
        }
        ffi_call(args, ret, call.tpe.parameter_t, ret_tpe, ffi_function, varargs, state)
    } else {
        let function = fp.function
        if function.imported {
            let ffi_function = preload::symbols[name]
            
            ffi_call(args, ret, function.args, function.ret, ffi_function, function.varargs, state)
        } else {
            let module = state.cstate.module
            state.cstate.module = function.module

            var line = 1
            if insn.debug {
                // TODO This points to another file
                let debug_value = function.module.result.metadata.get_or_default(insn.debug.name, null)
                if debug_value and debug_value.debug_values.value {
                    line = debug_value.debug_values[0].value.i !int 
                }
            }

            let stack_frame = make_stack_frame(function.block, name, line)

            for var i in 0..args.size {
                let arg = args[i]
                let np = function.args[i]
                let arg_value = get_value(arg, state)
                let mem = stack_frame.mem.allocate(arg.tpe.size)
                
                let name = np.name + ".value"
                stack_frame.locals[name] = mem
                set(mem, arg.tpe, arg_value)
            }

            push_stack_frame(stack_frame, state)

            /*print(function.name, "\n")
            print("==========================\n")
            var block = function.block
            while block {
                codegen::emit_block(std::stdout(), block)
                block = block.next
            }*/

            eval(function.block, state)

            if ret.tpe {
                let ret_value = get_value(stack_frame.ret, state)
                pop_stack_frame(state)

                set_value(ret, ret_value, state)
            } else {
                pop_stack_frame(state)
            }
            state.cstate.module = module
        }
    }
    
}

def eval_Ret(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.ret.value
    let stack_frame = get_stack_frame(state)
    stack_frame.ret = get_value(ret, state)
    stack_frame.next = null
}

def eval_BrUnc(insn: &compiler::Insn, state: &State) {
    let label_ = insn.value.br_unc.label_
    let stack_frame = get_stack_frame(state)
    stack_frame.next = stack_frame.jump_table[label_.name]
}

def eval_Br(insn: &compiler::Insn, state: &State) {
    let if_true = insn.value.br.if_true
    let if_false = insn.value.br.if_false
    
    let cond = get_value(insn.value.br.cond, state)
    assert(cond.kind == compiler::ValueKind::BOOL)
    
    let stack_frame = get_stack_frame(state)
    if cond.i {
        stack_frame.next = stack_frame.jump_table[if_true.name]
    } else {
        stack_frame.next = stack_frame.jump_table[if_false.name]
    }
}

def eval_Switch(insn: &compiler::Insn, state: &State) {
    let value = get_value(insn.value.switch_.value, state)
    let switch_values = insn.value.switch_.switch_values
    let otherwise = insn.value.switch_.otherwise

    let stack_frame = get_stack_frame(state)
    for var i in 0..vector::length(switch_values) {
        let sw = switch_values[i]
        if sw.value.i == value.i {
            stack_frame.next = stack_frame.jump_table[sw.label_.name] 
            return
        }
    }

    stack_frame.next = stack_frame.jump_table[otherwise.name]
}

def eval_Fptoui(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = (value.f !uint64) !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Fptosi(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = value.f !int64
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = result } !compiler::Value, state)
}

def eval_Uitofp(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = (value.i !uint64) !double
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_Sitofp(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    let result = value.i !double
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, f = result } !compiler::Value, state)
}

def eval_Ptrtoint(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, { kind = ValueKind::INT, tpe = ret.tpe, i = value.i } !compiler::Value, state) 
}

def eval_Inttoptr(insn: &compiler::Insn, state: &State) {
    let ret = insn.value.convert.ret
    let value = get_value(insn.value.convert.value, state)
    set_value(ret, { kind = ValueKind::POINTER, tpe = ret.tpe, i = value.i } !compiler::Value, state) 
}

def eval_insn(insn: &compiler::Insn, state: &State) {
    switch insn.kind !int {
        case compiler::InsnKind::INSERTVALUE:
            eval_InsertValue(insn, state)
        case compiler::InsnKind::EXTRACTVALUE:
            eval_ExtractValue(insn, state)
        case compiler::InsnKind::GETELEMENTPTR:
            eval_GetElementPtr(insn, state)
        case compiler::InsnKind::PTRTOINT:
            eval_Ptrtoint(insn, state)
        case compiler::InsnKind::INTTOPTR:
            eval_Inttoptr(insn, state)
        case compiler::InsnKind::TRUNC, compiler::InsnKind::SEXT, 
            compiler::InsnKind::ZEXT, compiler::InsnKind::FPTRUNC, 
            compiler::InsnKind::FPEXT, compiler::InsnKind::BITCAST:
            eval_Convert(insn, state)
        case compiler::InsnKind::FPTOUI:
            eval_Fptoui(insn, state)
        case compiler::InsnKind::FPTOSI:
            eval_Fptosi(insn, state)
        case compiler::InsnKind::UITOFP:
            eval_Uitofp(insn, state)
        case compiler::InsnKind::SITOFP:
            eval_Sitofp(insn, state)
        case compiler::InsnKind::SREM:
            eval_SRem(insn, state)
        case compiler::InsnKind::UREM:
            eval_URem(insn, state)
        case compiler::InsnKind::ASHR:
            eval_AShr(insn, state)
        case compiler::InsnKind::LSHR:
            eval_LShr(insn, state)
        case compiler::InsnKind::SHL:
            eval_Shl(insn, state)
        case compiler::InsnKind::AND:
            eval_And(insn, state)
        case compiler::InsnKind::OR:
            eval_Or(insn, state)
        case compiler::InsnKind::XOR:
            eval_XOr(insn, state)
        case compiler::InsnKind::ADD:
            eval_Add(insn, state)
        case compiler::InsnKind::SUB:
            eval_Sub(insn, state)
        case compiler::InsnKind::MUL:
            eval_Mul(insn, state)
        case compiler::InsnKind::SDIV:
            eval_SDiv(insn, state)
        case compiler::InsnKind::UDIV:
            eval_UDiv(insn, state)
        case compiler::InsnKind::FADD:
            eval_FAdd(insn, state)
        case compiler::InsnKind::FSUB:
            eval_FSub(insn, state) 
        case compiler::InsnKind::FMUL:
            eval_FMul(insn, state)
        case compiler::InsnKind::FREM:
            eval_FRem(insn, state)
        case compiler::InsnKind::FDIV:
            eval_FDiv(insn, state)
        case compiler::InsnKind::FNEG:
            eval_FNeg(insn, state)
        case compiler::InsnKind::FCMP:
            eval_FCmp(insn, state)
        case compiler::InsnKind::ICMP:
            eval_ICmp(insn, state)
        case compiler::InsnKind::ALLOCA:
            eval_Alloca(insn, state)
        case compiler::InsnKind::STORE:
            eval_Store(insn, state)
        case compiler::InsnKind::LOAD:
            eval_Load(insn, state)
        case compiler::InsnKind::CALL:
            eval_Call(insn, state)
        case compiler::InsnKind::RET:
            eval_Ret(insn, state)
        case compiler::InsnKind::BR_UNC:
            eval_BrUnc(insn, state)
        case compiler::InsnKind::BR:
            eval_Br(insn, state)
        case compiler::InsnKind::SWITCH:
            eval_Switch(insn, state)
        case compiler::InsnKind::UNREACHABLE:
            errors::errorv("Reached unreachable instruction")
        case:
            error(insn.kind, "\n") 
            assert(false)
    }
}

export def print_block(block: &compiler::Block) {
    if not block {
        print("<EMPTY>\n")
        return
    }
    for var i in 0..vector::length(block.insn) {
        let insn = block.insn[i]
        if insn.kind == compiler::InsnKind::LOAD {
            print(insn.value.load.value.name, " <- ", insn.kind, " ", insn.value.load.loc.name, "\n")
        } else if insn.kind == compiler::InsnKind::ALLOCA {
            print(insn.kind, " ", insn.value.alloca.ret.name, "\n")
        } else if insn.kind == compiler::InsnKind::STORE {
            print(insn.kind, " ", insn.value.store.loc.name, " ", insn.value.store.value.name, "\n")
        } else if insn.kind == compiler::InsnKind::CALL and insn.value.call.name.kind == compiler::ValueKind::GLOBAL {
            print(insn.value.call.ret.name, " <- ", insn.kind, " ", insn.value.call.name.name, "\n")
        } else if insn.kind == compiler::InsnKind::RET and insn.value.ret.value.kind == compiler::ValueKind::LOCAL {
            print(insn.kind, " ", insn.value.ret.value.name, "\n")
        } else {
            print(insn.kind, "\n")
        }
    }
    print("\n")
}

def eval_block(block: &compiler::Block, state: &State) {
    let stack_frame = get_stack_frame(state)
    stack_frame.next = block.next
    for var i in 0..vector::length(block.insn) {
        let insn = block.insn[i]
        eval_insn(insn, state)
    }
}

export def eval(block: &compiler::Block, state: &State) {
    let stack_frame = get_stack_frame(state)
    while block {
        eval_block(block, state)
        block = stack_frame.next
    }
}

// Turn pointers into their own constants
// the first parameter is an out value, you need to pass true and it gets set to false if any of the 
// sub expressions of value is not a constant (pointers and arrays)
def serialize(is_constant: *bool, value: compiler::Value, global: &compiler::Global, index: &Vector(compiler::Value), module: &toolchain::Module, cstate: &compiler::State) -> compiler::Value {
    if value.kind == compiler::ValueKind::POINTER {
        @is_constant = false

        var loc: compiler::Value
        if vector::length(index) > 0 {
            loc = compiler::make_local_value(typechecking::pointer(value.tpe), null, cstate)

            let gep = compiler::make_insn(compiler::InsnKind::GETELEMENTPTR)
            let index_array = allocate_ref(compiler::Value, vector::length(index) + 1)
            index_array[0] = compiler::make_int_value(0)
            for var i in 0..vector::length(index) {
                index_array[i + 1] = index[i]
            }
            gep.value.gep = {
                ret = loc,
                tpe = global.tpe,
                value = { kind = compiler::ValueKind::GLOBAL, name = global.name, tpe = typechecking::pointer(global.tpe) } !compiler::Value,
                index = index_array
            } !compiler::InsnGetElementPtr
            compiler::push_insn(gep, cstate)
        } else {
            loc = { kind = compiler::ValueKind::GLOBAL, name = global.name, tpe = global.tpe } !compiler::Value
        }

        let new_global = {
            private = true,
            name = compiler::make_global_name("const", cstate),
            tpe = value.tpe.tpe,
            line = -1
        } !&compiler::Global
        module.result.globals[new_global.name] = new_global
        
        new_global.value = serialize(is_constant, get(value.i !*, value.tpe.tpe), new_global, vector::make(compiler::Value), module, cstate)
        
        let store = compiler::make_insn(compiler::InsnKind::STORE)
        store.value.store = {
            value = { kind = compiler::ValueKind::GLOBAL, tpe = value.tpe, name = new_global.name } !compiler::Value,
            loc = loc
        } !compiler::InsnStore
        compiler::push_insn(store, cstate)

        return { kind = compiler::ValueKind::UNDEF, tpe = value.tpe } !compiler::Value
    } else if value.kind == compiler::ValueKind::STRUCT and value.tpe.kind == typechecking::TypeKind::ARRAY {
        @is_constant = false

        let length = value.values[0].i
        let ptr = value.values[1].i !*
        let values = allocate_ref(compiler::Value, length)
        let array_value = { kind = compiler::ValueKind::ARRAY, tpe = value.tpe, values = values } !compiler::Value
        
        let tpe = typechecking::make_type_raw(typechecking::TypeKind::STATIC_ARRAY)
        tpe._tpe = builtins::char_
        tpe.length = length
        tpe.size = tpe.length * value.tpe.tpe.size
        tpe.align = value.tpe.tpe.align

        let new_global = {
            private = true,
            name = compiler::make_global_name("const", cstate),
            tpe = tpe,
            line = -1
        } !&compiler::Global
        module.result.globals[new_global.name] = new_global

        for var i in 0..length {
            let new_index = vector::make(compiler::Value)
            new_index.push(compiler::make_int_value(i))
            values[i] = serialize(is_constant, get(ptr ++ value.tpe.tpe.size * i, value.tpe.tpe), new_global, new_index, module, cstate)
        }

        let loc = compiler::make_local_value(typechecking::pointer(typechecking::pointer(value.tpe.tpe)), null, cstate)
        let gep = compiler::make_insn(compiler::InsnKind::GETELEMENTPTR)
        let index_array = allocate_ref(compiler::Value, vector::length(index) + 2)
        index_array[0] = compiler::make_int_value(0)
        for var i in 0..vector::length(index) {
            index_array[i + 1] = index[i]
        }
        index_array[vector::length(index) + 1] = compiler::make_int_value(1)
        gep.value.gep = {
            ret = loc,
            tpe = global.tpe,
            value = { kind = compiler::ValueKind::GLOBAL, name = global.name, tpe = typechecking::pointer(global.tpe) } !compiler::Value,
            index = index_array
        } !compiler::InsnGetElementPtr
        compiler::push_insn(gep, cstate)

        let gep2_ret = compiler::make_local_value(typechecking::pointer(value.tpe.tpe), null, cstate)
        let gep2 = compiler::make_insn(compiler::InsnKind::GETELEMENTPTR)
        let index_array2 = allocate_ref(compiler::Value, 2)
        index_array2[0] = compiler::make_int_value(0)
        index_array2[1] = compiler::make_int_value(0)
        gep2.value.gep = {
            ret = gep2_ret,
            tpe = tpe,
            value = { kind = compiler::ValueKind::GLOBAL, tpe = typechecking::pointer(tpe), name = new_global.name } !compiler::Value,
            index = index_array2
        }
        compiler::push_insn(gep2, cstate)
        
        let store = compiler::make_insn(compiler::InsnKind::STORE)
        store.value.store = {
            value = gep2_ret,
            loc = loc
        } !compiler::InsnStore
        compiler::push_insn(store, cstate)

        new_global.value = array_value

        value.values[1].kind = compiler::ValueKind::UNDEF
        return value
        
    } else if value.kind == compiler::ValueKind::ARRAY or value.kind == compiler::ValueKind::STRUCT {
        @is_constant = false
        for var i in 0..value.values.size {
            let new_index = vector::copy(index)
            new_index.push(compiler::make_int_value(i))
            value.values[i] = serialize(is_constant, value.values[i], global, new_index, module, cstate)
        }
        return value
    } else {
        return value
    }
}

export def eval(cstate: &compiler::State) -> &State {
    var block = cstate.current_function.block

    let state = {
        cstate = cstate,
        stack = vector::make(type &StackFrame)
    } !&State
    let stack_frame = make_stack_frame(block, "<inline>", 1)

    push_stack_frame(stack_frame, state)
    eval(block, state)
    //pop_stack_frame(state)

    return state
}

export def serialize_value(key: Str, module: &toolchain::Module, cstate: &compiler::State) -> &compiler::Global {
    cstate.current_block = module.code

    let mem = cstate.globals.get_or_default(key, null) 
    if not mem { return null }
    let global = cstate.module.result.globals.get_or_default(key, null)
    if not global { return null } // Probably a constant
    if typechecking::is_stub(global.tpe) { return null } // Didn't reference

    let ptr = get(mem, typechecking::pointer(global.tpe)).i !*
    var is_constant = true
    let value = serialize(
        *is_constant, 
        get(ptr, global.tpe), 
        global, 
        vector::make(compiler::Value), 
        module, 
        cstate
    )

    if is_constant {
        global.value = value
    }

    // We need to create a new global, or else the constant is getting inlined
    let new_global = {
        private = false,
        name = global.name,
        tpe = global.tpe,
        value = value,
        line = -1
    } !&compiler::Global
    module.result.globals[new_global.name] = new_global
    module.imported.add(new_global.name)

    return global 
}