import vector
import map
import clexer

type Define = struct {
    token: Token
    is_function_like: bool
    arguments: &Vector(Token)
    replacement_list: *TokenList
}

type State = struct {
    defines: &SMap(Define)
    context_stack: &Vector(Str)
}

def is_macro_disabled(state: *State, macro_name: Str) -> bool {
    for var context in state.context_stack {
        if context == macro_name {
            return true
        }
    }
    return false
}

def copy_replacement_list(to_copy: *TokenList, tail: *TokenList) -> *TokenList {
    var start = zero_allocate(TokenList)
    var result = start
    loop {
        @result = @to_copy
        to_copy = to_copy.next
        if not result.next or result.token.kind == TokenKind::EOL {
            break
        }
        let new = zero_allocate(TokenList)
        result.next = new
        result = new
    }
    result.next = tail
    return start
}

def preprocess(list: *TokenList) {
    let state = {
        defines = map::make(Define),
        context_stack = vector::make(Str)
    } !State

    preprocess(list, *state)
}

def preprocess(list: *TokenList, state: *State) {
    var prev: *TokenList = null
    while list {
        let token = list.token
        print(list.token.kind, "\n")
        if token.kind == TokenKind::P_MACRO or token.kind == TokenKind::P_MACRO_FUNLIKE {
            if not list.next { return }
            let name = list.next.token
            list = list.next

            var args: &Vector(Token)
            if token.kind == TokenKind::P_MACRO_FUNLIKE {
                args = vector::make(Token)

                if not list.next { return }
                list = list.next.next
                while list.token.kind != TokenKind::C_PAREN and list.token.kind != TokenKind::EOF {
                    if list.token.kind != TokenKind::COMMA {
                        args.push(list.token)
                    }
                    list = list.next
                }
            }

            let start = list.next
            list = start
            while list and list.token.kind != TokenKind::EOL and 
                list.token.kind != TokenKind::EOF {
                list = list.next
            }
            if not list { return }
            let next = list.next
            list.next = null
            if prev { prev.next = list.next }
            list = next

            state.defines[name.value.str] = {
                token = name,
                is_function_like = token.kind == TokenKind::P_MACRO_FUNLIKE,
                replacement_list = start,
                arguments = args
            } !Define
        } else if is_textual(token.kind) and 
            state.defines.contains(token.value.str) and 
            not is_macro_disabled(state, token.value.str) {

            state.context_stack.push(token.value.str,)

            let define = *state.defines[token.value.str]

            if list.next and list.next.token.kind == TokenKind::O_PAREN and define.is_function_like {
                list = list.next
                list = list.next

                let arguments = vector::make(type *TokenList)

                var nesting = 0
                while list and (list.token.kind != TokenKind::EOF and list.token.kind != TokenKind::C_PAREN) {
                    var arg_start = zero_allocate(TokenList)
                    arg_start.token.kind = TokenKind::START
                    var result = zero_allocate(TokenList)
                    arg_start.next = result
                    loop {
                        @result = @list
                        list = list.next

                        if result.token.kind == TokenKind::O_PAREN {
                            nesting += 1
                        } else if result.token.kind == TokenKind::C_PAREN {
                            nesting -= 1
                        }
                        
                        if not list or (nesting <= 0 and 
                            (list.token.kind == TokenKind::COMMA or 
                            list.token.kind == TokenKind::C_PAREN)) {
                            if list and list.token.kind == TokenKind::COMMA {
                                list = list.next
                            }
                            result.next = null
                            break
                        }

                        let new = zero_allocate(TokenList)
                        result.next = new
                        result = new
                    }

                    preprocess(arg_start, state)
                    arguments.push(arg_start.next)
                    print("Argument: ")
                    print_tokens(arg_start.next)
                    print("\n")
                }

                if not list { return }

                let tokens = copy_replacement_list(define.replacement_list, null)
                var cur2 = tokens
                prev.next = tokens
                let rescan_start = prev

                print("Replacement list: ")
                print_tokens(tokens)
                print("\n")

                if list and list.next {
                    print("List to add at the end: ")
                    print_tokens(list.next)
                    print("\n")
                }

                loop {
                    if is_textual(cur2.token.kind) {
                        var arg_index = -1
                        var i = 0
                        for var arg in define.arguments {
                            if arg.value.str == cur2.token.value.str {
                                arg_index = i
                                break
                            }
                            i += 1
                        }
                
                        if arg_index != -1 and arg_index < arguments.length {
                            prev.next = copy_replacement_list(arguments[arg_index], cur2.next)
                        }
                    }

                    prev = cur2
                    if not cur2.next {
                        break
                    }
                    cur2 = cur2.next
                }

                cur2.next = list.next

                list = rescan_start.next
                print("Now looking at: ")
                print_tokens(list)
                print("\n")
            } else {
                list = list.next
                list = copy_replacement_list(define.replacement_list, list)
                state.context_stack.push(token.value.str)

                prev.next = list
            }
        } else if token.kind == TokenKind::EOL {
            state.context_stack.pop()
            let next = list.next
            prev.next = next
            list.next = null
            delete(list)
            list = next
        } else {
            prev = list
            list = list.next
        }
    }

    print(state.context_stack.length, "\n")
}

let include_path = [
    ".",
    "/usr/local/include",
    "/usr/include/x86_64-linux-gnu",
    "/usr/include"
]

let input = """
#define REPLACE_ME(a) a
#define SOME_FUN(a, b) a + REPLACE_ME(b)

SOME_FUN(REPLACE_ME(10), 20)
AFTER AFTER AFTER
"""
let out = lex(input, "")
print_tokens(out)
print("\n")
preprocess(out)
print_tokens(out)
print("\n")
delete(out)