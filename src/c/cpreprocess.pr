import vector
import map
import clexer
import util

type Define = struct {
    token: Token
    is_function_like: bool
    arguments: &Vector(Token)
    replacement_list: *TokenList
}

type State = struct {
    defines: &SMap(Define)
    context_stack: &Vector(Str)
}

def is_macro_disabled(state: *State, macro_name: Str) -> bool {
    for var context in state.context_stack {
        if context == macro_name {
            //print("Disabled! ", macro_name, "\n")
            return true
        }
    }
    return false
}

def copy_replacement_list(to_copy: *TokenList, tail: *TokenList) -> *TokenList {
    var start = zero_allocate(TokenList)
    var result = start
    loop {
        @result = @to_copy
        to_copy = to_copy.next
        if not result.next or result.token.kind == TokenKind::EOL {
            break
        }
        let new = zero_allocate(TokenList)
        result.next = new
        result = new
    }
    result.next = tail
    return start
}

def preprocess(list: *TokenList) {
    let state = {
        defines = map::make(Define),
        context_stack = vector::make(Str)
    } !State

    preprocess(list, *state)
}

def preprocess(list: *TokenList, state: *State) {
    var prev: *TokenList = null

    def next_token {
        let l = *list
        let p = *prev
        while (@l) and (@l).token.kind == TokenKind::EOL {
            if state.context_stack.length > 0 {
                state.context_stack.pop()
            }
            let next = (@l).next
            (@p).next = next
            (@l).next = null
            delete((@l))
            (@l) = next
        }
    }

    while list {
        let token = list.token
        //print(list.token.kind, "\n")
        if token.kind == TokenKind::P_MACRO or token.kind == TokenKind::P_MACRO_FUNLIKE {
            if not list.next { return }
            let name = list.next.token
            list = list.next

            var args: &Vector(Token)
            if token.kind == TokenKind::P_MACRO_FUNLIKE {
                args = vector::make(Token)

                if not list.next { return }
                list = list.next.next
                while list.token.kind != TokenKind::C_PAREN and list.token.kind != TokenKind::EOF {
                    if list.token.kind != TokenKind::COMMA {
                        args.push(list.token)
                    }
                    list = list.next
                }
            }

            let start = list.next
            list = start
            while list and list.token.kind != TokenKind::EOL and 
                list.token.kind != TokenKind::EOF {
                list = list.next
            }
            if not list { return }
            let next = list.next
            list.next = null
            if prev { prev.next = list.next }
            list = next

            state.defines[name.value.str] = {
                token = name,
                is_function_like = token.kind == TokenKind::P_MACRO_FUNLIKE,
                replacement_list = start,
                arguments = args
            } !Define
        } else if is_textual(token.kind) and 
            state.defines.contains(token.value.str) and 
            not is_macro_disabled(state, token.value.str) {

            let define = *state.defines[token.value.str]

            let tmp = list
            list = list.next
            next_token()
            if list and list.token.kind == TokenKind::O_PAREN and define.is_function_like {
                //print("Pushing ", token.value.str, "\n")
                state.context_stack.push(token.value.str)

                list = list.next

                let arguments = vector::make(type *TokenList)

                var nesting = 0
                while list and (list.token.kind != TokenKind::EOF and list.token.kind != TokenKind::C_PAREN) {
                    var arg_start = zero_allocate(TokenList)
                    arg_start.token.kind = TokenKind::START
                    var result = zero_allocate(TokenList)
                    arg_start.next = result
                    loop {
                        @result = @list
                        list = list.next

                        if result.token.kind == TokenKind::O_PAREN {
                            nesting += 1
                        } else if result.token.kind == TokenKind::C_PAREN {
                            nesting -= 1
                        }
                        
                        if not list or (nesting <= 0 and 
                            (list.token.kind == TokenKind::COMMA or 
                            list.token.kind == TokenKind::C_PAREN)) {
                            if list and list.token.kind == TokenKind::COMMA {
                                list = list.next
                            }
                            result.next = null
                            break
                        }

                        let new = zero_allocate(TokenList)
                        result.next = new
                        result = new
                    }

                    preprocess(arg_start, state)
                    arguments.push(arg_start.next)
                    //print("Argument: ")
                    //print_tokens(arg_start.next)
                    //print("\n")
                }

                if not list { return }

                let tokens = copy_replacement_list(define.replacement_list, null)
                var cur2 = tokens
                prev.next = tokens
                let rescan_start = prev

                //print("Replacement list: ")
                //print_tokens(tokens)
                //print("\n")

                //print("Start at: ")
                //print_tokens(rescan_start)
                //print("\n")

                loop {
                    if is_textual(cur2.token.kind) {
                        var arg_index = -1
                        var i = 0
                        for var arg in define.arguments {
                            if arg.value.str == cur2.token.value.str {
                                arg_index = i
                                break
                            }
                            i += 1
                        }
                
                        if arg_index != -1 and arg_index < arguments.length {
                            prev.next = copy_replacement_list(arguments[arg_index], cur2.next)
                        }
                    }

                    prev = cur2
                    if not cur2.next {
                        cur2.next = list.next
                        break
                    }
                    cur2 = cur2.next
                }

                list = rescan_start
                //print("Now looking at: ")
                //print_tokens(list)
                //print("\n")
            } else if not define.is_function_like {
                state.context_stack.push(token.value.str)

                list = list.next
                list = copy_replacement_list(define.replacement_list, list)
                state.context_stack.push(token.value.str)

                prev.next = list
            }
        } else if token.kind == TokenKind::P_INCLUDE {
            let start = list
            next_token()
            let include = list.next
            list = include.next
            include.next = null
            delete(start)

            let file = include.token.value.str
            for var path in include_path {
                let full_path = path + "/" + file
                if util::exists(full_path) {
                    var tokens = lex(full_path)
                    preprocess(tokens)
                    prev.next = tokens.next
                    prev = tokens
                    loop {
                        if not tokens.next or tokens.next.token.kind == TokenKind::EOF {
                            tokens.next = list.next
                            list = list.next
                            prev = tokens
                            break
                        }
                        prev = tokens
                        tokens = tokens.next
                    }
                    break
                }
            }
        } else if token.kind == TokenKind::EOL {
            next_token()
        } else {
            prev = list
            list = list.next
        }
    }

    //print(state.context_stack.length, "\n")
}

let include_path = [
    ".",
    "/usr/local/include",
    "/usr/include/x86_64-linux-gnu",
    "/usr/include"
]

let input = """
#include <stdio.h>
"""
let out = lex(input, "")
print_tokens(out)
print("\n")
preprocess(out)
print_tokens(out)
print("\n")
delete(out)