import vector
import map
import clexer
import util

type Define = struct {
    token: PPToken
    is_function_like: bool
    arguments: &Vector(PPToken)
    replacement_list: *TokenList
    nesting: int
}

type State = struct {
    prev: *TokenList
    list: *TokenList
    defines: &SMap(Define)
    context_stack: &Vector(Str)
    ifdef_stack: &Vector(bool)
}

def is_macro_disabled(state: *State, macro_name: Str) -> bool {
    for var context in state.context_stack {
        if context == macro_name {
            //error("Disabled! ", macro_name, "\n")
            return true
        }
    }
    return false
}

def copy_replacement_list(to_copy: *TokenList, tail: *TokenList) -> *TokenList {
    var start = zero_allocate(TokenList)
    var result = start
    loop {
        @result = @to_copy
        to_copy = to_copy.next
        if not result.next or result.token.kind == TokenKind::EOL {
            break
        }
        let new = zero_allocate(TokenList)
        result.next = new
        result = new
    }
    result.next = tail
    return start
}

def delete_next(s: *State) {
    let next = s.list.next
    s.prev.next = next
    s.list.next = null
    print(s.list !*, "\n")
    delete(s.list)
    s.list = next
}

def next_token(s: *State) {
    while s.list and s.list.token.kind == TokenKind::EOL {
        if s.context_stack.length > 0 {
            s.context_stack.pop()
        }
        delete_next(s)
    }
}

def skip_to_endif(s: *State) {
    while s.list and s.list.token.kind != TokenKind::P_ENDIF {
        delete_next(s)
    }
    delete_next(s)
    delete_next(s)
}

def skip_to_else(s: *State) {
    var nesting = 1
    while s.list {
        if s.list.token.kind == TokenKind::P_IF or 
            s.list.token.kind == TokenKind::P_IFDEF or
            s.list.token.kind == TokenKind::P_IFNDEF {
            nesting += 1
        } else if s.list.token.kind == TokenKind::P_ENDIF or 
            s.list.token.kind == TokenKind::P_ELSE or
            s.list.token.kind == TokenKind::P_ELIF {
            nesting -= 1
        }

        if nesting == 0 { break }

        delete_next(s)
    }
}

export def preprocess(list: *TokenList) {
    let state = {
        list = list,
        defines = map::make(Define),
        context_stack = vector::make(Str),
        ifdef_stack = vector::make(bool)
    } !State

    preprocess(*state)
}

def preprocess(s: *State) {
    s.prev = s.list

    while s.list {
        let token = s.list.token
        if token.kind == TokenKind::P_UNDEF {
            delete_next(s)
            let name = s.list.token.value
            s.defines.remove(name)
            delete_next(s)
            delete_next(s)
        } else if token.kind == TokenKind::P_MACRO or token.kind == TokenKind::P_MACRO_FUNLIKE {
            if not s.list.next { return }
            let name = s.list.next.token
            s.list = s.list.next

            var args: &Vector(PPToken)
            if token.kind == TokenKind::P_MACRO_FUNLIKE {
                args = vector::make(PPToken)

                if not s.list.next { return }
                s.list = s.list.next.next
                while s.list.token.kind != TokenKind::C_PAREN and s.list.token.kind != TokenKind::EOF {
                    if s.list.token.kind != TokenKind::COMMA {
                        args.push(s.list.token)
                    }
                    s.list = s.list.next
                }
            }

            let start = s.list.next
            s.list = start
            while s.list and s.list.token.kind != TokenKind::EOL and 
                s.list.token.kind != TokenKind::EOF {
                s.list = s.list.next
            }
            if not s.list { return }
            let next = s.list.next
            s.list.next = null

            s.prev.next = next
            s.list = next

            s.defines[name.value] = {
                token = name,
                is_function_like = token.kind == TokenKind::P_MACRO_FUNLIKE,
                replacement_list = start,
                arguments = args
            } !Define
        } else if token.kind == TokenKind::IDENTIFIER and 
            s.defines.contains(token.value) and 
            not is_macro_disabled(s, token.value) {
            
            if s.prev.token.kind == TokenKind::STRINGIFY or
                s.prev.token.kind == TokenKind::CONCAT or 
                (s.list.next and s.list.next.token.kind == TokenKind::CONCAT) {

                s.prev = s.list
                s.list = s.list.next

                continue
            }

            let prev = s.prev
            let list = s.list
            let define = *s.defines[token.value]

            s.list = s.list.next
            next_token(s)
            if s.list and s.list.token.kind == TokenKind::O_PAREN and define.is_function_like {
                //print("Pushing ", token.value, "\n")
                s.context_stack.push(token.value)
                delete_next(s)

                let arguments = vector::make(type *TokenList)

                var nesting = 0
                while s.list and (s.list.token.kind != TokenKind::EOF and s.list.token.kind != TokenKind::C_PAREN) {
                    var arg_start = zero_allocate(TokenList)
                    arg_start.token.kind = TokenKind::START
                    var result = zero_allocate(TokenList)
                    arg_start.next = result
                    loop {
                        @result = @s.list
                        s.list = s.list.next

                        if result.token.kind == TokenKind::O_PAREN {
                            nesting += 1
                        } else if result.token.kind == TokenKind::C_PAREN {
                            nesting -= 1
                        }
                        
                        if not s.list or (nesting <= 0 and 
                            (s.list.token.kind == TokenKind::COMMA or 
                            s.list.token.kind == TokenKind::C_PAREN)) {
                            if s.list and s.list.token.kind == TokenKind::COMMA {
                                s.list = s.list.next
                            }
                            result.next = null
                            break
                        }

                        let new = zero_allocate(TokenList)
                        result.next = new
                        result = new
                    }

                    arguments.push(arg_start)
                }

                if not s.list { return }

                let tokens = copy_replacement_list(define.replacement_list, null)
                var cur2 = tokens
                prev.next = tokens
                let rescan_start = prev
                s.prev = prev

                //error("Replacement list: ")
                //error(tokens_to_json(tokens), "\n")

                loop {
                    if cur2.token.kind == TokenKind::STRINGIFY {
                        s.prev.next = cur2.next
                        cur2 = cur2.next

                        var arg_index = -1
                        var i = 0
                        for var arg in define.arguments {
                            if arg.value == cur2.token.value {
                                arg_index = i
                                break
                            }
                            i += 1
                        }

                        if arg_index != -1 and arg_index < arguments.length {
                            let arg = arguments[arg_index].next
                            var str: StringBuffer = ""

                            var prev: *TokenList = null
                            var cur3 = arg
                            while cur3 and cur3.token.kind != TokenKind::EOL {
                                if prev and not (prev.token.loc.end_line == cur3.token.loc.line and 
                                    prev.token.loc.end_column == cur3.token.loc.column) {

                                    str += " "
                                }
                                if cur3.token.kind == TokenKind::STRING or cur3.token.kind == TokenKind::CHARACTER {
                                    for var c in cur3.token.value {
                                        if c == '\\' {
                                            str += "\\\\"
                                        } else if c == '"' {
                                            str += "\\\""
                                        } else {
                                            str += c
                                        }
                                    }
                                } else {
                                    str += cur3.token.value
                                }
                                prev = cur3
                                cur3 = cur3.next
                            }
                            cur2.token.kind = TokenKind::STRING
                            cur2.token.value = str
                        }
                    } else if cur2.token.kind == TokenKind::IDENTIFIER {
                        var arg_index = -1
                        var i = 0
                        for var arg in define.arguments {
                            if arg.value == cur2.token.value {
                                arg_index = i
                                break
                            }
                            i += 1
                        }

                        if arg_index != -1 and arg_index < arguments.length {
                            var args = copy_replacement_list(arguments[arg_index], null)
                            
                            // Preprocess as if it was the rest of the file
                            let list = s.list
                            let prev = s.prev
                            s.list = args

                            preprocess(s)
                            s.prev.next = cur2.next

                            s.list = list
                            s.prev = prev

                            s.prev.next = args.next
                        }
                    }

                    s.prev = cur2
                    if not cur2.next {
                        cur2.next = s.list.next
                        break
                    }
                    cur2 = cur2.next
                }

                s.list = rescan_start

                //error("Start at: ")
                //error(tokens_to_json(rescan_start), "\n")
            } else if not define.is_function_like {
                s.context_stack.push(token.value)
                s.list = copy_replacement_list(define.replacement_list, s.list)
                s.prev.next = s.list
            }
        } else if token.kind == TokenKind::P_INCLUDE {
            let start = s.list
            next_token(s)
            let include = s.list.next
            s.list = include.next
            include.next = null
            delete(start)

            let file = include.token.value
            for var path in include_path {
                let full_path = path + "/" + file
                if util::exists(full_path) {
                    var tokens = lex(full_path)
                    preprocess(tokens)
                    s.prev.next = tokens.next
                    s.prev = tokens
                    loop {
                        if not tokens.next or tokens.next.token.kind == TokenKind::EOF {
                            tokens.next = s.list.next
                            s.list = s.list.next
                            s.prev = tokens
                            break
                        }
                        s.prev = tokens
                        tokens = tokens.next
                    }
                    break
                }
            }
        } else if token.kind == TokenKind::P_IFDEF or token.kind == TokenKind::P_IFNDEF {
            var start = s.prev
            delete_next(s)
            let macro = s.list.token
            delete_next(s)
            if macro.kind != TokenKind::IDENTIFIER { continue }

            if s.defines.contains(macro.value) == (token.kind == TokenKind::P_IFNDEF) {
                s.ifdef_stack.push(false)
                skip_to_else(s)

                start.next = s.list
                s.prev = start

            } else {
                s.ifdef_stack.push(true)
                delete_next(s)
                start.next = s.list
            }
        } else if token.kind == TokenKind::P_ELIF {
            if s.ifdef_stack.peek() {
                skip_to_endif(s)    
            }
        } else if token.kind == TokenKind::P_ENDIF {
            delete_next(s)
            if s.ifdef_stack.length > 0 {
                s.ifdef_stack.pop()
            }
        } else if token.kind == TokenKind::P_ELSE {
            delete_next(s)
            if s.ifdef_stack.peek() {
                skip_to_endif(s)
            }  
        } else if token.kind == TokenKind::EOL {
            next_token(s)
        } else {
            s.prev = s.list
            s.list = s.list.next
        }
    }

    //print(s.context_stack.length, "\n")
}

let include_path = [
    ".",
    "/usr/local/include",
    "/usr/include/x86_64-linux-gnu",
    "/usr/include"
]

/*var input = """
    #define f(a) a*g
    #define g(a) f(a)
    f(1)(2)(3)
"""

let tokens = lex(input, "<snippet>")
preprocess(tokens)
let res = tokens_to_json(tokens)
delete(tokens)
print(res)*/