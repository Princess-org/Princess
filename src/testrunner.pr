import getopt
import shared
import vector
import util
import io
import process

#if defined WIN32 {
    import windows
} else {
    import linux
}

let options = [
    option('f', "--filter", "*").set_help("Filter test cases, wildcards * and ? are allowed"),
    option('r', "--recursive", false).set_help("Run directories recursively"),
    option("--compiler", runtime::executable).set_help("Set the compiler for the test cases"),
    option("--no-compile", false).set_help("Don't recompile test cases"),
    option("--runner", false),
    option("--runner-file", ""),
    option("--runner-test", ""),
    option_repeat("files").set_metavar("FILE...").set_help("Run tests in file or directory")
]

let parser = *getopt::make_parser(options, "Princess Test Runner")
let res = parser.parse(args)
if not res { exit(1) }

def assertion_handler(result: bool, msg: *char) {
    if not result {
        fprint(io::stdout_orig, "x")
        if msg {
            fprint(io::stderr_orig, "\nAssertion failure: ", msg, "\n")
        }
        abort()
    }
    fprint(io::stdout_orig, ".")
    fflush(io::stdout_orig)
}

var stdout_file: &string
var stderr_file: &string

def get_stdout() -> &string {
    fflush(std::stdout())
    let fh = open(stdout_file, "rb")
    let res = read_all(fh)
    close(fh)
    return res
}

def get_stderr() -> &string {
    fflush(std::stderr())
    let fh = open(stderr_file, "rb")
    let res = read_all(fh)
    close(fh)
    return res
}

var runner = parser.get_value("--runner").b
if runner {
    let file = parser.get_value("--runner-file").str
    let test = parser.get_value("--runner-test").str

    // Test runner process, we launch tests from here
    let lib = shared::load(file)
    for var symbol in @lib.symbols {
        if symbol.name != test { continue }
        let last_index = symbol.name.last_index_of("::(")
        let fun_name = symbol.name.substring(8, last_index)
        
        print(">", file, "::", fun_name)
        let tmpfolder = tmpfolder("princess")
        stdout_file = tmpfolder + "/stdout.txt"
        stderr_file = tmpfolder + "/stderr.txt"
        io::redirect_stdout_to_file(stdout_file)
        io::redirect_stderr_to_file(stderr_file)

        var test_env: runtime::TestEnvironment
        test_env.out = *get_stdout
        test_env.err = *get_stderr
        test_env.assertion_handler = *assertion_handler

        let test = symbol.value !def (*runtime::TestEnvironment) -> ()
        test(*test_env)

        io::restore_stdout()
        io::restore_stderr()
    }

    shared::close(*lib)
    exit(0)
}

var filter_str = parser.get_value("--filter").str
var recursive = parser.get_value("--recursive").b
var no_compile = parser.get_value("--no-compile").b
var compiler = parser.get_value("--compiler").str

var files_to_test = parser.get_value_as_vec("files")

#if defined WIN32 {
    const dll_ext = ".dll"
    const dev_null = "nul"
} else {
    const dll_ext = ".so"
    const dev_null = "/dev/null"
}

let files = vector::make(type &string)
for var i in 0..files_to_test.length {
    let file = files_to_test[i]
    enumerate_dir(file.str, "test*.pr", recursive, files)
}

print("Collected " + files.length + " test files\n")

if not no_compile {
    for var i in 0..files.length {
        let file = files[i]
        let dll_file = file.substring(0, file.length - 3) + dll_ext

        print("Compiling ", file, " ")
        // Disable cursor
        print("\x1B[?25l")

        let stdout = open(dev_null, "w")
        // TODO It needs to be incremental in the future
        let proc = *process::spawn(compiler, 
            [file, "--no-incremental" !&string, "-o" !&string, dll_file] ![&string], // TODO These arrays are clunky
            stdout = stdout, stderr = std::stderr()
        )

        let spinner = ['|', '/', '-', '\\']
        var index = 0
        print(spinner[index])
        while proc.running {
            proc.wait(100)
            print("\x1B[1D")
            print(spinner[index % spinner.size])
            index += 1
        }
        print("\x1B[1D")
        print(" \n")
        print("\x1B[?25h")

        proc.dispose()
        close(stdout)
        if proc.exit_code {
            error("Couldn't compile module " + file + "\n")
            files[i] = null
        }
    }
}

for var i in 0..files.length {
    let file = files[i]
    if not file { continue }
    let dll_file = file.substring(0, file.length - 3) + dll_ext

    let tests_to_run = vector::make(type &string)

    let lib = shared::load(dll_file, init = false) // We only want the symbol information
    for var symbol in @lib.symbols {
        if symbol.name.starts_with("__test::") {
            tests_to_run.push(symbol.name)
        }
    }
    shared::close(*lib, finalize = false)

    for var i in 0..tests_to_run.length {
        let test_function = tests_to_run[i]
        let proc = *process::spawn(executable_file(), 
            ["--runner" !&string, "--runner-file=\"" + dll_file + "\"", "--runner-test=\"" + test_function + "\""] ![&string]
        )
        proc.wait()

        if proc.exit_code {
            print(" \x1B[31m[ERROR]\x1B[0m (", proc.exit_code, ")\n")
        } else {
            print(" \x1B[32m[OK]\x1B[0m\n")
        }

        proc.dispose()
    }
}

const FILE_ATTRIBUTE_DIRECTORY = 0x10
const INVALID_HANDLE_VALUE = -1 !uint64

// TODO Use a generator and move it to std
def enumerate_dir(file_or_dir: &string, pattern: &string, recursive: bool, res: &Vector(&string)) {
    #if defined WIN32 {
        let attrib = windows::GetFileAttributesA(file_or_dir.value)
        if not (attrib & FILE_ATTRIBUTE_DIRECTORY) {
            res.push(file_or_dir)
            return
        }

        var full_pattern = file_or_dir + "\\*"
        var find_data: windows::WIN32_FIND_DATAA
        var handle: *

        if recursive {
            handle = windows::FindFirstFileA(full_pattern.value, *find_data)
            if handle != INVALID_HANDLE_VALUE !* {
                loop {
                    let folder = make_string(find_data.cFileName.value)
                    if folder != "." and folder != ".." and find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY {
                        enumerate_dir(file_or_dir + "\\" + folder, pattern, recursive, res)
                    }
                    if not windows::FindNextFileA(handle, *find_data) { break }
                }
            }
            windows::FindClose(handle)
        }

        full_pattern = file_or_dir + "\\" + pattern
        handle = windows::FindFirstFileA(full_pattern.value, *find_data)

        if handle != INVALID_HANDLE_VALUE !* {
            loop {
                if not (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    res.push(file_or_dir + "\\" + make_string(find_data.cFileName.value))
                }
                if not windows::FindNextFileA(handle, *find_data) { break }
            }
        }
        windows::FindClose(handle)
    } else {
        // TODO
    }
}