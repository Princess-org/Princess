import map
import set
import typechecking
import parser
import vector
import util
import toolchain
import debug
import builtins
import compiler
import errors
import consteval

// This is used to uniquely identify a value
export type Ident = struct {
    name: &string
    signature: &string
    _hash: uint64
    module: weak_ref(toolchain::Module)
}

export type ImportedModule = struct {
    module: weak_ref(toolchain::Module)
    alias: &parser::Node
}

export def make_ident(name: &string, module: &toolchain::Module = null, hash: uint64 = 0, signature: &string = null) -> Ident {
    if not signature { signature = name }
    return {
        name = name,
        signature = signature,
        module = module,
        _hash = hash
    } !Ident
}

export def hash(ident: Ident) -> uint64 {
    return combine_hashes(hash(ident.signature), hash(ident.module.module) if ident.module else 0)
}
export def == (this: Ident, other: Ident) -> bool {
    if not other.module {
        return this.signature == other.signature
    } else {
        return this.signature == other.signature and 
            this.module == other.module
    }
}
export def != (this: Ident, other: Ident) -> bool {
    return not (this == other)
}
export def fuzzy_equals(this: Ident, other: Ident) -> bool {
    if not other.module {
        return this.name == other.name
    } else {
        return this.name == other.name and
            this.module == other.module
    }
}

export def find(ident: Ident) -> &Value {
    if not ident.module { return null }

    let scope = ident.module.scope
    let values = scope.all_values()
    for var fun in values {
        if fun.ident == ident {
            return fun
        }
    }
    return null
}

export type Value = struct {
    // This is needed to store the location
    name_node: weak_ref(parser::Node)
    share: parser::ShareMarker
    modifier: parser::VarDecl
    // Name used by the source code
    name: &string
    // Name used by the assembly, might be suffixed with a number
    // in case of shadowed variables
    assembly_name: &string
    tpe: &typechecking::Type
    value: &compiler::Value
    _scope: &Scope
    _module: weak_ref(Scope) // This is needed for modules referencing each other
    // In case multiple values share one name (overloaded functions)
    next: &Value
    phase: Phase
    // True if the value is a global value
    global: bool
    // No mangling if extern
    extern: bool
    impl: bool
    dllimport: bool
    dllexport: bool
    // Definition of the value
    node: weak_ref(parser::Node)
    state: &typechecking::State
    // For imported scopes, this checks if a value is exported before accessing it
    // Also used by serialize to signal that a function is imported (ffi)
    imported: bool
    previous_underscore: &Value

    ident: Ident
    dependencies: &Set(Ident)
    // This belongs to functions that aren't found
    unresolved: &Set(Ident)
    dependants: &Set(Ident)
    is_capture: bool
    // TODO This is a strong reference to the identifier
    // It's needed because of compiler::create_type
    identifier: &parser::Node
    // So that the value doesn't come up in auto completion
    is_internal: bool
    // This is true if we have a polymorphic instance
    polymorph: bool
}

export def loc(value: &Value) -> parser::SourceLoc {
    if not value.name_node { 
        if value.tpe and value.tpe.kind == typechecking::TypeKind::NAMESPACE {
            let module = value._module.module
            return {
                module.filename,
                module.filename,
                module.module,
                0, 0, 0, 0
            } !parser::SourceLoc
        }
        return parser::invalid_loc
    }

    let loc = value.name_node.loc
    if not loc.filename {
        return parser::invalid_loc
    }
    return loc
}

export def get_scope(value: &Value) -> &Scope {
    if value._module {
        return value._module
    }
    return value._scope
}

export type ReExport = struct {
    module: weak_ref(toolchain::Module)
    pattern: &parser::Node
}

export type Scope = struct {
    module: weak_ref(toolchain::Module)
    is_function: bool
    // Counter for local scopes (shadowing)
    scope_count: int
    parent: weak_ref(Scope)
    fields: &SMap(&Value)
    implicits: &Vector(&Value)
    // This is a list of imported scopes,
    // for resolving names from other modules without
    // specifying the full path
    // Vector of toolchain::Module
    imports: &Vector(ImportedModule)
    // Current underscore
    underscore: &Value
    underscore_count: int
    re_exports: &Vector(ReExport)
}

export type Phase = enum {
    DECLARED; DEFINED; COMPILED
}

export def create_dependency(this: &Value, other: &parser::Node) {
    if other.svalue {
        create_dependency(this, other.svalue)        
    } else {
        var ident = other
        if other.kind == parser::NodeKind::TYPE_CONSTRUCTOR {
            ident = other.value.type_constructor.name
        }
        if ident and ident.kind == parser::NodeKind::IDENTIFIER {
            create_dependency(this, make_ident(parser::identifier_to_str(ident)))
        }
    }
}

// TODO The errors thrown here really degrade usability for cli,
// every unknown variable raises this instead of a more useful error
export def create_dependency_on_type(this: &Value, node: &parser::Node) {
    if not node { return }
    let other = node.svalue
    if not other {
        // TODO We need to check for type here for some reason, without this enums from other files get caught
        // Figure out why instead of working around the problem
        if node.kind == parser::NodeKind::IDENTIFIER and (not node.tpe or node.tpe.kind == typechecking::TypeKind::STUB) {
            if node.tpe and node.tpe.kind == typechecking::TypeKind::STUB {
                errors::errorn(node, "Unknown type")
            }
            create_dependency(this, make_ident(parser::identifier_to_str(node)))
        }
        return
    }
    if other.modifier == parser::VarDecl::TYPE {
        let tpe = other.value.value_tpe
        if tpe {
            if tpe.kind == typechecking::TypeKind::STUB {
                create_dependency(this, make_ident(other.name))
                errors::errorn(node, "Can't refer to stub type")
                return
            }
        } else {
            //errors::errorn(node, "Unknown type")
            if node.kind == parser::NodeKind::IDENTIFIER {
                create_dependency(this, make_ident(parser::identifier_to_str(node)))
            }
        }
    }
    create_dependency(this, other)
}

export def create_dependency(this: &Value, other: &Value) {
    if toolchain::no_dependency_tracking { return }
    if not this or not other { return }
    if not this.dependencies or not other.dependants { return }
    if this.ident == other.ident { return }

    this.dependencies.add(other.ident)
    other.dependants.add(this.ident)
}

export def create_dependency(this: &Value, other: Ident) {
    if toolchain::no_dependency_tracking { return }
    if not this { return }
    if not this.dependencies or not this.unresolved { return }
    if this.ident == other { return }
    this.unresolved.add(other)
    this.ident.module.unresolved[this.ident] = this
}

def get_scope_count(scope: &Scope) -> int {
    if not scope { return 0 }
    if scope.is_function { return 0 }
    return scope.scope_count
}

export def is_global(scope: &Scope) -> bool {
    if not scope { return true }
    // TODO Check against builtins
    if (@scope).parent == null { return true }
    scope = (@scope).parent
    if (@scope).parent == null { return true }
    return false
}

def get_function_parent(scope: &Scope) -> &Scope {
    if scope.is_function { return scope }
    if scope.parent { return get_function_parent(scope.parent) }
    return null
}

export def enter_scope(scope: &Scope, module: &toolchain::Module) -> &Scope {
    let s = {
        module = module,
        parent = scope,
        fields = map::make(type &Value),
        implicits = vector::make(type &Value),
        underscore_count = scope.underscore_count if scope else 0
    } !&Scope
    let function_parent = get_function_parent(s)
    if function_parent {
        function_parent.scope_count += 1
        s.scope_count = function_parent.scope_count
    }
    return s
}

export def enter_scope(scope: &Scope) -> &Scope {
    assert scope != null
    return enter_scope(scope, scope.module)
}

export def enter_function_scope(scope: &Scope, module: &toolchain::Module) -> &Scope {
    return {
        module = module,
        parent = scope,
        fields = map::make(type &Value),
        implicits = vector::make(type &Value),
        is_function = true,
        scope_count = 0
    } !&Scope
}

export def enter_function_scope(scope: &Scope) -> &Scope {
    assert scope != null
    return enter_function_scope(scope, scope.module)
}

export def exit_scope(scope: &Scope) -> &Scope {
    let parent = (@scope).parent
    return parent
}

export def all_functions(scope: &Scope) -> &Value {
    let keys = scope.fields.keys()
    for var i in 0..keys.size {
        let key = keys[i]
        var value = scope.fields[key]
        if value.modifier == parser::VarDecl::CONST and 
            value.tpe.kind == typechecking::TypeKind::FUNCTION {
            while value {
                yield value
                value = value.next
            }
        }
    }
}

export def all_values(scope: &Scope) -> &Value {
    let keys = scope.fields.keys()
    for var i in 0..keys.size {
        let key = keys[i]
        var value = scope.fields[key]
        while value {
            yield value
            value = value.next
        }
    }
}

def find_functions(value: &Value, resolved: &SMap(&Vector(&typechecking::Type)), result: &Vector(&typechecking::Type), template: &typechecking::Type) {
    if not value { return }

    let function = value.tpe
    let new_resolved = map::make(type &typechecking::Type)
    if vector::length(function.parameter_t) == vector::length(template.parameter_t) and
        vector::length(function.return_t) == vector::length(template.return_t) {
        var equal = true
        // TODO What about varargs functions?
        for var i in 0..vector::length(function.parameter_t) {
            let left = function.parameter_t[i]
            let right = template.parameter_t[i]
            if not typechecking::equals(left.tpe, right.tpe) {
                equal = false
                break
            } else if right.tpe.kind == typechecking::TypeKind::VARIANT {
                let old = new_resolved.get_or_default(right.tpe.name, null)
                if old and not typechecking::equals(old, left.tpe) {
                    equal = false
                    break
                }
                new_resolved[right.tpe.name] = left.tpe
            }
        }
        if equal {
            for var i in 0..vector::length(function.return_t) {
                let left = function.return_t[i]
                let right = template.return_t[i]
                if not typechecking::equals(left, right) {
                    equal = false
                    break
                } else if right.kind == typechecking::TypeKind::VARIANT {
                    let old = new_resolved.get_or_default(right.name, null)
                    if old and not typechecking::equals(old, left) {
                        equal = false
                        break
                    }
                    new_resolved[right.name] = left
                }
            }
        }
        if equal {
            let keys = map::keys(new_resolved)
            for var i in 0..keys.size {
                let key = keys[i]
                let tpe = new_resolved[key]
                var vec = resolved.get_or_default(key, null)
                if not vec { vec = vector::make(type &typechecking::Type) }
                vec.push(tpe)
                resolved[key] = vec
            }
            result.push(function)
        }
    }
}

def find_functions(scope: &Scope, name: &string, ret: &Vector(&Value), params: &Vector(&typechecking::Type) = null, check_export: bool = false) {
    for var key in @scope.fields.keys() {
        var value = scope.fields[key]
        if key == name and value.modifier == parser::VarDecl::CONST and 
            value.tpe.kind == typechecking::TypeKind::FUNCTION {
            while value {
                if params {
                    if value.tpe.parameter_t.length < params.length {
                        continue
                    }
                    var parameter_mismatch = false
                    for var i in 0..params.length {
                        let param = params[i]
                        if not typechecking::is_assignable(value.tpe.parameter_t[i].tpe, param, scope.module) {
                            parameter_mismatch = true
                            break
                        }
                    }
                    if parameter_mismatch { continue }
                }
                ret.push(value)
                value = value.next
            }
        }
    }
    if scope.parent {
        find_functions(scope.parent, name, ret, params, check_export)
    }
    if scope.imports and not check_export {
        for var i in 0..scope.imports.length {
            let imprt = scope.imports[i]
            find_functions(imprt.module.scope, name, ret, params, check_export = true)
        }
    }
}

export def find_functions(scope: &Scope, name: &string, params: &Vector(&typechecking::Type) = null) -> &Vector(&Value) {
    let ret = vector::make(type &Value)
    find_functions(scope, name, ret, params)
    return ret
}

// TODO Duplicate code, we want a filter function
def find_functions(scope: &Scope, tpe: &typechecking::Type, ret: &Vector(&Value), found: &SSet, check_export: bool = false) {
    if not scope { return }
    for var key in @scope.fields.keys() {
        var value = scope.fields[key]
        if check_export and not (value.share !int & parser::ShareMarker::EXPORT !int) { continue }
        if value.modifier == parser::VarDecl::CONST and 
            value.tpe.kind == typechecking::TypeKind::FUNCTION {
            while value {
                if value.tpe.parameter_t.length > 0 and
                    typechecking::is_assignable(value.tpe.parameter_t[0].tpe, tpe, scope.module) {
                    if not set::contains(found, value.tpe.type_name) {
                        set::add(found, value.tpe.type_name)
                        ret.push(value)
                    }
                }
                value = value.next
            }
        }
    }
    if scope.parent {
        find_functions(scope.parent, tpe, ret, found, check_export)
    }
    if scope.imports and not check_export {
        for var i in 0..scope.imports.length {
            let imprt = scope.imports[i]
            find_functions(imprt.module.scope, tpe, ret, found, check_export = true)
        }
    }
}

export def find_functions(scope: &Scope, tpe: &typechecking::Type) -> &Vector(&Value) {
    let ret = vector::make(type &Value)
    let found = set::make()
    find_functions(scope, tpe, ret, found)
    return ret
}

def find_all(scope: &Scope, ret: &Vector(&Value), found: &SSet, check_export: bool = false) {
    if not scope { return }
    for var key in @scope.fields.keys() {
        var value = scope.fields[key]
        if check_export and not (value.share !int & parser::ShareMarker::EXPORT !int) { continue }

        if value.modifier == parser::VarDecl::CONST and 
            value.tpe.kind == typechecking::TypeKind::FUNCTION {
            while value {
                if not set::contains(found, value.tpe.type_name) {
                    set::add(found, value.tpe.type_name)
                    ret.push(value)
                }
                value = value.next
            }
        } else if not set::contains(found, value.name) {
            set::add(found, value.name)
            ret.push(value)
        }
    }
    if scope.parent {
        find_all(scope.parent, ret, found, check_export)
    }
    if scope.imports and not check_export {
        for var i in 0..scope.imports.length {
            let imprt = scope.imports[i]
            find_all(imprt.module.scope, ret, found, check_export = true)
        }
    }
}

export def find_all(scope: &Scope, check_export: bool = false) -> &Vector(&Value) {
    let ret = vector::make(type &Value)
    let found = set::make()
    find_all(scope, ret, found, check_export)
    return ret
}

export def find_functions(scope: &Scope, node: &parser::Node, template: &typechecking::Type) -> &Vector(&typechecking::Type), &SMap(&Vector(&typechecking::Type)) {
    assert template.kind == typechecking::TypeKind::FUNCTION

    var resolved = map::make(type &Vector(&typechecking::Type))
    var result = vector::make(type &typechecking::Type)
    
    var first_value = get_function(scope, node, template.parameter_t, true)
    find_functions(first_value, resolved, result, template)

    var value = get(scope, node)
    if not value or not typechecking::is_function(value.tpe) {
        return result, resolved
    }
    while value != null {
        if value != first_value {
            find_functions(value, resolved, result, template)
        }
        value = value.next
    }

    return result, resolved
}

def find_function(scope: &Scope, node: &parser::Node, v: &Value, parameter_t: &Vector(typechecking::NamedParameter), score: *int, dry_run: bool) -> bool, &Value {
    for var i in 0..vector::length(parameter_t) {
        let np = parameter_t[i]
        if not np.tpe { return false, null }
    }
    
    var generated = false
    if node.value.identifier.types {
        // We disregard the parameters and only look at the identifier
        // The calling function must check the overload score manually
        if not v {
            let generated = generate_function(scope, node, node.value.identifier.types, true)
            return generated != null, generated
        }

        if not is_function(v.tpe) { return false, null }

        loop {
            if not v { break }
            let s = typechecking::overload_score(v.tpe, node.value.identifier.types, scope.module, true)
            if s == 0 {
                @score = 0
                return true, v
            }
            v = v.next
            if not v {
                if generated {
                    break
                } else {
                    if @score != 0 {
                        v = generate_function(scope, node, node.value.identifier.types, true)
                    }
                    generated = true
                }
            }
        }
        return false, null
    }

    if not v {
        let generated = generate_function(scope, node, parameter_t, dry_run)
        return generated != null, generated
    }

    if v.modifier != parser::VarDecl::CONST or not is_function(v.tpe) { return false, null }
    
    var found: &Value = null
    var d = false
    loop {
        if not v { break }
        if v.node and v.state {
            v.tpe = typechecking::lookup_parameters(v.node, v.state)
        }

        let s = typechecking::overload_score(v.tpe, parameter_t, scope.module, false)
        if s >= 0 {
            if s < @score {
                @score = s
                found = v
                d = false
            } else if s == @score {
                d = true
            }
        }
        v = v.next
        if not v {
            if generated {
                break
            } else {
                v = generate_function(scope, node, parameter_t, dry_run)
                generated = true
            }
        }
        
    }
    if d {
        if not dry_run { errors::errorn(node, "Ambiguous reference") }
        return true, null
    }
    return found != null, found
}

export def find_implicit_function(scope: &Scope, parameter_t: &Vector(typechecking::NamedParameter), ret: &typechecking::Type) -> &Value {
    if not scope { return null }
    assert parameter_t.length == 1

    let r = ret // TODO Capture parameters
    def find(scope: &Scope, score: *int, check_export: bool) -> &Value {
        var value: &Value = null
        var d = false
        for var i in 0..scope.implicits.length {
            let v = scope.implicits[i]
            if v.node and v.state {
                v.tpe = typechecking::lookup_parameters(v.node, v.state)
            }

            let retc = typechecking::convert_type_score(v.tpe.return_t[0], r, scope.module)
            if retc < 0 { continue }
            let s = typechecking::convert_type_score(v.tpe.parameter_t[0].tpe, parameter_t[0].tpe, scope.module, impl = false)
            if s == @score {
                d = true
            } else if s >= 0 and s < @score {
                @score = s
                d = false
                value = v
            }
        }
        if d { return null }
        if check_export and value and not (value.share !int & parser::ShareMarker::EXPORT !int) {
            return null
        }
        return value
    }

    var score = MAX_INT32
    var value = find(scope, *score, false)

    var parent = scope.parent
    while parent {
        let value2 = find(scope.parent, *score, false)
        if value2 { value = value2 }
        parent = parent.parent
    }

    if not value and scope.imports {
        for var i in 0..scope.imports.length {
            let imprt = scope.imports[i]
            let scope2 = imprt.module.scope
            // TODO See if we can rewrite the other functions to not be recursive
            let value2 = find(scope2, *score, true)
            if value2 { value = value2 }
        }
    }

    if value and value.phase == Phase::DEFINED and value.state and value.node {
        // TODO Factor this out
        if typechecking::is_polymorph(value.tpe) {
            typechecking::walk_Def_with_type_argument(value.node, parameter_t, value.state)
        } else {
            typechecking::walk_Def(value.node, value.state)
        }
    }
    return value
}

export def has_function(scope: &Scope, ftpe: &typechecking::Type) -> &Value {
    var value = get(scope, parser::make_identifier(ftpe.name), false, false, true)
    if value and is_function(value.tpe) {
        while value {
            if value.tpe.type_name == ftpe.type_name {
                return value
            }
            value = value.next
        }
    }
    return null
}

export def remove(scope: &Scope, value: &Value) {
    if not value or not scope { return }
    let keys = scope.fields.keys()
    for var i in 0..keys.size {
        let key = keys[i]
        var v = scope.fields[key]
        if v !* == value !* {
            scope.fields.remove(key)
            if v.next {
                scope.fields[key] = v.next
            }
            break
        } else {
            var prev = v
            v = v.next
            while v {
                if v !* == value !* {
                    prev.next = v.next
                    break
                }
                prev = v
                v = v.next
            }
        }
    }

    let index = scope.implicits.index_of(value)
    if index >= 0 {
        scope.implicits.remove(index)
    }
    value.next = null
}

export def generate_function(scope: &Scope, node: &parser::Node, parameter_t: &Vector(typechecking::NamedParameter), dry_run: bool = false) -> &Value {
    let module = scope.module
    while not is_global(scope) {
        scope = scope.parent
    }
    
    let name = last_path_element(node)
    if vector::length(parameter_t) >= 1 {
        var first_parameter = parameter_t[0]
        if not first_parameter.tpe { return null }
        if first_parameter.tpe.kind == typechecking::TypeKind::REFERENCE and 
            (first_parameter.tpe.tpe and first_parameter.tpe.tpe.kind == typechecking::TypeKind::STRUCTURAL) {
            
            let equals = get(toolchain::runtime_.scope, parser::make_identifier("equals"))
            consteval::compile_function(equals.node, equals.state)

            let parameter_t2 = vector::copy(parameter_t)
            vector::remove(parameter_t2, 0)

            let stpe = first_parameter.tpe.tpe
            let module = stpe.module
            let scope = module.scope

            var duplicate = false
            let least_score = std::MAX_INT32 !int
            var found_member: *typechecking::StructuralTypeMember = null
            for var i in 0..vector::length(stpe.members) {
                let member = stpe.members.get(i)
                if member.name != name { continue }

                let score = typechecking::overload_score(member.parameter_t, vector::make(type &typechecking::Type), parameter_t2, scope.module, false)
                if score < least_score {
                    found_member = member
                    duplicate = false
                } else if score == least_score {
                    duplicate = true
                }
            }

            if duplicate {
                if not dry_run { errors::errorn(node, "Ambiguous referernce") }
                return null
            }
            if not found_member { return null }

            let name_node = parser::make_identifier(name)
            let parameter_t3 = typechecking::copy_parameter_t(found_member.parameter_t)

            var return_t = vector::make(type &typechecking::Type)
            for var i in 0..found_member.return_t.length {
                var tpe = found_member.return_t[i]
                if tpe.kind == typechecking::TypeKind::BOX {
                    tpe = tpe.weak
                }
                return_t.push(typechecking::copy(tpe))
            }
            let types_map = map::make(type &typechecking::Type)

            if stpe.tc_args {
                for var i in 0..vector::length(stpe.tc_tpe.parameter_t) {
                    let np = stpe.tc_tpe.parameter_t[i]
                    let tpe = stpe.tc_args[i]
                    types_map[np.name] = tpe
                }
            }

            typechecking::replace_type_defs(parameter_t3, return_t, parameter_t2, types_map, module)
            
            vector::insert(parameter_t3, 0,  {
                name = "__ref",
                _tpe = first_parameter.tpe
            } !typechecking::NamedParameter)
            let tpe = typechecking::make_function_type_n(name_node, parameter_t3, return_t, module)
            let fun = has_function(scope, tpe)
            if fun { return fun }

            let value = create_function(scope, name_node, stpe.share, tpe)
            module.dyn_dispatch.push(tpe)
            return value
        } else if vector::length(parameter_t) == 1 and first_parameter.tpe.kind == typechecking::TypeKind::POINTER and 
            name == "__destruct__" and typechecking::has_destructor(first_parameter.tpe.tpe) {
            
            let args = vector::make(typechecking::NamedParameter)
            args.push({
                name = "__ptr",
                _tpe = first_parameter.tpe
            } !typechecking::NamedParameter)

            let name_node = parser::make_identifier("__destruct__")
            let tpe = typechecking::make_function_type_n(name_node, args, vector::make(type &typechecking::Type))
            let fun = has_function(builtins::builtins, tpe)
            if fun { return fun }

            let value = create_function(builtins::builtins, name_node, parser::ShareMarker::EXPORT, tpe)
            if module {
                compiler::predeclare_function(tpe, module)
            }
            compiler::destructors[debug::type_to_str(first_parameter.tpe, full_name = true)] = tpe
            return value
        } else if vector::length(parameter_t) == 2 and first_parameter.tpe.kind == typechecking::TypeKind::POINTER and
            name == "__construct__" and typechecking::has_copy_constructor(first_parameter.tpe.tpe, lookup = false) {
            let second_parameter = vector::get(parameter_t, 1) !*NamedParameter
            if equals(second_parameter.tpe, first_parameter.tpe) {
                
                let args = vector::make(typechecking::NamedParameter)
                args.push({
                    name = "__copy",
                    _tpe = first_parameter.tpe
                } !typechecking::NamedParameter)
                args.push({
                    name = "__this",
                    _tpe = second_parameter.tpe
                } !typechecking::NamedParameter)

                let name_node = parser::make_identifier("__construct__")
                let tpe = typechecking::make_function_type_n(name_node, args, vector::make(type &typechecking::Type))
                let fun = has_function(builtins::builtins, tpe)
                if fun { return fun }
                
                let value = create_function(builtins::builtins, name_node, parser::ShareMarker::EXPORT, tpe)
                if module {
                    compiler::predeclare_function(tpe, module)
                }
                compiler::constructors[debug::type_to_str(first_parameter.tpe, full_name = true)] = tpe
                return value
            }
        }
    }
    return null
}

export def get_underscore(scope: &Scope) -> &Value {
    if scope.underscore { return scope.underscore }
    if scope.parent { return get_underscore(scope.parent) }
    return null
}

export def create_underscore(scope: &Scope, name_node: &parser::Node, tpe: &typechecking::Type) -> &Value {
    while not scope.is_function {
        scope = scope.parent
    }
    let value = {
        name_node = name_node,
        share = parser::ShareMarker::NONE,
        modifier = parser::VarDecl::VAR,
        tpe = tpe,
        global = is_global(scope),
        phase = Phase::COMPILED,
        name = "_",
        assembly_name = "_." + scope.underscore_count,
        previous_underscore = scope.underscore
    } !&Value
    scope.underscore_count += 1

    scope.underscore = value

    return value
}

export def typecheck_function(value: &Value, id: &parser::Node, scope: &Scope, dry_run: bool, parameter_t: &Vector(typechecking::NamedParameter)) -> &Value {
    let tpe = typechecking::lookup_parameters(value.node, value.state)
    if typechecking::is_polymorph(value.tpe) {
        typechecking::walk_Def_with_type_argument(value.node, parameter_t, value.state)
        // TODO Do we really need to do that?
        return get_function(scope, id, parameter_t, false, dry_run, false)
    } else {
        value.node.tpe = tpe
        typechecking::walk_Def(value.node, value.state)
        return value
    }
}

export def typecheck(value: &Value) {
    if not value.node or not value.state { return }
    if value.node.kind == parser::NodeKind::DEF {
        let tpe = typechecking::lookup_parameters(value.node, value.state)
        if not typechecking::is_polymorph(tpe) {
            value.node.tpe = tpe
            value.tpe = tpe
            typechecking::walk_Def(value.node, value.state)
        }
    } else {
        typechecking::walk(value.node.parent, value.node, value.state)
    }
}

export def get_function_check(
    scope: &Scope, 
    id: &parser::Node, 
    parameter_t: &Vector(typechecking::NamedParameter), 
    check_export: bool = false, 
    dry_run: bool = false, 
    force_compile: bool = true, 
    only_function: bool = false
) -> bool, &Value {

    def check_for_re_exports(scope: &Scope, value: &Value) -> &Value {
        if not scope.re_exports { return value }
        for var i in 0..scope.re_exports.length {
            let re_export = scope.re_exports[i]
            if pattern_matches(id, re_export.pattern) {
                var _, value2 = get_function_check(re_export.module.scope, id, parameter_t, check_export, force_compile, only_function)
                if value2 and not pattern_matches(id, re_export.pattern, value2.tpe.parameter_t) { continue }
                if value2 and value2.share !int & parser::ShareMarker::EXPORT !int {
                    if value and value !* != value2 {
                        if not dry_run {
                            errors::errorn(id, "Ambiguous reference")
                        }
                        return null
                    }
                    value = value2
                }
            }
        }
        return value
    }

    if not scope { return false, null }
    //if id.svalue { return true, id.svalue }
    
    assert((@id).kind == parser::NodeKind::IDENTIFIER)
    if vector::length((@id).value.identifier.path) == 1 {
        let name = @((@id).value.identifier.path[0])
        var score = std::MAX_INT32 !int
        var code = false

        // We need to store this to check later that there's no entry by that name
        let first_value = scope.fields.get_or_default(name, null)
        let (code), first_function = find_function(scope, id, first_value, parameter_t, *score, dry_run)
        let first_score = score
        var value = first_function
        var d = false
        if (@scope).imports and not check_export {
            for var i in 0..vector::length((@scope).imports) {
                let imprt = (@scope).imports[i]
                let scope2 = imprt.module.scope
                var new_score = std::MAX_INT32 !int
                let code2, new_value = find_function(scope, id, scope2.fields.get_or_default(name, null), parameter_t, *new_score, dry_run)
                if code2 { code = true }
                if new_value and (@new_value).share !int & parser::ShareMarker::EXPORT !int {
                    if score == new_score {
                        d = true 
                    } else if new_score < score {
                        score = new_score
                        value = new_value
                        d = false
                    }
                }
            }
            if first_function and first_score == score {
                // We always return the declaration in the current file
                // if there are multiple ones with the same score
                value = first_function
            } else if d {
                if not dry_run { errors::errorn(id, "Ambiguous reference") }
                return true, null
            }
        }
        if scope.re_exports {
            value = check_for_re_exports(scope, value)
        }
        if scope.imports {
            for var i in 0..scope.imports.length {
                let scope2 = scope.imports[i].module.scope
                value = check_for_re_exports(scope2, value)
            }
        }

        if not value and (@scope).parent and (not first_value or only_function) {
            code, value = get_function_check((@scope).parent, id, parameter_t, check_export, dry_run, force_compile, only_function)
        }
        if not value and vector::length(parameter_t) > 0 {
            let first_param = parameter_t[0]
            let module = typechecking::get_module(first_param.tpe)
            if first_param.tpe and module and module != scope.module {
                let scope = module.scope
                var new_score = std::MAX_INT32 !int
                let code2, new_value = find_function(scope, id, scope.fields.get_or_default(name, null), parameter_t, *new_score, dry_run)
                if code2 { code = true }
                if new_value and new_value.share !int & parser::ShareMarker::EXPORT !int {
                    value = new_value
                }
            }
        }
        if value and value.phase == Phase::DEFINED and force_compile {
            value = typecheck_function(value, id, scope, dry_run, parameter_t)
        }
        if value and check_export and (value.share !int & parser::ShareMarker::EXPORT !int) == 0 {
            value = null
        }
        return code, value
    } else {
        let head = vector::head_vec((@id).value.identifier.path)
        let tail = vector::tail((@id).value.identifier.path)

        let id_head = parser::copy_node(id)
        (@id_head).value.identifier.path = head
        let id_tail = parser::copy_node(id)
        (@id_tail).value.identifier.path = tail

        let s = get(scope, id_head)
        if s {
            if not s.get_scope() {
                if not dry_run { errors::errorn(id, "Use of :: on non namespace") }
                return false, null
            }
            // TODO this should be able to go on one line
            let code, value = get_function_check(s.get_scope(), id_tail, parameter_t, s.imported, dry_run, force_compile, only_function)
            return code, value
        }
        return false, null
    }
}
export def get_function(
    scope: &Scope, 
    id: &parser::Node, 
    parameter_t: &Vector(typechecking::NamedParameter), 
    check_export: bool, 
    dry_run: bool, 
    force_compile: bool = true, 
    only_function: bool = false) -> &Value {

    let _, value = get_function_check(scope, id, parameter_t, check_export, dry_run, force_compile, only_function)
    return value
}

export def get_function(scope: &Scope, id: &parser::Node, parameter_t: &Vector(typechecking::NamedParameter), dry_run: bool) -> &Value {
    return get_function(scope, id, parameter_t, false, dry_run)
}

export def get_function(scope: &Scope, id: &parser::Node, parameter_t: &Vector(typechecking::NamedParameter)) -> &Value {
    return get_function(scope, id, parameter_t, false, false)
}

export def get(scope: &Scope, id: &parser::Node, force_compile: bool = true, check_export: bool = false, dry_run: bool = false, same_module: bool = false) -> &Value {
    if not scope { return null }
    assert((@id).kind == parser::NodeKind::IDENTIFIER)
    //TODO This optimization screws with incremental compilation
    //if id.svalue { return id.svalue }

    if vector::length((@id).value.identifier.path) == 1 {
        let name = @((@id).value.identifier.path[0])
        if name == "_" { 
            return get_underscore(scope) 
        }
        var value = scope.fields.get_or_default(name, null)
        if value { 
            if id.value.identifier.types {
                var score = 0
                let _, (value) = find_function(scope, id, value, id.value.identifier.types, *score, true)

                if value and force_compile and value.phase == Phase::DEFINED {
                    value = typecheck_function(value, id, scope, false, id.value.identifier.types)
                }
                return value
            } else if is_function(value.tpe) and id.parent and id.parent.kind == parser::NodeKind::PTR and value.next {
                if not dry_run { errors::errorn(id, "Ambiguous reference") }
                return null
            }

            if value and force_compile and value.phase == Phase::DEFINED {
                typecheck(value)
            }
        } else if scope.imports and not same_module and not check_export and not value {
            for var i in 0..vector::length((@scope).imports) {
                let imprt = (@scope).imports[i]
                let scope2 = imprt.module.scope
                var value2 = scope2.fields.get_or_default(name, null)
                
                if value2 and (@value2).share !int & parser::ShareMarker::EXPORT !int {
                    if value {
                        // TODO save location of values to give better error messages
                        if not dry_run { 
                            errors::errorn(id, "Ambiguous reference") 
                        }
                        return null
                    }

                    if id.value.identifier.types {
                        var score = 0
                        let _, (value2) = find_function(scope, id, value2, id.value.identifier.types, *score, true)
                        if value2 and force_compile and value2.phase == Phase::DEFINED {
                            value2 = typecheck_function(value2, id, scope, false, id.value.identifier.types)
                        }
                    } else {
                        if force_compile and value2.phase == Phase::DEFINED {
                            typecheck(value2)
                        }
                    }
                    value = value2
                }
            }
        }
        if scope.re_exports and name != "__main__" { // TODO To check for main is a dirty fix to allow wildcards
            for var i in 0..scope.re_exports.length {
                let re_export = scope.re_exports[i]
                if pattern_matches(id, re_export.pattern) {
                    var value2 = get(re_export.module.scope, id)
                    if value2 and value2.share !int & parser::ShareMarker::EXPORT !int {
                        if value and value !* != value2 !* {
                            if not dry_run {
                                errors::errorn(id, "Ambiguous reference")
                            }
                            return null
                        }
                        value = value2
                    }
                }
            }
        }
        if not value and (@scope).parent {
            value = get((@scope).parent, id, force_compile, check_export, dry_run, same_module)
        }
        if value and check_export and (value.share !int & parser::ShareMarker::EXPORT !int) == 0 {
            value = null
        }
        if not value and id.value.identifier.types {
            value = generate_function(scope, id, id.value.identifier.types, dry_run)
        }
        return value
    } else {
        let head = vector::head_vec((@id).value.identifier.path)
        let tail = vector::tail((@id).value.identifier.path)

        let id_head = parser::copy_node(id)
        (@id_head).value.identifier.path = head
        let id_tail = parser::copy_node(id)
        (@id_tail).value.identifier.path = tail

        let s = get(scope, id_head, force_compile, false, dry_run)
        if s {
            if not s.get_scope() {
                errors::errorn(id, "Use of :: on non namespace")
                return null
            }
            let value = get(s.get_scope(), id_tail, force_compile, s.imported, dry_run)
            return value
        }
        return null
    }
}

export def get_const_value(scope: &Scope, id: &parser::Node) -> &Value {
    let value = get(scope, id)
    if not value {
        errors::errorn(id, "Unknown identifier `", parser::identifier_to_str(id), "`")
        return null
    }
    if value.modifier != parser::VarDecl::CONST and value.modifier != parser::VarDecl::TYPE {
        return null
    }
    return value
}

export def get_type(scope: &Scope, id: &parser::Node) -> &typechecking::Type {
    let value = get_const_value(scope, id)
    if not value { return null }
    if (@value).modifier != parser::VarDecl::TYPE {
        return null
    }
    return (@value).value.value_tpe
}

// This function creates the namespaces for identifiers like 
// namespace::path::foo
// beware, this function can return null
def create_path(scope: &Scope, node: &parser::Node) -> &Scope {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)

    let length = vector::length((@node).value.identifier.path)
    for var i in 0..length - 1 {
        let ident = (@node).value.identifier.path[i]
        let scope_v = scope.fields.get_or_default(ident, null)
        if not scope_v {
            let n = parser::copy_node(node)
            let vec = vector::make(type &string)
            vec.push(ident)
            (@n).value.identifier.path = vec
            let scope2 = enter_scope(scope)
            enter_namespace(scope, scope2, n)
            scope = scope2
        } else {
            if not (@scope_v).get_scope() {
                errors::errorn(node, "Illegal declaration of `", parser::identifier_to_str(node), "`")
                return null
            } else {
                scope = (@scope_v).get_scope()
            }
        }
    }
    return scope
}

// Returns the last element in a path, eg Element for path::Element
// TODO Move this elsewhere
export def last_path_element(node: &parser::Node) -> string {
    assert((@node).kind == parser::NodeKind::IDENTIFIER)
    let length = vector::length((@node).value.identifier.path)
    return @((@node).value.identifier.path[length - 1])
}

// This overwrites value with the changes from other,
// while preserving some of the contents
def merge(value: &Value, other: &Value) {
    let dependencies = value.dependencies
    let dependants = value.dependants
    let unresolved = value.unresolved
    let dllimport = value.dllimport
    let dllexport = value.dllexport

    @value = @other
    value.dependencies = dependencies
    value.dependants = dependants
    value.unresolved = unresolved
    value.dllimport = dllimport
    value.dllexport = dllexport
}

// TODO These following functions grew organically, they are in need of a rewrite

export def create_function(scope: &Scope, name_node: &parser::Node, v: &Value, impl: bool = false) -> &Value {
    if not v { return null }

    let name = last_path_element(name_node)
    let phase = v.phase
    let tpe = v.tpe

    if scope.fields.contains(name) {
        var val = scope.fields[name]
        if not typechecking::is_function((@val).tpe) {
            errors::errorn(name_node, "Redeclaration of `", name, "`")
            return null 
        }
        var next = val
        loop {
            if phase == Phase::COMPILED and next.node and next.state {
                next.tpe = typechecking::lookup_parameters(next.node, next.state)
            }
            let s = typechecking::overload_score((@next).tpe, (@tpe).parameter_t, scope.module, true)
            if next.tpe and s == 0 {
                //if phase == Phase::DECLARED { return next }
                if phase == Phase::DEFINED and next.phase != Phase::DECLARED {
                    errors::errorn(name_node, "Function `", name, "` was already declared previously (same arguments)")
                    return null
                } else {
                    // Make sure we keep the chain intact
                    // TODO This is quite dodgy but its apparently needed for some reason
                    next.tpe = v.tpe
                    v.next = next.next
                    merge(next, v)
                }
                return next
            }
            if (@next).next {
                next = (@next).next
            } else {
                break
            }
        }
        (@next).next = v
    } else {
        (@scope).fields[name] = v
    }
    if impl {
        scope.implicits.push(v)
    }
    return v
}


// TODO Give better error messages, where was the function/variable declared previously?
export def create_function(
    scope: &Scope, name_node: &parser::Node, share: parser::ShareMarker, 
    tpe: &typechecking::Type, phase: Phase, node: &parser::Node,
    state: &typechecking::State, impl: bool = false) -> &Value {

    assert((@tpe).kind == typechecking::TypeKind::FUNCTION)

    scope = create_path(scope, name_node)
    if not scope { return null }
    let name = last_path_element(name_node)
    let global = is_global(scope)

    let v = {
        name_node = name_node,
        share = share,
        modifier = parser::VarDecl::CONST,
        name = name,
        assembly_name = name,
        impl = impl,
        tpe = tpe,
        phase = phase,
        global = global,
        node = node,
        state = state,
        ident = make_ident(name, scope.module, node.signature_hash if node else 0, tpe.type_name)
    } !&Value

    if global {
        // Remove unresolved symbols
        v.unresolved = set::make(Ident)
        v.dependencies = set::make(Ident)
        v.dependants = set::make(Ident)
    }

    return create_function(scope, name_node, v, impl)
}

export def create_function(
    scope: &Scope, name_node: &parser::Node, share: parser::ShareMarker, 
    tpe: &typechecking::Type, impl: bool = false) -> &Value {
    return create_function(scope, name_node, share, tpe, Phase::COMPILED, null, null, impl)
}

def append_scope_count(scope: &Scope, name: &string) -> &string {
    let scope_count = get_scope_count(scope)
    return name + '.' + scope_count
}

export def create_variable(
    scope: &Scope, name_node: &parser::Node, share: parser::ShareMarker, 
    modifier: parser::VarDecl, tpe: &typechecking::Type, extern: bool, dllimport: bool, dllexport: bool,
    value: &compiler::Value, phase: Phase, node: &parser::Node, state: &typechecking::State) -> &Value {
    
    scope = create_path(scope, name_node)
    if not scope { return null }
    let name = last_path_element(name_node)

    let global = is_global(scope)
    let v = {
        name_node = name_node,
        dllimport = dllimport,
        dllexport = dllexport,
        extern = extern,
        share = share,
        modifier = modifier,
        name = name,
        tpe = tpe,
        value = value,
        global = global,
        phase = phase,
        node = node,
        state = state,
        ident = make_ident(name, scope.module, node._hash if node else 0)
    } !&Value

    if global {
        v.unresolved = set::make(Ident)
        v.dependencies = set::make(Ident)
        v.dependants = set::make(Ident)
    }

    if extern {
        v.assembly_name = name
    } else if global {
        v.assembly_name = typechecking::append_module(name, (@name_node).loc.module)
    } else {
        v.assembly_name = append_scope_count(scope, name)
    }

    let val = scope.fields.get_or_default(name, null)
    if val {
        if phase == Phase::DEFINED and val.phase != Phase::DECLARED or 
            phase == Phase::COMPILED and val.phase != Phase::DEFINED and val.phase != Phase::DECLARED or 
            typechecking::is_function(val.tpe) or typechecking::is_type(val.tpe) {

            errors::errorn(name_node, "Redeclaration of `", name, "`")
        } else {
            merge(val, v)
            return val
        }
    } else {
        scope.fields[name] = v
    }

    return v
}

export def create_variable(
    scope: &Scope, name_node: &parser::Node, share: parser::ShareMarker, 
    modifier: parser::VarDecl, tpe: &typechecking::Type, extern: bool, value: &compiler::Value) -> &Value {
    return create_variable(scope, name_node, share, modifier, tpe, extern, false, false, value, Phase::COMPILED, null, null)
}

export def create_variable(
    scope: &Scope, name_node: &parser::Node, share: parser::ShareMarker, 
    modifier: parser::VarDecl, tpe: &typechecking::Type, value: &compiler::Value) -> &Value {
    return create_variable(scope, name_node, share, modifier, tpe, false, false, false, value, Phase::COMPILED, null, null)
}

export def create_type(
    scope: &Scope, name_node: &parser::Node, 
    share: parser::ShareMarker, tpe: &typechecking::Type, 
    phase: Phase, node: &parser::Node, state: &typechecking::State,
    no_svalue: bool = false
) -> &Value {

    scope = create_path(scope, name_node)
    if not scope { return null }
    let name = last_path_element(name_node)

    let value_tpe = { kind = compiler::ValueKind::TYPE, tpe = builtins::type_, value_tpe = tpe } !compiler::Value

    let global = is_global(scope)
    let v = {
        name_node = name_node,
        share = share,
        modifier = parser::VarDecl::TYPE,
        name = name,
        assembly_name = name,
        tpe = builtins::type_,
        value = value_tpe,
        _module = tpe.scope,
        global = global,
        phase = phase,
        node = node,
        state = state,
        ident = make_ident(name, scope.module)
    } !&Value
    if global {
        v.unresolved = set::make(Ident)
        v.dependencies = set::make(Ident)
        v.dependants = set::make(Ident)
    }

    let value = scope.fields.get_or_default(name, null)
    if value {
        let tpe2 = value.value
        // TODO This logic is flawed, rethink how we handle phases and make sure that types can be declared multiple times but only defined once.
        if phase == Phase::DEFINED and value.phase != Phase::DECLARED or 
            phase == Phase::COMPILED and value.phase != Phase::DEFINED and value.phase != Phase::DECLARED and not typechecking::is_stub(tpe2.value_tpe) or 
            value.tpe.kind != typechecking::TypeKind::TYPE {
            
            errors::errorn(node, "Redeclaration of `", name, "`")
            return null
        } 
        //if phase != Phase::DECLARED {
            if not no_svalue { tpe.svalue = value }
            @tpe2.value_tpe = @tpe
            v.value = tpe2
            merge(value, v)
        //}
        return value
    } else {
        if not no_svalue { tpe.svalue = v }
        scope.fields[name] = v
    }
    return v
}

export def create_type(
    scope: &Scope, name_node: &parser::Node, 
    share: parser::ShareMarker, tpe: &typechecking::Type, no_svalue: bool = false) -> &Value {
    return create_type(scope, name_node, share, tpe, Phase::COMPILED, null, null, no_svalue = no_svalue)
}

export def enter_namespace(scope: &Scope, scope2: &Scope, node: &parser::Node) -> &Value {
    
    scope = create_path(scope, node)
    if not scope { return null }
    let name = last_path_element(node)
    let tpe = typechecking::make_type(typechecking::TypeKind::NAMESPACE, node)

    let v = {
        share = parser::ShareMarker::NONE,
        modifier = parser::VarDecl::CONST,
        name = name,
        assembly_name = name,
        tpe = tpe,
        _scope = scope2,
        global = is_global(scope)
    } !&Value

    let value = scope.fields.get_or_default(name, null)
    if value and not value.get_scope() {
        errors::errorn(node, "Redeclaration of `", name, "`")
    } else {
        scope.fields[name] = v
    }
    return v
}

export def insert_module(scope: &Scope, alias: &parser::Node, module: &toolchain::Module) -> &Value {
    // Don't import the same module twice
    if scope.imports {
        for var i in 0..vector::length(scope.imports) {
            let module2 = scope.imports[i]
            if module.filename == module2.module.filename { return null }
        }
    }

    let v = enter_namespace(scope, module.scope, alias)
    v.imported = true
    v._module = module.scope
    v._scope = null

    if not scope.imports {
        scope.imports = vector::make(ImportedModule)
    }
    scope.imports.push({
        module = module,
        alias = alias
    } !ImportedModule)

    return v
}

export def insert_re_export(scope: &Scope, pattern: &parser::Node, module: &toolchain::Module) {
    assert scope != null
    if not scope.re_exports {
        scope.re_exports = vector::make(ReExport)
    }
    scope.re_exports.push({
        module = module,
        pattern = pattern
    } !ReExport)
}

def pattern_matches(this: &parser::Node, other: &parser::Node) -> bool {
    if not other { return true }
    // TODO This is going to fail if we add namespaces
    let thisname = last_path_element(this)
    let othername = last_path_element(other)
    if thisname != othername { return false }

    let this_types = this.value.identifier.types
    let other_types = other.value.identifier.types
    if other_types {
        if not this_types { return true }
        if this_types.length != other_types.length { return false }
        for var i in 0..this_types.length {
            if not typechecking::equals(this_types[i].tpe, other_types[i].tpe) {
                return false
            }
        }
    }
    return true
}

def pattern_matches(this: &parser::Node, other: &parser::Node, parameter_t: &Vector(typechecking::NamedParameter)) -> bool {
    if not pattern_matches(this, other) { return false }
    if not other { return true }

    let other_types = other.value.identifier.types
    if not other_types { return true }

    if other_types.length != parameter_t.length { return false }
    for var i in 0..other_types.length {
        if not typechecking::equals(other_types[i].tpe, parameter_t[i].tpe) {
            return false
        }
    }
    return true
}