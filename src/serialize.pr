import typechecking
import toolchain
import lexer
import parser
import debug
import vector
import map
import set
import scope
import compiler
import consteval
import scope
import util
import builtins

type Serialize = struct {
    module: weak_ref(toolchain::Module)
    types: &Map(&typechecking::Type, int64)
    dependencies: &Set(scope::Ident)
}

const MAGIC = "PRNCSVI"

def add_type(tpe: &typechecking::Type, state: &Serialize) -> int64 {
    if not tpe { return -1 }

    let name = debug::type_to_str(tpe, full_name = true)
    var index: int64 = -1
    if name {
        if state.types.contains(tpe) { return state.types[tpe] }
        index = state.types.size
        state.types[tpe] = index
    }

    if tpe.tc_args {
        for var i in 0..tpe.tc_args.length {
            let tc_arg = tpe.tc_args[i]
            add_type(tc_arg, state)
        }
    }

    if typechecking::is_box(tpe) or 
        typechecking::is_enum(tpe) or 
        tpe.kind == typechecking::TypeKind::TYPE or 
        tpe.kind == typechecking::TypeKind::TYPE_DEF {
        
        add_type(tpe.tpe, state)
    } else if typechecking::is_struct(tpe) {
        for var i in 0..tpe.fields.size {
            let field = tpe.fields[i]
            typechecking::lookup_struct_member(field)
            add_type(field.tpe, state)
        }
    } else if tpe.kind == typechecking::TypeKind::FUNCTION or
        tpe.kind == typechecking::TypeKind::CLOSURE or 
        tpe.kind == typechecking::TypeKind::TYPE_CONSTRUCTOR {

        for var i in 0..tpe.parameter_t.length {
            let np = tpe.parameter_t[i]
            add_type(np.tpe, state)
        }
        if tpe.kind != typechecking::TypeKind::TYPE_CONSTRUCTOR {
            for var i in 0..tpe.return_t.length {
                add_type(tpe.return_t[i], state)
            }
        }
    } else if tpe.kind == typechecking::TypeKind::STRUCTURAL {
        for var i in 0..tpe.members.length {
            let member = tpe.members[i]
            for var i in 0..member.parameter_t.length {
                let np = member.parameter_t[i]
                add_type(np.tpe, state)
            }
            for var i in 0..member.return_t.length {
                add_type(member.return_t[i], state)
            }
        }
    } else if tpe.kind == typechecking::TypeKind::GENERIC {
        add_type(tpe.tpe, state)
    }

    return index
}

let TYPE_MOD: byte = -1
let TYPE_REF: byte = -2
let VARARGS: byte = -3
let NO_TYPE: byte = -4

def write_module_reference(fp: File, tpe: &typechecking::Type, state: &Serialize) {
    // Module reference
    fp.write(*TYPE_MOD)

    let defmodule = tpe.defmodule if tpe.defmodule else tpe.module
    fp.write_str(defmodule.module if defmodule else null)
    if defmodule !* == builtins::builtins_module !* {
        fp.write_str("builtins")
    } else if defmodule !* == toolchain::runtime_ {
        fp.write_str("runtime")
    } else {
        assert defmodule.filename != null
        fp.write_str(defmodule.filename)
    }
    fp.write_str(tpe.name)
    fp.write_str(tpe.type_name)
}

def write_type(fp: File, tpe: &typechecking::Type, state: &Serialize) {
    if not tpe { 
        fp.write(*NO_TYPE) 
        return
    }

    if tpe.defmodule and tpe.defmodule != state.module and tpe.name and not tpe.tc_args {
        write_module_reference(fp, tpe, state)
        return
    }

    let index = add_type(tpe, state)
    if index < 0 {
        fp.write(*NO_TYPE)
    } else {
        fp.write(*TYPE_REF)
        fp.write(*index)
    }
}

def serialize_type(fp: File, tpe: &typechecking::Type, state: &Serialize) {
    if not tpe {
        fp.write(*NO_TYPE)
        return
    }
    if tpe.kind == typechecking::TypeKind::BOX {
        tpe = tpe.weak
    }
    assert tpe.kind != typechecking::TypeKind::BOX

    if tpe.defmodule and tpe.defmodule != state.module and tpe.name and not tpe.tc_args {
        write_module_reference(fp, tpe, state)
    } else {
        let id = tpe.kind !byte
        fp.write(*id)
        let hash = tpe.hash
        fp.write(*hash)
        fp.write_str(tpe.name)
        fp.write_str(tpe.type_name)
        fp.write_str(tpe.defmodule.module if tpe.defmodule else null)
        fp.write_str(tpe.module.module if tpe.module else null)
        fp.write(*tpe.tc_incomplete)
        
        if tpe.tc_args {
            fp.write(*tpe.tc_args.length)
            for var i in 0..tpe.tc_args.length {
                write_type(fp, tpe.tc_args[i], state)
            }
        } else {
            let zero: uint64 = 0
            fp.write(*zero)
        }

        fp.write(*tpe.size)
        fp.write(*tpe.align)

        if tpe.kind == typechecking::TypeKind::WORD {
            fp.write(*tpe.unsig)
        } else if tpe.kind == typechecking::TypeKind::STATIC_ARRAY {
            let len = tpe.length
            fp.write(*len)
            write_type(fp, tpe.tpe, state)
        } else if typechecking::is_box(tpe) or tpe.kind == typechecking::TypeKind::TYPE or
            tpe.kind == typechecking::TypeKind::TYPE_DEF {

            write_type(fp, tpe.tpe, state)
        } else if typechecking::is_struct(tpe) {
            let sz = tpe.fields.size
            fp.write(*sz)
            for var i in 0..sz {
                let field = tpe.fields[i]
                write_type(fp, field.tpe, state)
                fp.write(*field.line)
                fp.write(*field.is_bitfield)
                fp.write(*field.bit_size)
                fp.write_str(field.name)
            }
            if tpe.kind == typechecking::TypeKind::UNION {
                write_type(fp, tpe.field_types[0].tpe, state)
            }
        } else if tpe.kind == typechecking::TypeKind::FUNCTION or
            tpe.kind == typechecking::TypeKind::CLOSURE {
            fp.write(*tpe.parameter_t.length)
            for var i in 0..tpe.parameter_t.length {
                let np = tpe.parameter_t[i]
                write_type(fp, np.tpe, state)
                fp.write_str(np.name)
            }
            fp.write(*tpe.return_t.length)
            for var i in 0..tpe.return_t.length {
                write_type(fp, tpe.return_t[i], state)
            }
        } else if tpe.kind == typechecking::TypeKind::STRUCTURAL {
            fp.write(*tpe.members.length)
            for var i in 0..tpe.members.length {
                let member = tpe.members[i]
                fp.write_str(member.name)
                fp.write(*member.parameter_t.length)
                for var i in 0..member.parameter_t.length {
                    let np = member.parameter_t[i]
                    write_type(fp, np.tpe, state)
                    fp.write_str(np.name)
                }
                fp.write(*member.return_t.length)
                for var i in 0..member.return_t.length {
                    write_type(fp, member.return_t[i], state)
                }
            }
        } else if tpe.kind == typechecking::TypeKind::STUB {
            // nothing here
        } else if tpe.kind == typechecking::TypeKind::ENUM {
            write_type(fp, tpe.tpe, state)

            let scpe = tpe.scope
            let ekeys = scpe.fields.keys()
            let sz = ekeys.size
            fp.write(*sz)
            for var i in 0..sz {
                let key = ekeys[i]
                let value = scpe.fields[key]
                assert value.modifier == parser::VarDecl::CONST
                fp.write_str(value.name)
                fp.write(*value.value.i)
            }
        } else if tpe.kind == typechecking::TypeKind::TYPE_CONSTRUCTOR {
            fp.write(*tpe.parameter_t.length)
            for var i in 0..tpe.parameter_t.length {
                let np = tpe.parameter_t[i]
                fp.write_str(np.name)
            }
            let loc = tpe.tc_node.loc
            fp.write(*loc.line)
            fp.write(*loc.column)
            fp.write(*loc.end_line)
            fp.write(*loc.end_column)
        } else if tpe.kind == typechecking::TypeKind::GENERIC {
            assert tpe.tpe != null
            write_type(fp, tpe.tpe, state)
        } else if tpe.kind == typechecking::TypeKind::CHAR {
        } else {
            error(tpe.kind, "\n")
            assert
        }
    }
}

def serialize_function(fp: File, value: &scope::Value, state: &Serialize) {
    let tpe = value.tpe
    let hash = value.ident._hash
    let share = value.share !byte
    fp.write(*hash)
    fp.write(*share)
    fp.write(*value.extern)
    fp.write(*value.imported)
    fp.write(*value.polymorph)
    fp.write(*value.impl)
    // TODO Get Function object with dllexport and dllimport
    fp.write_str(value.name)
    fp.write_str(tpe.type_name)

    state.dependencies.add_all(value.dependencies)

    fp.write(*tpe.parameter_t.length)
    for var i in 0..tpe.parameter_t.length {
        let np = tpe.parameter_t[i]
        fp.write_str(np.name)
        fp.write(*np.varargs)
        if not np.tpe and np.varargs {
            fp.write(*VARARGS)
            let f = false
            fp.write(*f) // has_value
        } else {
            let has_value = np.value and np.value.kind != compiler::ValueKind::TYPE
            if np.value and np.value.kind == compiler::ValueKind::TYPE {
                // TODO This shouldn't be in value but instead be stored on the type directly
                np.tpe._tpe = np.value.value_tpe
            }
            write_type(fp, np.tpe, state)
            fp.write(*has_value)
            if has_value {
                serialize_value(fp, np.value, state)
            }
        }
    }
    fp.write(*tpe.return_t.length)
    for var i in 0..tpe.return_t.length {
        let tpe = tpe.return_t[i]
        write_type(fp, tpe, state)
    }
    // TODO This is because is_polymorph (incorrectly) returns true for TYPE_DEF
    // This is needed in some other places, hence the workaround
    let is_polymorph = typechecking::is_polymorph(tpe) and value.node
    fp.write(*is_polymorph)
    if is_polymorph {
        let loc = value.node.loc
        fp.write(*loc.line)
        fp.write(*loc.column)
        fp.write(*loc.end_line)
        fp.write(*loc.end_column)
    }
}

def create_type_if_absent(module: &toolchain::Module, tpe: &typechecking::Type) -> &typechecking::Type {
    let ident = parser::make_identifier(tpe.name)
    tpe._defmodule = module
    var value = scope::get(module.scope, ident, force_compile = false, dry_run = true, same_module = true)
    if value and value.modifier == parser::VarDecl::TYPE {
        return value.value.value_tpe
    }
    value = scope::create_type(module.scope, ident, parser::ShareMarker::EXPORT, tpe, scope::Phase::DECLARED, null, module.state)
    value.identifier = ident
    return tpe
}

def deserialize_node(deserialize: &Deserialize, loc: parser::SourceLoc) -> &parser::Node {
    let tokens = lexer::lex(deserialize.module.text, loc.line, loc.column, loc.end_line, loc.end_column)
    let parse_state = parser::make_state(deserialize.module.filename, deserialize.module.display_name, deserialize.module.module, deserialize.module.lines, tokens)
    let node = parser::parse_statement(parse_state)
    delete(tokens)

    deserialize.nodes.push(node)
    return node
}

def deserialize_type_node(deserialize: &Deserialize, loc: parser::SourceLoc) -> &parser::Node {
    let tokens = lexer::lex(deserialize.module.text, loc.line, loc.column, loc.end_line, loc.end_column)
    let parse_state = parser::make_state(deserialize.module.filename, deserialize.module.display_name, deserialize.module.module, deserialize.module.lines, tokens)
    let node = parser::parse_type(parse_state)
    delete(tokens)

    deserialize.nodes.push(node)
    return node
}

def deserialize_type(deserialize: &Deserialize, fp: File, tpe: &typechecking::Type = null) -> &typechecking::Type {
    var kind: byte
    fp.read(*kind)
    if kind == NO_TYPE { return null }
    if kind == VARARGS { return null }

    if not tpe {
        tpe = { kind = typechecking::TypeKind::STUB } !&typechecking::Type
    }

    if kind == TYPE_MOD {
        let module = fp.read_str()
        let filename = fp.read_str()
        let name = fp.read_str()
        let type_name = fp.read_str()
        if filename == "builtins" {
            @tpe = @builtins::builtins_module.scope.get_type(parser::make_identifier(name))
            return tpe
        }
        tpe.type_name = type_name
        tpe.name = name
        return create_type_if_absent(toolchain::create_module_if_absent(filename, module), tpe)
    } else if kind == TYPE_REF {
        var index: int64
        fp.read(*index)

        if index < 0 { return null }
        if index < deserialize.types.length {
            let tpe = deserialize.types[index]
            if tpe { return tpe }
        }

        tpe.kind = typechecking::TypeKind::STUB
        deserialize.types.resize(max(index + 1, deserialize.types.length) !size_t)
        vector::set_item(deserialize.types, index, tpe) // TODO Why do we have to do this??

        return tpe
    } else {
        var tpekind = kind !typechecking::TypeKind

        var hash: uint64
        fp.read(*hash)
        var name = fp.read_str()
        var type_name = fp.read_str()
        var defmodule_str = fp.read_str()
        var module_str = fp.read_str()
        
        var defmodule: &toolchain::Module
        if module_str {
            defmodule = toolchain::find_module(defmodule_str)
        } else {
            defmodule = deserialize.module
        }

        var module: &toolchain::Module
        if module_str {
            module = toolchain::find_module(module_str)
        } else {
            module = deserialize.module
        }

        var tc_incomplete: bool
        fp.read(*tc_incomplete)

        var sz: uint64
        var tc_args: &Vector(&typechecking::Type)
        fp.read(*sz)
        if sz > 0 {
            tc_args = vector::make(type &typechecking::Type)
            for var i in 0..sz {
                tc_args.push(deserialize_type(deserialize, fp))
            }
        }

        var size: uint64
        fp.read(*size)
        var align: uint64
        fp.read(*align)

        @tpe = { 
            kind = tpekind, 
            name = name, 
            type_name = type_name,
            is_in_type_cache = false,
            module = module,
            _defmodule = defmodule,
            tc_incomplete = tc_incomplete,
            size = size,
            align = align,
            _hash = hash,
            tc_args = tc_args
        } !typechecking::Type

        switch tpekind !int {
        case typechecking::TypeKind::CHAR:
            tpe = builtins::char_
        case typechecking::TypeKind::WORD:
            fp.read(*tpe.unsig)
        case typechecking::TypeKind::STATIC_ARRAY:
            fp.read(*tpe.length)
            tpe._tpe = deserialize_type(deserialize, fp)
        case typechecking::TypeKind::TYPE, 
            typechecking::TypeKind::TYPE_DEF,
            typechecking::TypeKind::POINTER,
            typechecking::TypeKind::REFERENCE,
            typechecking::TypeKind::WEAK_REF,
            typechecking::TypeKind::ARRAY:

            let ptpe = deserialize_type(deserialize, fp)
            if ptpe and ptpe.is_in_type_cache {
                tpe._tpe = typechecking::box(ptpe)
            } else {
                tpe._tpe = ptpe
            }
        case typechecking::TypeKind::STRUCT,
            typechecking::TypeKind::UNION:
            
            var sz: size_t
            fp.read(*sz)

            let fields = allocate_ref(typechecking::StructMember, sz)
            for var i in 0..sz {
                var np = {} !typechecking::StructMember
                np.tpe = deserialize_type(deserialize, fp)
                fp.read(*np.line)
                fp.read(*np.is_bitfield)
                fp.read(*np.bit_size)
                np.name = fp.read_str()
                fields[i] = np
            }
            tpe.fields = fields
            
            if tpekind == typechecking::TypeKind::STRUCT {
                @tpe = @typechecking::make_struct_type(fields)
                // TODO Maybe only pick what's actually needed
                tpe._hash = hash
                tpe.type_name = type_name
                tpe.name = name
                tpe.module = module
                tpe._defmodule = defmodule
                tpe.tc_incomplete = tc_incomplete
                tpe.size = size
                tpe.align = align
                tpe.tc_args = tc_args
            } else {
                let biggest_type = deserialize_type(deserialize, fp)
                let field_types = vector::make(typechecking::TypeMember)
                let type_member = { biggest_type, 0 } !typechecking::TypeMember
                field_types.push(type_member)
                tpe.field_types = field_types
            }
        case typechecking::TypeKind::FUNCTION,
            typechecking::TypeKind::CLOSURE:

            var fun: &typechecking::Type
            if tpekind == typechecking::TypeKind::CLOSURE {
                var ntpe, (fun) = typechecking::make_closure_type()
                @tpe = @ntpe
                tpe._hash = hash
                tpe.type_name = type_name
                tpe.name = name
                tpe.module = module
                tpe._defmodule = defmodule
                tpe.tc_incomplete = tc_incomplete
                tpe.tc_args = tc_args
            }

            let parameter_t = vector::make(typechecking::NamedParameter)
            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                var np: typechecking::NamedParameter
                np._tpe =  deserialize_type(deserialize, fp)
                np.name = fp.read_str()
                parameter_t.push(np)
                if fun {
                    fun.parameter_t.push(np)
                }
            }

            let return_t = vector::make(type &typechecking::Type)
            fp.read(*size)
            for var i in 0..size {
                let ret_tpe = deserialize_type(deserialize, fp)
                return_t.push(ret_tpe)
                if fun {
                    fun.return_t.push(ret_tpe)
                }
            }
            tpe.parameter_t = parameter_t
            tpe.return_t = return_t
        case typechecking::TypeKind::STRUCTURAL:
            let members = vector::make(typechecking::StructuralTypeMember)
            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                var member: typechecking::StructuralTypeMember
                member.name = fp.read_str()

                var size: size_t
                member.parameter_t = vector::make(typechecking::NamedParameter)
                fp.read(*size)
                for var i in 0..size {
                    var np: typechecking::NamedParameter
                    let ftpe = deserialize_type(deserialize, fp)
                    if ftpe and ftpe.is_in_type_cache {
                        np._tpe =  typechecking::box(ftpe)
                    } else {
                        np._tpe =  ftpe
                    }
                    np.name = fp.read_str()
                    member.parameter_t.push(np)
                }
                member.return_t = vector::make(type &typechecking::Type)
                fp.read(*size)
                for var i in 0..size {
                    member.return_t.push(deserialize_type(deserialize, fp))
                }
                members.push(member)
            }
            tpe.members = members
        case typechecking::TypeKind::STUB:
            // nothing here
        case typechecking::TypeKind::ENUM:
            tpe._tpe = deserialize_type(deserialize, fp)

            let scpe = scope::enter_scope(deserialize.module.scope)
            deserialize.scopes.push(scpe)
            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                let name = parser::make_identifier(fp.read_str())
                var value: int64
                fp.read(*value)
                let v = scope::create_variable(scpe,
                    name, parser::ShareMarker::EXPORT, parser::VarDecl::CONST, tpe, 
                    { kind = compiler::ValueKind::INT, tpe = tpe.tpe, i = value } !compiler::Value
                )
                v.identifier = name
            }
            tpe.scope = scpe
        case typechecking::TypeKind::TYPE_CONSTRUCTOR:
            tpe.parameter_t = vector::make(typechecking::NamedParameter)

            var size: size_t
            fp.read(*size)
            for var i in 0..size {
                let name = fp.read_str()
                var np: typechecking::NamedParameter
                np._tpe =  builtins::type_
                np.name = name
                tpe.parameter_t.push(np)
            }

            var loc: parser::SourceLoc
            fp.read(*loc.line)
            fp.read(*loc.column)
            fp.read(*loc.end_line)
            fp.read(*loc.end_column)
            let node = deserialize_type_node(deserialize, loc)
            tpe.tc_node = node
            tpe.cache = map::make(type &typechecking::Type)
        case typechecking::TypeKind::GENERIC:
            tpe._tpe = deserialize_type(deserialize, fp)
        case typechecking::TypeKind::BOOL:
            return builtins::bool_
        case:
            error(tpe.kind, "\n")
            assert
        }

        return tpe
    }
}

def deserialize_function(deserialize: &Deserialize, fp: File) {
    var hash: uint64
    var share: bool
    var extern: bool
    var imported: bool
    var impl: bool
    var polymorph: bool
    var name: &string
    var type_name: &string

    fp.read(*hash)
    fp.read(*share)
    fp.read(*extern)
    fp.read(*imported)
    fp.read(*polymorph)
    fp.read(*impl)
    name = fp.read_str()
    type_name = fp.read_str()

    var size: size_t
    fp.read(*size)

    let parameter_t = vector::make(typechecking::NamedParameter)
    for var i in 0..size {
        var name = fp.read_str()
        var varargs: bool
        fp.read(*varargs)
        let tpe = deserialize_type(deserialize, fp)
        var has_value: bool
        fp.read(*has_value)

        var value: &compiler::Value
        if has_value {
            value = deserialize_value(deserialize, fp)
        }
        parameter_t.push({ name = name, _tpe = tpe, varargs = varargs, value = value } !typechecking::NamedParameter)
    }

    let return_t = vector::make(type &typechecking::Type)
    fp.read(*size)
    for var i in 0..size {
        let tpe = deserialize_type(deserialize, fp)
        return_t.push(tpe)
    }

    var node: &parser::Node
    var state: &typechecking::State

    let ftpe = typechecking::make_function_type()
    ftpe.type_name = type_name
    ftpe.name = name
    ftpe.module = deserialize.module
    ftpe.parameter_t = parameter_t
    ftpe.return_t = return_t

    var is_polymorph: bool
    fp.read(*is_polymorph)
    if is_polymorph {
        var loc: parser::SourceLoc
        fp.read(*loc.line)
        fp.read(*loc.column)
        fp.read(*loc.end_line)
        fp.read(*loc.end_column)
        node = deserialize_node(deserialize, loc)
        state = deserialize.module.state
        deserialize.nodes.push(node)

        node.value.def_.function = {
            is_global = true,
            module = deserialize.module,
            name = ftpe.type_name,
            unmangled = ftpe.name
        } !&compiler::Function
    }

    deserialize.functions.push({
        name = name,
        hash = hash,
        node = node,
        state = state,
        ftpe = ftpe,
        imported = imported,
        polymorph = polymorph
    } !FunctionEntry)
}

def serialize_variable(fp: File, value: &scope::Value, state: &Serialize) {
    let hash = value.node._hash if value.node else 0
    let share = value.share !byte
    let modifier = value.modifier !byte
    let is_constant = value.modifier == typechecking::VarDecl::CONST

    fp.write(*hash)
    fp.write(*share)
    fp.write(*modifier)
    fp.write(*value.extern)
    fp.write(*value.dllimport)
    fp.write(*value.dllexport)
    fp.write_str(value.name)

    state.dependencies.add_all(value.dependencies)

    write_type(fp, value.tpe, state)
    fp.write(*is_constant)
    if is_constant {
        serialize_value(fp, value.value, state)
    }
}

def deserialize_variable(deserialize: &Deserialize, fp: File) {
    var hash: uint64
    var share: byte
    var modifier: byte
    var extern: bool
    var dllimport: bool
    var dllexport: bool
    
    fp.read(*hash)
    fp.read(*share)
    fp.read(*modifier)
    fp.read(*extern)
    fp.read(*dllimport)
    fp.read(*dllexport)
    let name = fp.read_str()

    let tpe = deserialize_type(deserialize, fp)
    var is_constant: bool
    fp.read(*is_constant)
    var value: &compiler::Value
    if is_constant {
        value = deserialize_value(deserialize, fp)
    }

    deserialize.variables.push({
        name = name,
        hash = hash,
        modifier = modifier !parser::VarDecl,
        extern = extern,
        dllimport = dllimport,
        dllexport = dllexport,
        tpe = tpe,
        value = value
    } !VariableEntry)
}

let NO_VALUE: byte = -1

def serialize_value(fp: File, value: &compiler::Value, state: &Serialize) {
    if not value {
        fp.write(*NO_VALUE)
        return
    }
    let kind = value.kind !byte
    fp.write(*kind)
    fp.write(*value.metadata)
    fp.write(*value.distinct)
    fp.write_str(value.name)
    fp.write(*value.i)
    fp.write(*value.f)
    fp.write_str(value.s)
    write_type(fp, value.value_tpe, state)
    if value.values {
        let sz = value.values.size
        fp.write(*sz)
        for var i in 0..sz {
            serialize_value(fp, value.values[i], state)
        }
    } else {
        let zero: uint64 = 0
        fp.write(*zero)
    }
    write_type(fp, value.tpe, state)
}

def deserialize_value(deserialize: &Deserialize, fp: File) -> &compiler::Value {
    var kind: byte
    fp.read(*kind)
    if kind == NO_VALUE {
        return null
    }

    let value = {} !&compiler::Value
    value.kind = kind !compiler::ValueKind
    fp.read(*value.metadata)
    fp.read(*value.distinct)
    value.name = fp.read_str()
    fp.read(*value.i)
    fp.read(*value.f)
    value.s = fp.read_str()
    value.value_tpe = deserialize_type(deserialize, fp)
    var sz: uint64
    fp.read(*sz)
    value.values = allocate_ref(type compiler::Value, sz)
    for var i in 0..sz {
        value.values[i] = @deserialize_value(deserialize, fp)
    }
    value.tpe = deserialize_type(deserialize, fp)

    return value
}

export def serialize(module: &toolchain::Module) {
    let cache_file = toolchain::outfolder + "/" + module.file + ".prc"

    let fp = open(@cache_file, "wb")
    defer close(fp)
    fp.write(MAGIC)

    let state = {
        types = map::make(type &typechecking::Type, int64),
        module = module,
        dependencies = set::make(scope::Ident)
    } !&Serialize

    if module.deserialize and not toolchain::no_incremental {
        // Keep types that have been deserialized for this module
        for var i in 0..module.deserialize.types.length {
            add_type(module.deserialize.types[i], state)
        }
    }

    let zero: uint64 = 0

    // Write imports
    let imports = module.scope.imports
    if imports {
        fp.write(*imports.length)
        for var i in 0..imports.length {
            let imp = imports[i]
            fp.write_str(parser::identifier_to_str(imp.alias))
            fp.write_str(imp.module.module)
            fp.write_str(imp.module.filename)
        }
    } else {
        fp.write(*zero)
    }

    let re_exports = module.scope.re_exports
    if re_exports {
        fp.write(*re_exports.length)
        for var i in 0..re_exports.length {
            let re_export = re_exports[i]
            fp.write_str(re_export.module.module)
            fp.write_str(parser::identifier_to_str(re_export.pattern, types = false))
            let types = re_export.pattern.value.identifier.types
            if types {
                fp.write(*types.length)
                for var j in 0..types.length {
                    let tpe = types[i].tpe
                    write_type(fp, tpe, state)
                }
            } else {
                fp.write(*zero)
            }
        }
    } else {
        fp.write(*zero)
    }

    let functions = scope::all_functions(module.scope)
    let exported_functions = vector::make(type &scope::Value)
    for var value in functions {
        // We need to serialize types of local variables
        // as these are referencing types in the types module
        if value.node {
            let function = value.node.value.def_.function
            if function.all_locals {
                let locals = function.all_locals
                let keys = locals.keys()
                for var i in 0..keys.size {
                    var key = keys[i]
                    let tpe = locals[key]
                    add_type(tpe, state)
                }
            }
        }
        if value.share !int & parser::ShareMarker::EXPORT !int { 
            exported_functions.push(value)
        }
    }

    fp.write(*exported_functions.length) // Number of functions
    for var i in 0..exported_functions.length {
        let value = exported_functions[i]
        serialize_function(fp, value, state)
    }

    let variables = vector::make(type &scope::Value)
    let types = vector::make(type &scope::Value)
    let keys = module.scope.fields.keys()
    for var i in 0..keys.size {
        let key = keys[i]
        let value = module.scope.fields[key]
        if value.modifier == parser::VarDecl::TYPE {
            types.push(value)
            state.dependencies.add_all(value.dependencies)
        } else if value.share !int & parser::ShareMarker::EXPORT !int {
            if value.modifier == parser::VarDecl::CONST {
                if value.tpe.kind != typechecking::TypeKind::FUNCTION {
                    variables.push(value)
                }
            } else if value.modifier != parser::VarDecl::TYPE {
                variables.push(value)
            }
        }
    }

    fp.write(*variables.length)
    for var i in 0..variables.length {
        serialize_variable(fp, variables[i], state)
    }

    fp.write(*types.length)
    for var i in 0..types.length {
        let value = types[i]
        fp.write_str(value.name)
        let share: byte = value.share !byte
        fp.write(*share)
        fp.write(*value.ident._hash)
        write_type(fp, value.value.value_tpe, state)
    }

    let types_size = state.types.size
    fp.write(*types_size) // Number of types
    let keys1 = state.types.keys()
    for var i in 0..keys1.size { 
        let key = keys1[i]
        serialize_type(fp, key, state)
    }
    assert types_size == state.types.size // Make sure we don't add any new types on the way

    // Filter out local stuff
    let dependencies = set::make(scope::Ident)
    let keys2 = state.dependencies.keys()
    for var i in 0..keys2.size {
        let ident = keys2[i]
        if ident.module != module {
            dependencies.add(ident)
        }
    }

    let keys3 = dependencies.keys()
    fp.write(*dependencies.size)
    for var i in 0..keys3.size {
        let ident = keys3[i]
        fp.write(*ident._hash)
        fp.write_str(ident.name)
        fp.write_str(ident.signature)
        fp.write_str(ident.module.module if ident.module else null)
    }
}

type FunctionEntry = struct {
    name: &string
    hash: uint64
    node: &parser::Node
    state: &typechecking::State
    ftpe: &typechecking::Type
    imported: bool
    polymorph: bool
    impl: bool
}

type VariableEntry = struct {
    name: &string
    hash: uint64
    modifier: parser::VarDecl
    extern: bool
    dllimport: bool
    dllexport: bool
    tpe: &typechecking::Type
    value: &compiler::Value
}

type TypeEntry = struct {
    name: &string
    share: parser::ShareMarker
    hash: uint64
    tpe: &typechecking::Type
}

export type Deserialize = struct {
    module: weak_ref(toolchain::Module)
    types: &Vector(&typechecking::Type)
    nodes: &Vector(&parser::Node) // Strong references to nodes
    scopes: &Vector(&scope::Scope) // Strong references to enum scopes
    dependencies: &[scope::Ident]
    functions: &Vector(FunctionEntry) // Things get written before the type information so we must delay processing
    variables: &Vector(VariableEntry)
    rtypes: &Vector(TypeEntry)
}

export def resolver_pass(module: &toolchain::Module) {
    if toolchain::no_incremental { return }
    if module.stage !int >= toolchain::Stage::READ_CACHE { return }
    let cache_file = toolchain::outfolder + "/" + module.file + ".prc"

    if not util::exists(toolchain::outfolder + "/" + module.file + ".o") {
        module.is_dirty = true
    }

    debug::trace("Deserializing module ", module.module)

    let deserialize = {
        module = module,
        types = vector::make(type &typechecking::Type),
        nodes = vector::make(type &parser::Node),
        scopes = vector::make(type &scope::Scope),
        functions = vector::make(FunctionEntry),
        variables = vector::make(VariableEntry),
        rtypes = vector::make(TypeEntry)
    } !&Deserialize

    module.deserialize = deserialize

    let fp = open(@cache_file, "rb")
    if not fp { module.is_dirty = true; return }
    defer close(fp)

    let source_fp = open(@module.filename, "rb")
    defer close(source_fp)

    if modified_time(source_fp) > modified_time(fp) {
        module.is_dirty = true
    }
    
    var magic: [8; char] // TODO use MAGIC.size here
    fp.read(magic)
    if magic != MAGIC { module.is_dirty = true; return }

    var size: size_t
    fp.read(*size)
    for var i in 0..size {
        let ident = parser::identifier_from_str(fp.read_str())
        let modulename = fp.read_str()
        let filename = fp.read_str()

        let imprt = toolchain::create_module_if_absent(filename, modulename)
        scope::insert_module(module.scope, ident, imprt)
    }

    fp.read(*size)
    for var i in 0..size {
        let mod = toolchain::find_module(fp.read_str())
        let name = fp.read_str()
        let ident = parser::make_identifier(name)
        var types_size: uint64
        fp.read(*types_size)
        if types_size > 0 {
            ident.value.identifier.types = vector::make(typechecking::NamedParameter)
        }
        for var j in 0..types_size {
            let tpe = deserialize_type(deserialize, fp)
            ident.value.identifier.types.push({
                _tpe = tpe
            } !typechecking::NamedParameter)
        }
        scope::insert_re_export(module.scope, ident, mod)
    }
    
    fp.read(*size)
    for var i in 0..size {
        deserialize_function(deserialize, fp)
    }

    fp.read(*size)
    for var i in 0..size {
        deserialize_variable(deserialize, fp)
    }

    fp.read(*size)
    for var i in 0..size {
        let name = fp.read_str()
        var share: byte
        fp.read(*share)
        var hash: uint64
        fp.read(*hash)
        let tpe = deserialize_type(deserialize, fp)

        deserialize.rtypes.push({
            name = name,
            share = share !parser::ShareMarker,
            hash = hash,
            tpe = tpe
        } !TypeEntry)
    }

    fp.read(*size)
    for var i in 0..size {
        if i >= deserialize.types.length {
            deserialize.types.resize(i + 1)
        }

        var tpe = deserialize.types[i]
        if not tpe {
            tpe = { kind = typechecking::TypeKind::STUB, is_in_type_cache = true } !&typechecking::Type
        }

        deserialize.types[i] = tpe
        deserialize.types[i] = deserialize_type(deserialize, fp, tpe)
    }

    for var i in 0..deserialize.rtypes.length {
        let entry = deserialize.rtypes[i]
        let name_node = parser::make_identifier(entry.name)
        name_node.loc.module = module.module
        let val = scope::create_type(
            deserialize.module.scope, name_node, entry.share, 
            entry.tpe, scope::Phase::COMPILED, null, null
        )
        val.ident = scope::make_ident(entry.name, module, entry.hash)
        val.identifier = name_node
    }

    for var i in 0..deserialize.functions.length {
        let entry = deserialize.functions[i]
        let name_node = parser::make_identifier(entry.name)
        name_node.loc.module = module.module
        let value = scope::create_function(
            module.scope, name_node, parser::ShareMarker::EXPORT, 
            entry.ftpe, scope::Phase::COMPILED, entry.node, entry.state, entry.impl
        )
        value.imported = entry.imported
        value.polymorph = entry.polymorph
        value.ident = scope::make_ident(entry.name, module, entry.hash, entry.ftpe.type_name)
        value.identifier = name_node
    }

    for var i in 0..deserialize.variables.length {
        let entry = deserialize.variables[i]
        let id = parser::make_identifier(entry.name)
        id.loc.module = module.module
        let val = scope::create_variable(
            module.scope, id, parser::ShareMarker::EXPORT, 
            entry.modifier, entry.tpe, 
            entry.extern, entry.dllimport, entry.dllexport, entry.value, 
            scope::Phase::COMPILED, null, null
        )
        val.identifier = id
    }

    fp.read(*size)
    deserialize.dependencies = allocate_ref(scope::Ident, size)
    for var i in 0..size {
        var hash: uint64
        fp.read(*hash)
        let name = fp.read_str()
        let signature = fp.read_str()
        let module = fp.read_str()
        deserialize.dependencies[i] = scope::make_ident(name, toolchain::find_module(module), hash, signature)
    }
}

export def dependency_pass(module: &toolchain::Module) {
    if module.stage !int >= toolchain::Stage::RESOLVE_DEPENDENCIES !int { return } 
    module.stage = toolchain::Stage::RESOLVE_DEPENDENCIES
    
    if module.node {
        let node = module.node
        assert node.kind == parser::NodeKind::PROGRAM
        for var i in 0..node.body.length {
            let n = node.body[i]
            if not n or n.kind != parser::NodeKind::IMPORT { continue }
            // IMPORT
            let imports = n.value.body
            for var i in 0..vector::length(imports) {
                let imprt = imports[i]
                var name = (@imprt).value.import_module.name
                if not name { continue }
                toolchain::resolve_dependencies(name, module)
            }
        }
        return
    }

    let deserialize = module.deserialize

    let imports = module.scope.imports
    if imports {
        for var i in 0..imports.length {
            let imprt = imports[i]
            dependency_pass(imprt.module)
        }
    }

    // Check if any of the dependencies are out of date
    for var i in 0..deserialize.dependencies.size {
        let dep = deserialize.dependencies[i]
        if dep.name == "__destruct__" { continue } // TODO These need to be serialized as well
        let value = scope::find(dep)
        if not value or value.ident._hash != dep._hash {
            print(dep.module.module, "\n")
            print(dep, " ", value !*, "\n")
            module.is_dirty = true
            break
        }
    }

    if module.is_dirty and module.stage !int < toolchain::Stage::TYPECHECKING !int {
        toolchain::reset_and_consteval(module)
    }
}

export def generate_ctor_and_dtor(module: &toolchain::Module) {
    if not module.deserialize { return }
    debug::trace("Generating type metadata for " + module.module + " (" + module.deserialize.types.length + ")")
    def create_type(tpe: &typechecking::Type) {
        if not tpe { return }
        if typechecking::is_polymorph(tpe) or 
        tpe.kind == typechecking::TypeKind::TYPE_CONSTRUCTOR { return }

        // TODO These functions are weird, we want to generate both
        typechecking::get_builtin_destructor(tpe)
        typechecking::has_copy_constructor(tpe)
        compiler::create_type(tpe, module)
    }

    for var i in 0..module.deserialize.types.length {
        let tpe = module.deserialize.types[i]
        create_type(tpe)
    }
}