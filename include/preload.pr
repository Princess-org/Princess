import map
import ffi
import std
import cstd
import vector
import symbol

#if defined WIN32 {
    import windows
} else {
    import linux
}

const RTLD_LAZY = 1

export type DLL = struct {
    handle: *
}

export def destruct(dll: *DLL) {
    #if defined WIN32 {
        windows::FreeLibrary(dll.handle !*windows::s_HINSTANCE__)
    } else {
        linux::dlclose(dll.handle)
    }
}

export let symbols = map::make(type &symbol::Symbol)
export let dlls = map::make(DLL)

export def load_ffi(syms: [symbol::Symbol]) {
    for var i in 0..syms.size {
        let sym = syms[i]
        symbols[sym.name] = sym
    }
}

export def load_library(name: string) {
    if dlls.contains(name) { return }
    #if defined WIN32 {
        dlls[name] = { windows::LoadLibraryA(name.value) !* } !DLL
    } else {
        dlls[name] = { linux::dlopen(name.value, RTLD_LAZY) } !DLL
    }
}

export def get_function(sym: &symbol::Symbol) -> () -> () {
    assert sym.kind == symbol::SymbolKind::FUNCTION
    let name = sym.name
    if sym.function { return sym.function }
    if sym.dllimport {
        let keys = dlls.keys
        for var i in 0..keys.size {
            let dll = dlls[keys[i]]
            var proc: *
            #if defined WIN32 {
                proc = windows::GetProcAddress(dll.handle !*windows::s_HINSTANCE__, name.value)
            } else {
                proc = linux::dlsym(dll.handle, name.value)
            }
            if proc {
                sym.function = proc !() -> ()
                break
            }
        }
    }
    return sym.function
}

import cstd_sym
load_ffi(cstd_sym::__SYMBOLS)
import ffi_sym
load_ffi(ffi_sym::__SYMBOLS)

#if defined WIN32 {
    import windows_sym
    load_ffi(windows_sym::__SYMBOLS)
    load_library("Kernel32.dll")
    load_library("User32.dll")
} else {
    import linux_sym
    load_ffi(linux_sym::__SYMBOLS)
}