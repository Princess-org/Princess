import bfd
import libdwarf
import map
import vector
import linux

import attributes

const DW_AT_low_pc: ushort = 0x11
const DW_AT_high_pc: ushort = 0x12

const DW_DLA_STRING = 0x01
const DW_DLA_DIE = 0x08
const DW_DLA_LIST = 0x0f
const DW_DLA_ATTR = 0x0a

const DW_DLV_NO_ENTRY = -1

const DW_TAG_compile_unit = 0x11

export type DIE = struct {
    obj: weak_ref(Object) // Owner
    offset: size_t
    tag: ushort

    child: &DIE
    parent: weak_ref(DIE)
    right: &DIE
    left: weak_ref(DIE)

    attributes: &Vector(&Attr)
    die: *s_Dwarf_P_Die_s
}

type Section = struct {
    offsets: &Map(&Section, size_t)
    section: *s_bfd_section
    name: &string
    size: size_t // Size of the entire section
    data: *
    relocations: Relocations
}

type DebugSection = struct {
    section: *s_bfd_section
    name: Str
    index: int
    size: size_t
    data: *
    relocations: Relocations
    last_size: size_t
}

type Relocations = struct {
    count: size_t
    reloc: **s_reloc_cache_entry
    // TODO It would take less memory to have some sort of range based data structure
    // Because all we do here is add the same object to it in a loop
    origin: &Vector(&Object)
}

export def hash(sec: &Section) -> uint64 {
    return sec !*uint64 !uint64
}

export type Object = struct {
    bfd: *s_bfd
    sections: &SMap(&Section)
    symtab: **s_bfd_symbol
    symbols: &Vector(&Symbol)
    sym_size: size_t

    // DWARF
    dbg: *s_Dwarf_Debug_s
    pdbg: *s_Dwarf_P_Debug_s
    dies: &Vector(&DIE)
    all_dies: &Vector(weak_ref(DIE))

    section_index: int
    debug_sections: &Vector(&DebugSection)
    reference_markers: &Vector(ReferenceMarker)
}

export type ReferenceMarker = struct {
    die: &DIE
    attr: ushort
    addr: uint64
}

export def add_reference_marker(o: &Object, die: &DIE, attr: ushort, addr: uint64) {
    //print("Inserting marker for die ", die.die !*, "\n")
    o.reference_markers.push({die, attr, addr} !ReferenceMarker)
}

def find_symbol(o: &Object, name: Str) -> &Symbol {
    for var sym in o.symbols {
        if sym.name == name { return sym }
    }
    return null
}

def find_symbol(o: &Object, origin: &Object, section: &Section, reloc: *s_reloc_cache_entry) -> &Symbol {
    let addr = reloc.address !int64
    for var sym in o.symbols {
        let loc = sym.location !int64
        if sym.origin == origin and sym.section == section {
            if addr >= loc and addr < loc + sym.size {
                return sym
            }
        }
    }
    return null
}

export def delete_symbol(o: &Object, name: Str) {
    for var i in 0..o.symbols.length {
        let sym = o.symbols[i]
        if sym.name == name {
            o.symbols.remove(i)
            return
        }
    }
}

export def open_object_read(file: Str) -> &Object {
    let path = file.to_array()
    let abfd = bfd_openr(path.value, null)
    bfd_check_format(abfd, e_bfd_format::bfd_object)

    let obj = { 
        abfd, 
        sections = map::make(type &Section), 
        symbols = vector::make(type &Symbol), 
        dies = vector::make(type &DIE),
        all_dies = vector::make(type weak_ref(DIE))
    } !&Object

    var error: *s_Dwarf_Error_s
    if dwarf_init_path(path.value, null, 0, 0, null, null, *obj.dbg, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }

    return obj
}

def bfd_write_callback(
    name: *char, size: int, tpe: uint64, 
    flags: uint64, link: uint64, info: uint64, 
    sect_name_index: *uint64, user_data: *, errorcode: *int) -> int {

    let namep = make_string(name)

    let obj = user_data !*Object
    
    var has_created_section = false
    for var section in obj.debug_sections { // Check if we already made this section during a previous pass
        if section.name == namep {
            has_created_section = true
            break
        }
    }

    if tpe != 9 { // 9 is for the rel section but don't ask me why
        @sect_name_index = obj.sym_size
        if not has_created_section  {
            let section = bfd_make_section(obj.bfd, name)

            obj.symtab = reallocate(obj.symtab, (obj.sym_size + 1) * size_of *s_bfd_symbol)
            let symbol = obj.bfd.xvec._bfd_make_empty_symbol(obj.bfd)
            symbol.section = section
            symbol.flags = 0x1 /* BSF_LOCAL */ | 0x100 /* BSF_SECTION_SYM */

            obj.symtab[obj.sym_size] = symbol

            obj.symbols.push({ null, make_string(name), symbol, null, 0, 0, 0, obj.sym_size } !&Symbol)

            obj.debug_sections.push({
                section = section,
                name = namep,
                index = obj.section_index
            } !&DebugSection)
        }

        obj.sym_size += 1
    }

    
    obj.section_index += 1
    return obj.section_index - 1
}

export def open_object_write(file: Str) -> &Object {
    let path = file.to_array()
    let abfd = bfd_openw(path.value, null)
    bfd_set_format(abfd, e_bfd_format::bfd_object)

    let obj = { abfd, 
        sections = map::make(type &Section), 
        symbols = vector::make(type &Symbol), 
        debug_sections = vector::make(type &DebugSection), 
        dies = vector::make(type &DIE),
        all_dies = vector::make(type weak_ref(DIE)),
        reference_markers = vector::make(ReferenceMarker)
    } !&Object

    return obj
}

export def copy_arch_mach(to: &Object, frm: &Object) {
    to.bfd.xvec._bfd_set_arch_mach(to.bfd, bfd_get_arch(frm.bfd), bfd_get_mach(frm.bfd))
}

export def delete(obj: &Object) {
    bfd_close(obj.bfd)

    if obj.dbg {
        dwarf_finish(obj.dbg)
    }

    free(obj.symtab)
    for var name in @obj.sections.keys() {
        let section = obj.sections[name]
        free(section.data)
        free(section.relocations.reloc)
    }
}

export def copy_debug_info(res: &Object, frm: &Object) {
    var error: *s_Dwarf_Error_s
    // TODO actually merge something here
    res.dies.add_all(frm.dies)
    res.all_dies.add_all(frm.all_dies)
}

def write_debug_info(o: &Object, die: &DIE, parent: *s_Dwarf_P_Die_s = null, left: *s_Dwarf_P_Die_s = null, no_sibling: bool = false) -> *s_Dwarf_P_Die_s {

    var error: *s_Dwarf_Error_s

    var res: *s_Dwarf_P_Die_s
    //print("Creating die ", die.tag, "\n")
    if dwarf_new_die_a(o.pdbg, die.tag, parent, null, left, null, *res, *error) == DW_DLV_ERROR {
        dwarf_error(error)
    }
    die.die = res

    // Attributes
    for var attr in die.attributes {
        var dwattr: *s_Dwarf_Attribute_s
        //print("Writing attribute ", ref_type(attr).tpe.name, "\n")
        if attr.write(o, die, *dwattr, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }
    }
    
    if die.child {
        var child = write_debug_info(o, die.child, res, null)
    }

    if no_sibling { return res }
    	
    die = die.right
    var dwdie = res
    while die != null {
        var sibling = write_debug_info(o, die, null, dwdie, no_sibling = true)

        die = die.right
        dwdie = sibling
    }

    return res
}

export def write_debug_info(res: &Object) {
    // Test debug info
    var error: *s_Dwarf_Error_s
    var abbrev_offset = 0
    var sym_size = res.sym_size
    for var die in res.dies {
        res.sym_size = sym_size
        res.section_index = 0

        if dwarf_producer_init(
            1 /* DW_DLC_WRITE */ | /*symbolic relocations*/ 0x04000000 | /*little endian*/ 0x00100000 | /* 64 bit pointers */ 0x40000000,
            *bfd_write_callback, null, null, res !*, "x86_64".value, "V4".value, null, *res.pdbg, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }

        if dwarf_pro_set_default_string_form(res.pdbg, /* DW_FORM_strp */0x0e, *error) { dwarf_error(error) }

        let ndwdie = write_debug_info(res, die)
        if dwarf_add_die_to_debug_a(res.pdbg, ndwdie, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }

        // Fixup references
        for var ref in res.reference_markers {
            var found = false
            if ref.die.obj == die.obj {
                for var die2 in die.obj.all_dies {
                    if die2.offset == ref.addr {
                        if dwarf_fixup_AT_reference_die(res.pdbg, ref.attr, ref.die.die, die2.die, *error) == DW_DLV_ERROR {
                            dwarf_error(error)
                        }
                        found = true
                        break
                    }
                }
            }
        }

        var nbufs: uint64
        if dwarf_transform_to_disk_form_a(res.pdbg, *nbufs, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }

        for var i in 0..nbufs {
            let section = res.debug_sections[i]
            var section_index: uint64
            var new_section_size: uint64
            var data: *

            var error: *s_Dwarf_Error_s
            if dwarf_get_section_bytes_a(res.pdbg, i, *section_index, *new_section_size, *data, *error) == DW_DLV_ERROR {
                dwarf_error(error)
            }

            if section.name == ".debug_info" {
                var abbr_offset = ((data !*uint8) ++ 6) !*uint32
                @abbr_offset = abbrev_offset
            } else if section.name == ".debug_abbrev" {
                abbrev_offset += new_section_size
            } else if section.name == ".debug_str" {
                section.size = 0 // Apparently we write the same data multiple times, there seems to be some data still in the buffer
            }

            section.last_size = section.size
            
            section.data = reallocate(section.data !*uint8, section.size + new_section_size) !*
            memcopy(data, section.data ++ section.size, new_section_size)

            section.size += new_section_size
            print("Section ", section.name, " new size ", section.size, "\n")

            bfd_set_section_size(section.section, section.size)
            bfd_set_section_flags(section.section, section.section.flags | 0x8 /*SEC_READONLY*/ | 0x100 /*SEC_CONTENTS*/ )
        }

        var nrelocs: uint64
        var drd_version: int
        if dwarf_get_relocation_info_count(res.pdbg, *nrelocs, *drd_version, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }

        for var i in 0..nrelocs {
            var elf_section_index: uint64
            var elf_section_index_link: uint64
            var relocation_buffer_count: uint64
            var reld: *s_Dwarf_Relocation_Data_s


            if dwarf_get_relocation_info(res.pdbg,
                *elf_section_index,
                *elf_section_index_link,
                *relocation_buffer_count,
                *reld, *error) == DW_DLV_ERROR {

                dwarf_error(error)
            }

            let sec = res.debug_sections[elf_section_index_link]

            sec.relocations.reloc = reallocate(sec.relocations.reloc, (sec.relocations.count + relocation_buffer_count) * size_of *s_reloc_cache_entry) !**s_reloc_cache_entry

            for var j in 0..relocation_buffer_count {
                let relent = zero_allocate(s_reloc_cache_entry)
                
                relent.sym_ptr_ptr = *res.symbols[reld[j].drd_symbol_index].symbol
                relent.address = reld[j].drd_offset + sec.last_size
                relent.addend = @((sec.data !*uint8 ++ relent.address) !*int32)
                relent.howto = bfd_reloc_type_lookup(res.bfd, e_bfd_reloc_code_real::BFD_RELOC_32 if reld.drd_length == 4 else e_bfd_reloc_code_real::BFD_RELOC_64)
                print(sec.name, " ", relent.address, "\n")
                sec.relocations.reloc[sec.relocations.count + j] = relent
            }
            
            sec.relocations.count += relocation_buffer_count
            bfd_set_section_flags(sec.section, sec.section.flags | 0x4 /* SEC_RELOC */)
            res.bfd.xvec._bfd_set_reloc(res.bfd, sec.section, sec.relocations.reloc, sec.relocations.count !uint)
        }

        if dwarf_producer_finish_a(res.pdbg, *error) == DW_DLV_ERROR {
            dwarf_error(error)
        }
        
        dwarf_reset_section_bytes(res.pdbg)
    }
}

export def write_debug_sections(res: &Object) {
    for var i in 0..res.debug_sections.length {
        let section = res.debug_sections[i]

        print("Writing section ", section.name, " with size ", section.size, "\n")
        bfd_set_section_contents(res.bfd, section.section, section.data, 0, section.size)
    }
}

type Symbol = struct {
    origin: &Object
    name: Str
    symbol: *s_bfd_symbol
    section: &Section
    size: size_t
    offset: int64 // Offset based on deleted sections
    location: size_t // Original location based on the offset within a file
    index: size_t
}

def bfd_asymbol_value(sy: *s_bfd_symbol) -> size_t {
    return sy.section.vma + sy.value
}

export def initialize_section(res: &Object, name: Str) {
    let sec = bfd_get_section_by_name(res.bfd, name.to_array().value)
    if not sec { return }
    res.sections[name] = { section = sec, name = name.to_array(), offsets = map::make(type &Section, size_t), size = sec.size} !&Section
}

export def load_section_data(obj: &Object, name: Str) {
    if not obj.sections.contains(name) { return }
    let section = obj.sections[name]
    var data = allocate(section.section.size)
    bfd_get_section_contents(obj.bfd, section.section, data, 0, section.section.size)
    section.data = data
}

export def merge_section(res: &Object, obj_a: &Object, name: Str) {
    if not obj_a.sections.contains(name) { return }
    let a_sec = obj_a.sections[name]

    if res.sections.contains(name) {
        return
    }

    let section_name = name.to_array()
    let new_sec = bfd_make_section(res.bfd, section_name.value)
    bfd_set_section_flags(new_sec, a_sec.section.flags)
    bfd_set_section_size(new_sec, a_sec.section.size)
    new_sec.alignment_power = a_sec.section.alignment_power

    let section = { section = new_sec, name = section_name, offsets = map::make(type &Section, size_t), size = 0 } !&Section
    section.relocations.origin = vector::make(type &Object)
    res.sections[name] = section
}

export def merge_section_data(res: &Object, obj_a: &Object, name: Str) {
    if not obj_a.sections.contains(name) { return }

    merge_section(res, obj_a, name)

    let a_sec = obj_a.sections[name]
    let new_sec = res.sections[name]

    let sz = a_sec.section.size
    
    var offset: size_t = new_sec.size
    var data = reallocate(new_sec.data !*char, offset + sz)

    // Initialize relocations
    let rel_sz = bfd_get_reloc_upper_bound(obj_a.bfd, a_sec.section)
    if rel_sz > 0 {
        let relent = allocate(rel_sz) !**s_reloc_cache_entry
        let count = bfd_canonicalize_reloc(obj_a.bfd, a_sec.section, relent, obj_a.symtab)

        if count > 0 {
            let new_sz = (count + new_sec.relocations.count) * size_of *s_reloc_cache_entry
            let out = reallocate(new_sec.relocations.reloc, new_sz)
            memcopy(relent, out ++ new_sec.relocations.count, count * size_of *s_reloc_cache_entry)

            new_sec.relocations.reloc = out
            new_sec.relocations.count += count

            for var i in 0..count {
                let rel = relent[i]
                let sym_name = make_string((@rel.sym_ptr_ptr).name)
                let sym = find_symbol(obj_a, sym_name)
                rel.address += offset
            }
              
            for var i in 0..count {
                new_sec.relocations.origin.push(obj_a)
            }
        }

        free(relent)
    }

    memcopy(a_sec.data, data ++ offset, a_sec.section.size)
    new_sec.offsets[a_sec] = offset

    new_sec.data = data
    new_sec.size += sz

    bfd_set_section_size(new_sec.section, new_sec.size)
}

export def write_section_data(res: &Object, name: Str) {
    if not res.sections.contains(name) { return }
    let sec = res.sections[name]
    bfd_set_section_contents(res.bfd, sec.section, sec.data, 0, sec.size)

    // Write relocations
    let count = sec.relocations.count
    let relent = sec.relocations.reloc
    if count > 0 {
        for var i in 0..count {
            let rel = relent[i]
            let sym_name = make_string((@rel.sym_ptr_ptr).name)
            let sym = find_symbol(res, sec.relocations.origin[i], sec, rel)
            rel.sym_ptr_ptr = *find_symbol(res, sym_name).symbol

            if sym {
                rel.address += sym.offset
            }
        }
        res.bfd.xvec._bfd_set_reloc(res.bfd, sec.section, relent, count !uint)
    }
}

export def load_symbols(res: &Object) {
    let a_sz = res.bfd.xvec._bfd_get_symtab_upper_bound(res.bfd)
    let syms = allocate(a_sz) !**s_bfd_symbol
    let cnta = res.bfd.xvec._bfd_canonicalize_symtab(res.bfd, syms)
    
    res.symtab = syms

    // TODO This relies on symbols being ordered
    var i = 0
    while i < cnta {
        var sym = syms[i]
        let sec_name = make_string(sym.section.name)
        let sym_name = make_string(sym.name)

        var section: &Section
        if not is_abs_section(sym.section) and res.sections.contains(sec_name) {
            section = res.sections[sec_name]
        }

        var offset: size_t = bfd_asymbol_value(sym) 
        var size: size_t = 0

        if section and sec_name != sym_name {
            if i + 1 < cnta {
                let next_sym = syms[i + 1]
                if make_string(next_sym.section.name) != sec_name {
                    size = section.size - offset
                } else {
                    size = bfd_asymbol_value(next_sym) - offset
                }
            } else {
                size = section.size - offset
            }
        }
        
        let out_sym = { res, sym_name, sym, section, size, index = res.symbols.length } !&Symbol
        res.symbols.push(out_sym)
        res.sym_size += 1
        i += 1
    }
}

// returns the difference in size when a symbol is deleted
export def remove_symbol(res: &Object, name: Str) -> int {
    if find_symbol(res, name) == null { return 0 }
    let sym = find_symbol(res, name)
    let sec = sym.section

    delete_symbol(res, name)
    
    var size_diff = 0
    if sec { 
        // Purge the symbol from the section
        let data = allocate(sec.size - sym.size)
        memcopy(sec.data, data, sym.symbol.value)
        memcopy(sec.data ++ sym.symbol.value ++ sym.size, data ++ sym.symbol.value, sec.size - sym.symbol.value - sym.size)
        free(sec.data)
        sec.data = data

        // Actually shrink the section
        sec.size -= sym.size
        size_diff -= sym.size
    }

    var i = 0
    while i < res.sym_size {
        if make_string(res.symtab[i].name) == name {
            break
        }
        i += 1
    }

    let symtab = allocate(size_of **s_bfd_symbol * (res.sym_size - 1)) !**s_bfd_symbol
    memcopy(res.symtab, symtab, i * size_of **s_bfd_symbol)
    if res.sym_size - i > 0 {
        memcopy(res.symtab ++ i ++ 1, symtab ++ i, (res.sym_size - i - 1) * size_of **s_bfd_symbol) 
    }

    free(res.symtab)

    res.symtab = symtab
    res.sym_size -= 1

    if sec {
        for var sym2 in res.symbols {
            // Offset symbols
            if sym.section and sym2.symbol.value > sym.symbol.value and sym.section == sym2.section {
                sym2.symbol.value -= sym.size
                sym2.offset -= sym.size
            }
        }
    }

    return size_diff
}

// TODO There are in fact ways to do this without a string compare but it doesn't seem to work
def #inline is_und_section(section: *s_bfd_section) -> bool {
    return cstd::strcmp(section.name, "*UND*".value) == 0
}

def #inline is_abs_section(section: *s_bfd_section) -> bool {
    return cstd::strcmp(section.name, "*ABS*".value) == 0
}

type DuplicateEntry = struct {
    symbol: &Symbol
    from_section: &Section
}

export def copy_symbols(to: &Object, frm: &Object) {
    to.symtab = reallocate(to.symtab, size_of *s_bfd_symbol * (frm.sym_size + to.sym_size)) !**s_bfd_symbol

    let duplicates = map::make(DuplicateEntry)
    
    var i = to.sym_size
    for var sym in frm.symbols {
        let name = sym.name
        let new_sym = to.bfd.xvec._bfd_make_empty_symbol(to.bfd)
        let section = frm.sections[sym.section.name] if sym.section else null
        let to_section = to.sections[sym.section.name] if sym.section else null

        var offset: int64 = 0
        if to_section and to_section.offsets.contains(section) {
            offset = to_section.offsets[section]
        }

        new_sym.name = sym.symbol.name
        if to_section {
            new_sym.section = to_section.section
        } else {
            new_sym.section = sym.symbol.section
        }
        new_sym.flags = sym.symbol.flags
        new_sym.value = sym.symbol.value + offset

        to.symtab[i] = new_sym
        let symbol = { frm, name, new_sym, to_section, sym.size, offset, sym.symbol.value } !&Symbol

        if not is_und_section(sym.symbol.section) {
            if find_symbol(to, name) != null {
                if name.starts_with(".") { continue }
                
                duplicates[name] = { symbol, section } !DuplicateEntry
                new_sym.value = sym.symbol.value
            } else {
                symbol.index = to.symbols.length
                to.symbols.push(symbol)
                to.sym_size += 1
                i += 1
            }
        }
    }

    var size_diff = 0
    for var name in @duplicates.keys() {
        size_diff += remove_symbol(to, name)
    }

    to.symtab = reallocate(to.symtab, size_of *s_bfd_symbol * (to.sym_size + duplicates.size)) !**s_bfd_symbol

    for var name in @duplicates.keys() {
        let entry = duplicates[name]
        let sym = entry.symbol
        
        if entry.symbol.section {
            sym.symbol.value += entry.symbol.section.offsets[entry.from_section]
        }

        sym.symbol.value = sym.symbol.value !int + size_diff
        sym.offset += size_diff

        sym.index = to.symbols.length
        to.symbols.push(sym)
        to.symtab[to.sym_size] = sym.symbol
        to.sym_size += 1
    }

    // DWARF
    read_dwarf_symbols(frm)
}

def dwarf_die_handler(obj: &Object, die: *s_Dwarf_Die_s, my_die: &DIE) {
    
    var error: *s_Dwarf_Error_s
    var atlist: **s_Dwarf_Attribute_s
    var atcount: int64
    var res: int

    res = dwarf_attrlist(die, *atlist, *atcount, *error)
    if res != DW_DLV_OK {
        dwarf_error(error)
    }

    for var i in 0..atcount {
        var attrnum: ushort
        var attrname: *char 

        res = dwarf_whatattr(atlist[i], *attrnum, *error)
        if res != DW_DLV_OK {
            dwarf_error(error)
        }
        let attr = parse(obj, die, atlist[i], *error)
        if attr { my_die.attributes.push(attr) }

        dwarf_dealloc(obj.dbg, atlist[i], DW_DLA_ATTR)
    }

    dwarf_dealloc(obj.dbg, atlist, DW_DLA_LIST)
}

export def dwarf_error(err: *s_Dwarf_Error_s) {
    error(dwarf_errno(err), "\n")
    abort()
}

def read_dwarf_die(obj: &Object, in_die: *s_Dwarf_Die_s, is_info: int, in_level: int, parent: &DIE) -> &DIE {

    var error: *s_Dwarf_Error_s
    var res = DW_DLV_OK
    var cur_die = in_die
    var child: *s_Dwarf_Die_s

    var tag: ushort
    var dieoff: uint64
    if dwarf_dieoffset(cur_die, *dieoff, *error) == DW_DLV_ERROR { dwarf_error(error) }
    if dwarf_tag(cur_die, *tag, *error) == DW_DLV_ERROR { dwarf_error(error) }
    let first_die = { obj = obj, offset = dieoff, tag = tag, parent = parent, attributes = vector::make(type &Attr) } !&DIE
    obj.all_dies.push(first_die)

    var res_die = first_die

    dwarf_die_handler(obj, in_die, first_die)

    loop {
        var sib_die: *s_Dwarf_Die_s
        res = dwarf_child(cur_die, *child, *error)
        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_OK {
            let child_die = read_dwarf_die(obj, child, is_info, in_level + 1, first_die)
            res_die.child = child_die

            dwarf_dealloc(obj.dbg, child, DW_DLA_DIE)
            child = null
        }
        res = dwarf_siblingof_b(obj.dbg, cur_die, is_info, *sib_die, *error)
        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_NO_ENTRY { break }

        if cur_die != in_die {
            dwarf_dealloc(obj.dbg, cur_die, DW_DLA_DIE)
            cur_die = null
        }

        cur_die = sib_die
        var tag: ushort
        var dieoff: uint64
        if dwarf_dieoffset(cur_die, *dieoff, *error) == DW_DLV_ERROR { dwarf_error(error) }
        if dwarf_tag(sib_die, *tag, *error) == DW_DLV_ERROR { dwarf_error(error) }
        let new_die = { obj = obj, offset = dieoff, tag = tag, parent = first_die, attributes = vector::make(type &Attr) } !&DIE
        obj.all_dies.push(new_die)

        new_die.left = res_die
        res_die.right = new_die
        res_die = new_die

        dwarf_die_handler(obj, sib_die, res_die)
    }

    return first_die
}

export def read_dwarf_symbols(o: &Object) {

    var error: *s_Dwarf_Error_s

    var abbrev_offset: uint64
    var address_size: ushort
    var version_stamp: ushort
    var offset_size: ushort
    var extension_size: ushort
    var signature: s_Dwarf_Sig8_s
    var typeoffset: uint64
    var next_cu_hader: uint64
    var header_cu_type: ushort

    var is_info: int = 1
    var res = 0

    loop {
        var no_die: *s_Dwarf_Die_s
        var cu_die: *s_Dwarf_Die_s
        var cu_header_length: uint64

        res = dwarf_next_cu_header_d(o.dbg, is_info, *cu_header_length,
            *version_stamp, *abbrev_offset,
            *address_size, *offset_size,
            *extension_size, *signature,
            *typeoffset, *next_cu_hader,
            *header_cu_type, *error)
        
        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_NO_ENTRY {
            if is_info { 
                is_info = 0
                continue
            }
            else { return }
        }
        res = dwarf_siblingof_b(o.dbg, no_die, is_info, *cu_die, *error)

        if res == DW_DLV_ERROR { dwarf_error(error) }
        if res == DW_DLV_NO_ENTRY { dwarf_error(error) }
        
        o.dies.push(read_dwarf_die(o, cu_die, is_info, 0, null))
    }
}

export def write_symbols(res: &Object) {
    bfd_set_symtab(res.bfd, res.symtab, res.sym_size !uint)
}
