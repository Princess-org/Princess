import cstd
import std
import vector
import strings

export type ByteStream = struct {
    _data: &Vector(byte)
}

export def make_stream -> &ByteStream {
    return [ _data = vector::make(byte) ] !ByteStream
}

export def write(this: &ByteStream, data: type T) {
    this._data.extend(T.size)
    std::memcopy(*data, this._data.data.value ++ this._data.length, T.size)
    this._data.length += T.size
}

export def write_zt(this: &ByteStream, s: Str) -> size_t {
    let offset = this._data.length
    this._data.extend(s.length + 1)
    std::memcopy(get_internal_buffer(*s), this._data.data.value ++ offset, s.length)
    this._data.data(this._data.length + s.length) = 0
    this._data.length += s.length + 1
    return offset
}

export def data(this: &ByteStream) -> [byte] {
    let data = this._data.data
    data.size = this._data.length
    return data
}

var stderr_orig_fd = -1
export var stderr_orig: File
var stderr_fh: File
var stdout_orig_fd = -1
export var stdout_orig: File
var stdout_fh: File

export const NO_BLOCKING = 1

#if defined WIN32 {
    import windows

    const _O_BINARY = 0x8000

    export def redirect_stderr_to_file(file: String) {
        if stderr_orig_fd < 0 {
            stderr_orig_fd = cstd::_dup(2)
            stderr_orig = cstd::_fdopen(stderr_orig_fd, "w".value)
        }
        stderr_fh = open(file, "wb")
        cstd::_dup2(cstd::_fileno(stderr_fh), 2)
        cstd::_setmode(2, _O_BINARY)
    }

    export def redirect_stdout_to_file(file: String) {
        if stdout_orig_fd < 0 {
            stdout_orig_fd = cstd::_dup(1)
            stdout_orig = cstd::_fdopen(stdout_orig_fd, "w".value)
        }
        stdout_fh = open(file, "wb")
        cstd::_dup2(cstd::_fileno(stdout_fh), 1)
        cstd::_setmode(1, _O_BINARY)
    }

    export def restore_stderr {
        cstd::_dup2(stderr_orig_fd, 2)
        close(stderr_fh)
    }

    export def restore_stdout {
        cstd::_dup2(stdout_orig_fd, 1)
        close(stdout_fh)
    }

    export def pipe(mode: int = 0) -> File, File {
        var read: *
        var write: *

        windows::CreatePipe(*read, *write, null, 0)

        return cstd::fdopen(cstd::_open_osfhandle(read !int64, 0), "r".value) !File, 
            cstd::fdopen(cstd::_open_osfhandle(write !int64, 0), "w".value) !File
    }

    export def is_a_tty(file: File) -> bool {
        return cstd::_isatty(cstd::_fileno(file)) != 0
    }

    export def open_memory_as_file(arr: [uint8]) -> File {
        // TODO implement, see https://github.com/Arryboom/fmemopen_windows
        return null
    }

} else {
    import linux 

    export def redirect_stderr_to_file(file: String) {
        if stderr_orig_fd < 0 {
            stderr_orig_fd = linux::dup(2)
            stderr_orig = cstd::fdopen(stderr_orig_fd, "w".value)
        }
        stderr_fh = open(file, "w")
        linux::dup2(cstd::fileno(stderr_fh), 2)
    }

    export def redirect_stdout_to_file(file: String) {
        if stdout_orig_fd < 0 {
            stdout_orig_fd = linux::dup(1)
            stdout_orig = cstd::fdopen(stdout_orig_fd, "w".value)
        }
        stdout_fh = open(file, "w")
        linux::dup2(cstd::fileno(stdout_fh), 1)
    }

    export def restore_stderr {
        linux::dup2(stderr_orig_fd, 2)
        close(stderr_fh)
    }

    export def restore_stdout {
        linux::dup2(stdout_orig_fd, 1)
        close(stdout_fh)
    }

    export const _IONBF = 2
    const F_SETFL = 4
    
    #if defined MACOS {
        const O_NONBLOCK = 4
    } else {
        const O_NONBLOCK = 2048
    }

    export def pipe(mode: int = 0) -> File, File {
        var res: [2; int]

        linux::pipe(res.value)
        if mode & NO_BLOCKING {
            linux::fcntl(res(0), F_SETFL, O_NONBLOCK) 
        }

        let r = cstd::fdopen(res(0), "r".value)
        let w = cstd::fdopen(res(1), "w".value)
        cstd::setvbuf(r, null, _IONBF, 0)
        cstd::setvbuf(w, null, _IONBF, 0)

        return r, w
            
    }

    export def is_a_tty(file: File) -> bool {
        return linux::isatty(cstd::fileno(file)) != 0
    }

    export def open_memory_as_file(arr: [uint8], mode: String) -> File {
        return cstd::fmemopen(arr.value, arr.size, mode.to_array().value)
    }
}