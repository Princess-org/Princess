export type Type = &interface {
    let name: string
    let module: string
    let id: uint64
    let size: size_t
    let align: size_t
}

export def implements(a: Type, b: StructuralT) -> bool {
    return false
}

export def assignable(a: Type, b: Type) -> bool {
    return false
}

export def == (a: Type, b: Type) -> bool {
    return a.id == b.id
}
export def != (a: Type, b: Type) -> bool {
    return not (a == b)
}

type BaseType = struct {
    name: string
    module: string
    id: uint64
}

export type OpaqueT = &struct {
    BaseType
    const size: size_t = 1
    const algin: size_t = 1
}

export type BoolT = &struct {
    BaseType
    const size: size_t = size_of bool
    const align: size_t = align_of bool
}
export type FloatT = &struct {
    BaseType
    size: size_t
    align: size_t
}
export type WordT = &struct {
    BaseType
    signed: bool
    size: size_t
    align: size_t
}
export type CharT = &struct {
    BaseType
    const size: size_t = size_of char
    const align: size_t = align_of char
}

export type BoxType = struct {
    BaseType
    ref: Type
}

export type PointerT = &struct {
    BoxType
    const size: size_t = size_of *
    const align: size_t = align_of *
}
export type ReferenceT = &struct {
    BoxType
    const size: size_t = size_of &
    const align: size_t = align_of &
}
export type WeakReferenceT = &struct {
    BoxType
    const size: size_t = size_of weak_ref
    const align: size_t = align_of weak_ref
}
export type ArrayT = &struct {
    BoxType
    const size: size_t = size_of [*]
    const align: size_t = align_of [*]
}
export type StaticArrayT = &struct {
    BoxType
    size: size_t
    align: size_t
    length: size_t
}

export type FunctionT = &struct {
    BaseType
    arguments: [Type]
    returns: [Type]
    const size: size_t = size_of ->
    const align: size_t = align_of ->
}

type RecordType = struct {
    BaseType
    size: size_t
    align: size_t
    members: [Field]
}
export type Field = struct {
    name: string
    offset: size_t
    tpe: *Type
}
export type Struct = &struct {
    RecordType
}
export type Union = &struct {
    RecordType
}

export type EnumValue = struct {
    name: string
    value: int64
}
export type EnumT = &struct {
    BaseType
    signed: bool
    size: size_t
    align: size_t
    values: [EnumValue]
}

export type Function = struct {
    name: string
    exported: bool
    module: string
    tpe: &FunctionT
}

export type InterfaceT = &struct {
    BaseType
    const size: size_t = 0
    const align: size_t = 0
    members: [Function]
}

export type VariantT = &struct {
    BaseType
    size: size_t
    align: size_t
    variants: [Type]
}

export type TupleT = &struct {
    BaseType
    size: size_t
    align: size_t
    elements: [Type]
}

var types: [Type]
var upper_id: int64

type TypeKind = enum {
    BOOL
    WORD
    FLOAT
    STRUCT
    UNION
    ARRAY
    STATIC_ARRAY
    POINTER
    REFERENCE
    FUNCTION
    ENUM
    CHAR
    STRUCTURAL
    OPAQUE
    WEAK_REF
    TYPE
    VARIANT
    TUPLE
}

// Type registry functions 
def load_types(size: size_t, data: *uint8, strings: *char) {
    var index = 0
    var offset = 0
    while index < size {
        index += 1
    }
}

def type_id(index: size_t) -> Type {
    return types ++ index
}