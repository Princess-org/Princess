export type Type = &interface {
    let name: string
    let module: string
    let id: uint64
    let size: size_t
    let align: size_t
}

export def implements(a: Type, b: StructuralT) -> bool {
    return false
}

export def assignable(a: Type, b: Type) -> bool {
    return false
}

export def == (a: Type, b: Type) -> bool {
    return a.id == b.id
}
export def != (a: Type, b: Type) -> bool {
    return not (a == b)
}

type BaseType = struct {
    name: string
    module: string
    id: uint64
}

export type OpaqueT = &struct {
    BaseType
    const size: size_t = 1
    const algin: size_t = 1
}

export type BoolT = &struct {
    BaseType
    const size: size_t = size_of bool
    const align: size_t = align_of bool
}
export type FloatT = &struct {
    BaseType
    size: size_t
    align: size_t
}
export type WordT = &struct {
    BaseType
    signed: bool
    size: size_t
    align: size_t
}
export type CharT = &struct {
    BaseType
    const size: size_t = size_of char
    const align: size_t = align_of char
}

export type BoxType = struct {
    BaseType
    ref: weak Type
}

export type PointerT = &struct {
    BoxType
    const size: size_t = size_of *
    const align: size_t = align_of *
}
export type ReferenceT = &struct {
    BoxType
    const size: size_t = size_of &
    const align: size_t = align_of &
}
export type WeakReferenceT = &struct {
    BoxType
    const size: size_t = size_of weak_ref
    const align: size_t = align_of weak_ref
}
export type ArrayT = &struct {
    BoxType
    const size: size_t = size_of [*]
    const align: size_t = align_of [*]
}
export type StaticArrayT = &struct {
    BoxType
    size: size_t
    align: size_t
    length: size_t
}

export type FunctionT = &struct {
    BaseType
    arguments: &[weak Type]
    returns: &[weak Type]
    const size: size_t = size_of ->
    const align: size_t = align_of ->
}

type RecordT = struct {
    BaseType
    size: size_t
    align: size_t
    members: &[Field]
}
export type Field = struct {
    name: string
    offset: size_t
    tpe: weak Type
}
export type StructT = &struct {
    RecordT
}
export type UnionT = &struct {
    RecordT
}

export type EnumValue = struct {
    name: string
    value: int64
}
export type EnumT = &struct {
    BaseType
    signed: bool
    size: size_t
    align: size_t
    values: &[EnumValue]
}

export type Function = struct {
    name: string
    exported: bool
    module: string
    tpe: FunctionT
}

export type InterfaceT = &struct {
    BaseType
    const size: size_t = 0
    const align: size_t = 0
    members: &[Function]
}

export type VariantT = &struct {
    BaseType
    size: size_t
    align: size_t
    variants: &[weak Type]
}

export type TupleT = &struct {
    BaseType
    size: size_t
    align: size_t
    elements: &[weak Type]
}

type TypeKind = enum {
    BOOL
    WORD
    FLOAT
    STRUCT
    UNION
    ARRAY
    STATIC_ARRAY
    POINTER
    REFERENCE
    WEAK_REF
    FUNCTION
    ENUM
    CHAR
    STRUCTURAL
    VARIANT
    TUPLE
}

import io
import map

var types: &Map(size_t, Type)

// Type registry functions 
def load_types(data: [uint8], num: size_t, strings: *char) {
    let fp = io::open_memory_as_file(data, "r")
    defer close(fp)

    if not types {
        types = map::make(size_t, Type)
    }

    var index = 0
    while index < num {
        let kind = fp.read(TypeKind)
        let name = make_string(strings ++ fp.read(int))
        let module = make_string(strings ++ fp.read(int))
        let id = fp.read(size_t)

        switch kind {
        case TypeKind::BOOL
            types(index) = [ name = name, module = module, id = id ] !BoolT
        case TypeKind::WORD
            let size = fp.read(int)
            let align = fp.read(int)
            let signed = fp.read(bool)
            types(index) = [ name = name, module = module, id = id, 
                size = size, align = align, signed = signed ] !WordT
        case TypeKind::FLOAT
            let size = fp.read(int)
            let align = fp.read(int)
            types(index) = [ name = name, module = module, id = id, 
                size = size, align = align ] !FloatT
        case TypeKind::STRUCT, TypeKind::UNION
            let size = fp.read(int)
            let align = fp.read(int)
            let members = zero_allocate(Field, fp.read(int))
            for var i in 0..members.size {
                members(i) = [ name = make_string(strings ++ fp.read(int)), offset = fp.read(int) ] !Field
            }

            if kind == TypeKind::STRUCT {
                types(index) = [ name = name, module = module, id = id, 
                    size = size, align = align, members = members ] !StructT
            } else {
                types(index) = [ name = name, module = module, id = id, 
                    size = size, align = align, members = members ] !UnionT
            }
        case TypeKind::ARRAY
            types(index) = [ name = name, module = module, id = id ] !ArrayT
        case TypeKind::STATIC_ARRAY
            let size = fp.read(size_t)
            let align = fp.read(size_t)
            let length = fp.read(size_t)

            types(index) = [ name = name, module = module, id = id, 
                size = size, align = align, length = length ] !StaticArrayT
        case TypeKind::POINTER
            types(index) = [ name = name, module = module, id = id ] !PointerT
        case TypeKind::REFERENCE
            types(index) = [ name = name, module = module, id = id ] !ReferenceT
        case TypeKind::WEAK_REF
            types(index) = [ name = name, module = module, id = id ] !WeakReferenceT
        case TypeKind::FUNCTION
            types(index) = [ name = name, module = module, id = id,
                arguments = allocate_ref(type weak Type, fp.read(int)),
                returns = allocate_ref(type weak Type, fp.read(int)) ] !FunctionT
        case TypeKind::ENUM
            let size = fp.read(int)
            let align = fp.read(int)
            let signed = fp.read(bool)

            let values = allocate_ref(type EnumValue, fp.read(int))
            for var i in 0..values.size {
                values(i) = [ 
                    name = make_string(strings ++ fp.read(int)), 
                    value = fp.read(int64) 
                ] !EnumValue
            }
            types(index) = [ name = name, module = module, id = id, 
                size = size, align = align, values = values ] !EnumT
        case TypeKind::CHAR
            types(index) = [ name = name, module = module, id = id ] !CharT
        case TypeKind::STRUCTURAL
            let members = allocate_ref(type Function, fp.read(int))
            for var i in 0..members.size {
                members(i) = [
                    name = make_string(strings ++ fp.read(int)),
                    exported = fp.read(bool),
                    module = make_string(strings ++ fp.read(int))
                ] !Function
            }
            types(index) = [ name = name, module = module, id = id, members = members ] !InterfaceT
        case TypeKind::VARIANT
            types(index) = [ name = name, module = module, id = id,
                variants = allocate_ref(type weak Type, fp.read(int))
            ] !VariantT
        case TypeKind::TUPLE
            types(index) = [ name = name, module = module, id = id,
                elements = allocate_ref(type weak Type, fp.read(int))
            ] !TupleT
        }

        index += 1
    }

    // Resolve type references
    for var tpe in types {
        if tpe.type == StructT {
            let rec = tpe !StructT
            for var i in 0..rec.fields.size {
                let f = *rec.fields(i)
                f.tpe = type_id(fp.read(int))
            }
        } else if tpe.type == UnionT {
            let rec = tpe !UnionT
            for var i in 0..rec.fields.size {
                let f = *rec.fields(i)
                f.tpe = type_id(fp.read(int))
            }
        } else if tpe.type == InterfaceT {
            let intf = tpe !InterfaceT
            for var i in 0..intf.members.size {
                let m = *inf.members(i)
                m.tpe = type_id(fp.read(int)) !FunctionT
            }
        } else if tpe.type == PointerT {
            (box !PointerT).tpe = type_id(fp.read(int))
        } else if tpe.type == ReferenceT {
            (box !ReferenceT).tpe = type_id(fp.read(int))
        } else if tpe.type == WeakReferenceT {
            (box !WeakReferenceT).tpe = type_id(fp.read(int))
        } else if tpe.type == ArrayT {
            (box !ArrayT).tpe = type_id(fp.read(int))
        } else if tpe.type == StaticArrayT {
            (box !StaticArrayT).tpe = type_id(fp.read(int))
        } else if (tpe.type == VariantT) {
            let vnt = tpe !VariantT
            for var i in 0..vnt.variants.size {
                vnt.variants(i) = type_id(fp.read(int))
            }
        } else if (tpe.type == TupleT) {
            let tuple = tpe !TupleT
            for var i in 0..vnt.elements.size {
                vnt.elements(i) = type_id(fp.read(int))
            }
        } else if (tpe.type == FunctionT) {
            let fun = tpe !FunctionT
            for var i in 0..fun.arguments.size {
                fun.arguments(i) = type_id(fp.read(int))
            }
            for var i in 0..fun.returns.size {
                fun.returns(i) = type_id(fp.read(int))
            }
        }
    }
}

def type_id(index: size_t) -> Type {
    return types(index)
}